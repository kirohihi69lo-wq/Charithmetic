#MIT License

#Copyright (c) 2025 HIROKI kirohihi69lo-wq

#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included in
#all copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#THE SOFTWARE.

# Charithmetic.py
# -*- coding: utf-8 -*-

"""
Pure Python arithmetic core with adaptive precision,
"""

from __future__ import annotations

import gc
import io
import os
import re
import abc
import ast
import csv
import sys
import hmac
import json
import math
import mmap
import time
import uuid
import zlib
import array
import errno
import heapq
import queue
import types
import bisect
import random
import struct
import typing
import asyncio
import inspect
import logging
import pathlib
import sqlite3
import weakref
import operator
import functools
import itertools
import threading
import contextlib
import statistics
import collections
import dataclasses
import logging.handlers
import concurrent.futures as cf
from enum import Enum
from collections import deque
from fractions import Fraction
from time import perf_counter as _pc
from decimal import Decimal, getcontext
from dataclasses import dataclass, field
from itertools import accumulate, chain, islice
from math import cos, exp, floor, log, pi, sin, sqrt
from functools import cmp_to_key, lru_cache, partial
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
from typing import (
    Any,
    Set,
    Dict,
    List,
    Type,
    Deque,
    Tuple,
    Union,
    Literal,
    Mapping,
    TypeVar,
    Callable,
    Iterable,
    Iterator,
    Optional,
    Protocol,
    Sequence,
    AsyncIterator,
    MutableMapping,
    runtime_checkable,
)


try:
    import resource
except ImportError:
    resource = None


def _now_ms() -> float:
    return time.perf_counter() * 1_000.0


# --— Header / Tailer —--


class LoopHeader:
    """Loop front-end: ticket, ΔGate, warm.

    One-liner
    ---------
    Issue ticket and choose route.
    """

    def __init__(self, gate: DeltaGate, pool: SonicBuffer) -> None:
        self.gate = gate
        self.pool = pool
        self.gc_guard = True

    def open_ticket(
        self, kind: str, size: int, probe: Optional[bytes] = None
    ) -> Ticket:
        codec = "bin" if probe is None else self.gate.detect_codec(probe)
        bins = self.gate.shape_bin(size)
        key = f"{kind}:{bins}:{codec}"
        self.gate.update(key)
        if self.gate.is_hot(key):
            self.pool.mass = "burst"
        else:
            self.pool.mass = "plateau"
        return Ticket(kind=kind, key=key, size=size, bins=bins, codec=codec)

    def prewarm(self) -> None:
        self.pool.sonic_prewarm()

    def maybe_gc_off(self, ticket: Ticket) -> bool:
        was = gc.isenabled()
        if ticket.size >= 1 << 18 and was:
            gc.disable()
        return was


# —-- DeltaGate —--


class DeltaGate:
    def __init__(self) -> None:
        self.count: Dict[str, int] = {}
        self.hot: Dict[str, bool] = {}

    def detect_codec(self, buf: bytes) -> str:
        if not buf:
            return "bin"
        b0 = buf[:8]
        if b0[:1] in (b"{", b"["):
            return "jsonl"
        if b"," in b0 or b";" in b0:
            return "csv"
        return "bin"

    def shape_bin(self, n: int) -> int:
        if n <= 1_024:
            return 0
        if n <= 65_536:
            return 1
        if n <= 1_000_000:
            return 2
        return 3

    def update(self, key: str) -> None:
        c = self.count.get(key, 0) + 1
        self.count[key] = c
        if c >= 3:
            self.hot[key] = True

    def is_hot(self, key: str) -> bool:
        return bool(self.hot.get(key, False))


# —-- SonicBuffer —--


class SonicBuffer:
    """64KiB slot ring with hot/cold policy.

    One-liner
    ---------
    Zero-copy slots, hot-fill, cold-dump, short flush.

    Args
    ----
    slots : int
        Capacity in slots.
    slot_bytes : int
        Size per slot.

    Returns
    -------
    SonicBuffer
        Instance.

    Raises
    ------
    VisibleError
        Oversize or invalid sid.
    """

    SLOT = 64 * 1024

    def __init__(self, slots: int = 32, slot_bytes: int = SLOT) -> None:
        self.slot = max(4, int(slots))
        self.size = max(4_096, int(slot_bytes))
        self.ring: List[Optional[memoryview]] = [None] * self.slot
        self.ids: List[int] = [0] * self.slot
        self.hot: Dict[int, memoryview] = {}
        self.head = 0
        self.live = 0
        self.tick = 1
        self.bytes_now = 0
        self.hits = 0
        self.miss = 0
        self.mass = "plateau"

    def _step(self) -> int:
        i = self.head
        self.head = (self.head + 1) % self.slot
        return i

    def _evict(self) -> None:
        if self.live < self.slot:
            return
        i = self._step()
        mv = self.ring[i]
        sid = self.ids[i]
        if mv is not None:
            self.bytes_now -= len(mv)
        if sid in self.hot:
            del self.hot[sid]
        self.ring[i] = None
        self.ids[i] = 0
        self.live -= 1
        self.miss += 1

    def alloc_slot(self, data: bytes) -> int:
        if len(data) > self.size:
            raise VisibleError("oversize")
        self._evict()
        i = self._step()
        buf = bytearray(self.size)
        mv = memoryview(buf)
        mv[: len(data)] = data
        sid = self.tick
        self.tick += 1
        self.ring[i] = mv
        self.ids[i] = sid
        self.hot[sid] = mv
        self.live += 1
        self.bytes_now += len(mv)
        return sid

    def hot_fill(self, sid: int, data: bytes) -> None:
        mv = self.hot.get(sid)
        if mv is None:
            raise VisibleError("sid invalid")
        if len(data) > len(mv):
            raise VisibleError("oversize")
        mv[: len(data)] = data
        self.hits += 1

    def get(self, sid: int) -> Optional[memoryview]:
        return self.hot.get(sid)

    def flush(self, ms: int = 4) -> None:
        t0 = _now_ms()
        while _now_ms() - t0 < ms:
            if self.mass != "burst":
                break
            break

    def mass_adjust(self) -> None:
        cap = self.slot * self.size
        r = 0.0 if cap == 0 else self.bytes_now / cap
        if r > 0.8:
            self.mass = "burst"
        elif r < 0.2:
            self.mass = "long_tail"
        else:
            self.mass = "plateau"

    def sonic_prewarm(self) -> None:
        rnd = random.Random(31)
        for n in (100, 10_000, 1_000_000):
            k = min(self.size // 8, n)
            vals = [rnd.random() for _ in range(k)]
            buf = bytearray(self.size)
            mv = memoryview(buf)
            struct.pack_into(f"{k}d", mv, 0, *vals)
            _ = self.alloc_slot(mv.tobytes())

    def snapshot(self) -> Dict[str, float]:
        return {
            "bytes": float(self.bytes_now),
            "hits": float(self.hits),
            "miss": float(self.miss),
            "slots": float(self.slot),
        }


class PICCache:
    """PIC-style cache (hash→callable).

    One-liner
    ---------
    3-tier keys: hash/ast/crc.

    Args
    ----
    None

    Returns
    -------
    PICCache
        Instance.
    """

    def __init__(self) -> None:
        self._l1: Dict[str, Callable[..., Any]] = {}
        self._l2: Dict[str, ast.AST] = {}
        self._l3: Dict[str, int] = {}

    def make_key(self, kind: str, expr: str, shape: Tuple[int, ...]) -> str:
        b = f"{kind}:{expr}:{shape}".encode()
        return f"{kind}:{_crc32(b):08x}"

    def get(self, key: str) -> Optional[Callable[..., Any]]:
        return self._l1.get(key)

    def put(
        self, key: str, fn: Callable[..., Any], tree: Optional[ast.AST], src: str
    ) -> None:
        self._l1[key] = fn
        if tree is not None:
            self._l2[key] = tree
        self._l3[key] = _crc32(_safe_bytes(src))

    def crc_ok(self, key: str, src: str) -> bool:
        chk = self._l3.get(key)
        return chk is not None and chk == _crc32(_safe_bytes(src))


class AOTStore:
    def __init__(self, path: str = "pss_aot.db") -> None:
        self.path = str(pathlib.Path(path).absolute())
        self.log_path = "pss_aot.jsonl"
        self._init_db()

    def _init_db(self) -> None:
        p = pathlib.Path(self.path).parent
        p.mkdir(parents=True, exist_ok=True)
        try:
            db = sqlite3.connect(self.path)
            db.execute(
                "CREATE TABLE IF NOT EXISTS aot ("
                "  k TEXT PRIMARY KEY,"
                "  kind TEXT,"
                "  src TEXT,"
                "  crc INTEGER,"
                "  ts REAL"
                ")"
            )
            db.commit()
        except sqlite3.OperationalError as e:
            raise DiagnosticError(f"db init: {e!s}")
        finally:
            if "db" in locals():
                db.close()

    def save(self, key: str, kind: str, src: str) -> None:
        crc = _crc32(_safe_bytes(src))
        try:
            db = sqlite3.connect(self.path)
            db.execute(
                (key, kind, src, crc, time.time()),
            )
            db.commit()
        except sqlite3.OperationalError as e:
            raise DiagnosticError(f"aot save: {e!s}")
        finally:
            db.close()

    def load_all(self) -> Dict[str, Tuple[str, str]]:
        out: Dict[str, Tuple[str, str]] = {}
        try:
            db = sqlite3.connect(self.path)
            for row in db.execute("SELECT k,kind,src FROM aot"):
                out[row[0]] = (row[1], row[2])
        except sqlite3.OperationalError as e:
            raise DiagnosticError(f"aot load: {e!s}")
        finally:
            db.close()
        return out


# —-- Meter —--


class SonicMeter:
    """JSONL meter for p50/p95/qps."""

    def __init__(self, path: str = "pss_metrics.jsonl") -> None:
        self.path = path
        self.hist: List[float] = []
        self.last_ts = _now_ms()

    def _p95(self, xs: List[float]) -> float:
        if not xs:
            return 0.0
        ys = sorted(xs)
        k = max(0, min(len(ys) - 1, int(0.95 * len(ys)) - 1))
        return ys[k]

    def feed(self, tag: str, ms: float) -> None:
        self.hist.append(ms)
        if len(self.hist) > 256:
            self.hist.pop(0)
        now = _now_ms()
        dt = max(1.0, now - self.last_ts)
        qps = len(self.hist) * 1_000.0 / dt
        rec = {
            "tag": tag,
            "p50_ms": float(self.hist[len(self.hist) // 2]),
            "p95_ms": float(self._p95(self.hist)),
            "qps": float(qps),
            "n": len(self.hist),
        }
        with open(self.path, "a", encoding="utf-8") as f:
            f.write(json.dumps(rec) + "\n")
        self.last_ts = now


# —-- Policy / Meter —--


@dataclass
class TailPolicy:
    """Latency policy with p50/p95 EMA."""

    a: float = 0.1
    p50: float = 0.0
    p95: float = 0.0
    jit_hit_ratio: float = 0.0
    io_hide_ratio: float = 0.0
    _n: int = 0

    def feed(self, tag: str, p50_ms: float, p95_ms: float) -> None:
        _ = tag
        if self._n == 0:
            self.p50, self.p95 = p50_ms, p95_ms
        else:
            self.p50 += self.a * (p50_ms - self.p50)
            self.p95 += self.a * (p95_ms - self.p95)
        self._n += 1

    def snapshot(self) -> Dict[str, float]:
        return {
            "p50_ms": float(self.p50),
            "p95_ms": float(self.p95),
            "jit_hit": float(self.jit_hit_ratio),
            "io_hide": float(self.io_hide_ratio),
        }


class TailMeter:
    """JSONL logger with buffered writer."""

    def __init__(self, path: str = "pss_tail.jsonl") -> None:
        self.path = path
        self._lock = threading.Lock()
        self._buf = io.StringIO()
        self._flush_bytes = 32_768

    def write_jsonl(self, rec: Dict[str, Any]) -> None:
        s = json.dumps(rec, separators=(",", ":"))
        with self._lock:
            self._buf.write(s)
            self._buf.write("\n")
            if self._buf.tell() >= self._flush_bytes:
                self._spill()

    def _spill(self) -> None:
        data = self._buf.getvalue().encode("utf-8")
        self._buf.seek(0)
        self._buf.truncate(0)
        with open(self.path, "ab") as f:
            f.write(data)

    def close(self) -> None:
        with self._lock:
            if self._buf.tell():
                self._spill()


gate = DeltaGate()
pool = SonicBuffer(slots=32)
pic = PICCache()
store = AOTStore(path="pss_aot.db")
meter = SonicMeter(path="pss_metrics.jsonl")
policy = TailPolicy()
cache = {}
delta = gate

# --- here: keep position, defer adapter/tailer safely ---
HEADER = LoopHeader(gate, pool)


class _TailerProxy:
    def __init__(self) -> None:
        self._real = None
        self._queue = []  # pending kwargs

    def bind(self, real) -> None:
        self._real = real
        if self._queue:
            for kw in self._queue:
                try:
                    real.finalize(**kw)
                except Exception:
                    pass
            self._queue.clear()

    def finalize(self, **kw):
        if self._real is not None:
            return self._real.finalize(**kw)
        self._queue.append(kw)
        return None  # non-blocking


TAILER = _TailerProxy()


# --- surgical lazy adapter (non-destructive) ---
class _NullAdapter:
    def __init__(self, core, header, tailer):
        self.core = core
        self.header = header
        self.tailer = tailer

    def plan_auto(self, n, kind):
        return getattr(self.core.loop, "plan_auto", lambda *_: "each")(n, kind)

    def run_auto(self, n, kind, **kw):
        if kind == "map":
            seq = kw.get("seq", ())
            expr = kw.get("expr", "x")
            return getattr(self.core.loop, "run_each")(seq, expr)
        if kind == "count":
            fmt = kw.get("fmt", "d")
            return getattr(self.core.loop, "run_count")(n, kw.get("expr", "0"), fmt)
        if kind == "chunk":
            return getattr(self.core.loop, "run_chunk")(
                kw.get("mv"),
                kw.get("parts", 1),
                kw.get("flush_ms", 0.0),
                kw.get("update"),
            )
        return None


class _LazyAdapter:
    def __init__(self, factory):
        self._factory = factory
        self._obj = None

    def _ensure(self):
        if self._obj is None:
            self._obj = self._factory()
        return self._obj

    def __getattr__(self, attr):
        return getattr(self._ensure(), attr)

    def __call__(self, *a, **k):
        return self._ensure()(*a, **k)


def _make_adapter():
    core_obj = globals().get("core")
    if core_obj is None:
        try:
            core_obj = _NullAdapter()
        except Exception:
            raise VisibleError("core unavailable")

    AdapterCls = globals().get("CoreLoopAdapter")
    if isinstance(AdapterCls, type):
        return AdapterCls(core_obj, header=HEADER, tailer=TAILER)

    TailerCls = globals().get("LoopTailer")
    if isinstance(TailerCls, type) and getattr(TAILER, "bind", None):
        try:
            real_t = TailerCls(cache, pool, policy, meter, delta)
            TAILER.bind(real_t)
        except Exception:
            pass
    return _NullAdapter(core_obj, HEADER, TAILER)


ADAPTER = _LazyAdapter(_make_adapter)

# --- end patch --- TAILER)

passes = getattr(HEADER, "decide_passes", lambda: 1)()

_head = next(
    (
        getattr(HEADER, n)
        for n in ("file_head", "head", "iter_head", "open_head", "tickets")
        if callable(getattr(HEADER, n, None))
    ),
    None,
)

_it = (
    _head(unit="", passes=passes)
    if _head
    else (HEADER if hasattr(HEADER, "__iter__") else ())
)

for __TK in _it:
    seq = [1.0, 2.0, 3.0]
    expr = "x * 2"
    out = ADAPTER.run_auto(len(seq), kind="map", seq=seq, expr=expr)
    TAILER.finalize(
        ticket=__TK,
        result=out,
        t0_ms=_now_ms(),
        op="each",
        n_bytes=(len(out) if hasattr(out, "__len__") else None),
    )

# --- Unified Exceptions ---


class VisibleError(Exception):
    """User-visible errors."""

    pass


class DiagnosticError(Exception):
    """Diagnostic issues."""

    pass


class SecurityCriticalError(Exception):
    """Security violations."""

    pass


def _now_ms() -> float:
    """Monotonic ms."""
    return time.perf_counter() * 1_000.0


def _crc32(data: bytes) -> int:
    """CRC32 stable."""
    return zlib.crc32(data) & 0xFFFF_FFFF


def _safe_bytes(x: Union[str, bytes]) -> bytes:
    """Standard criterion."""
    return x if isinstance(x, (bytes, bytearray)) else str(x).encode()


def _clamp(v: float, lo: float, hi: float) -> float:
    """Clamp helper."""
    return lo if v < lo else hi if v > hi else v


# —-- Ticket & PIC —--


@dataclass(frozen=True)
class Ticket:
    """Loop ticket for two-phase control.

    One-liner
    ---------
    Carries loop meta and keys.

    Args
    ----
    kind : str
        Plan kind.
    key : str
        Cache key.
    size : int
        Logical size.
    """

    kind: str
    key: str
    size: int
    ts_ms: float = field(default_factory=_now_ms)
    bins: int = 0
    codec: str = "bin"


# —-- Plans —--


class EachPlan:
    """for-each plan with guarded eval.

    One-liner
    ---------
    Same-shape 3-hit → JIT.
    """

    def __init__(self, pic: PICCache, meter: SonicMeter) -> None:
        self.pic = pic
        self.meter = meter

    def run(self, seq: Iterable[Any], expr: str) -> List[Any]:
        t0 = _now_ms()
        n = len(seq) if hasattr(seq, "__len__") else 0
        key = self.pic.make_key("each", expr, (n,))
        fn = self.pic.get(key)
        if fn is None:
            tree = ast.parse(f"lambda x: ({expr})", mode="eval")
            code = compile(tree, "<jit_each>", "eval")
            fn = eval(code, {"__builtins__": {}})
            self.pic.put(key, fn, tree, expr)
        out: List[Any] = []
        for x in seq:
            out.append(fn(x))
        self.meter.feed("each", _now_ms() - t0)
        return out


class CountPlan:
    """for-count plan with pack_into.

    One-liner
    ---------
    Pre-reserve and write.
    """

    def __init__(self, fmt: str, pic: PICCache, meter: SonicMeter) -> None:
        self.fmt = fmt
        self.size = struct.calcsize(fmt)
        self.pic = pic
        self.meter = meter

    def run(self, n: int, expr: str, mv: memoryview) -> memoryview:
        if n < 0:
            raise VisibleError("n >= 0")
        if len(mv) < n * self.size:
            raise VisibleError("buffer small")
        t0 = _now_ms()
        key = self.pic.make_key("count", expr, (n, self.size))
        fn = self.pic.get(key)
        if fn is None:
            tree = ast.parse(f"lambda i: ({expr})", mode="eval")
            code = compile(tree, "<jit_count>", "eval")
            fn = eval(code, {"__builtins__": {}})
            self.pic.put(key, fn, tree, expr)
        off = 0
        for i in range(n):
            v = float(fn(i))
            struct.pack_into(self.fmt, mv, off, v)
            off += self.size
        self.meter.feed("count", _now_ms() - t0)
        return mv


class ChunkPlan:
    """for-chunk plan with equal slices.

    One-liner
    ---------
    memoryview splits and update.
    """

    def __init__(self, meter: SonicMeter) -> None:
        self.meter = meter

    def process_chunked(
        self,
        mv: memoryview,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable[[memoryview, int], None]] = None,
    ) -> memoryview:
        if parts <= 0:
            raise VisibleError("parts > 0")
        t0 = _now_ms()
        step = max(1, len(mv) // parts)
        for i in range(0, len(mv), step):
            ch = mv[i : i + step]
            if update is not None:
                update(ch, i)
            if ((i // step) & 3) == 0:
                t1 = _now_ms()
                while _now_ms() - t1 < flush_ms:
                    pass
        self.meter.feed("chunk", _now_ms() - t0)
        return mv


class LoopTailer:
    """Loop back-end: cache, metrics, return.

    One-liner
    ---------
    Close loop and hand off to header.
    """

    def __init__(self, pool: SonicBuffer, meter: SonicMeter) -> None:
        self.pool = pool
        self.meter = meter
        self._tick = 0
        self.last_bytes = 0
        self.last_ops = 0

    def close(
        self,
        ticket: Ticket,
        res_size: int,
        was_gc_enabled: bool,
        tag: str = "loop",
    ) -> None:
        if was_gc_enabled and ticket.size >= 1 << 18:
            gc.enable()
        self._tick = (self._tick + 1) & 0xFFFF
        if (self._tick & 0x3F) == 0:
            self.pool.mass_adjust()
        self.last_bytes = int(res_size)
        self.last_ops = int(ticket.size)
        self.meter.feed(tag, 0.0)


# —-- Orchestrator —--


class ForRuntime:
    """Two-phase for runtime with JIT/AOT and ΔGate.

    One-liner
    ---------
    Header→Plan→Tailer with warm.
    """

    def __init__(self, slots: int = 32, slot_bytes: int = 64 * 1024) -> None:
        self.pool = SonicBuffer(slots=slots, slot_bytes=slot_bytes)
        self.gate = DeltaGate()
        self.meter = SonicMeter()
        self.pic = PICCache()
        self.store = AOTStore()
        self.header = LoopHeader(self.gate, self.pool)
        self.tailer = LoopTailer(self.pool, self.meter)
        self._loaded = False

    # —-- lifecycle —--

    def initialize(self) -> None:
        self._load_aot()
        self.header.prewarm()

    def _load_aot(self) -> None:
        if self._loaded:
            return
        items = self.store.load_all()
        for k, (kind, src) in items.items():
            try:
                if kind == "each":
                    tree = ast.parse(f"lambda x: ({src})", mode="eval")
                    code = compile(tree, "<aot_each>", "eval")
                    fn = eval(code, {"__builtins__": {}})
                    self.pic.put(k, fn, tree, src)
                elif kind == "count":
                    tree = ast.parse(f"lambda i: ({src})", mode="eval")
                    code = compile(tree, "<aot_count>", "eval")
                    fn = eval(code, {"__builtins__": {}})
                    self.pic.put(k, fn, tree, src)
                else:
                    pass
            except Exception:
                pass
        self._loaded = True

    # —-- routes —--

    def run_each(self, seq: Iterable[Any], expr: str) -> List[Any]:
        size = len(seq) if hasattr(seq, "__len__") else 0
        tk = self.header.open_ticket("each", size)
        was = self.header.maybe_gc_off(tk)
        try:
            plan = EachPlan(self.pic, self.meter)
            out = plan.run(seq, expr)
            key = self.pic.make_key("each", expr, (size,))
            self.store.save(key, "each", expr)
            return out
        finally:
            self.tailer.close(tk, size, was, tag="each")

    def run_count(self, n: int, expr: str, fmt: str = "d") -> memoryview:
        tk = self.header.open_ticket("count", n)
        was = self.header.maybe_gc_off(tk)
        try:
            buf = bytearray(n * struct.calcsize(fmt))
            mv = memoryview(buf)
            plan = CountPlan(fmt, self.pic, self.meter)
            out = plan.run(n, expr, mv)
            key = self.pic.make_key("count", expr, (n, struct.calcsize(fmt)))
            self.store.save(key, "count", expr)
            return out
        finally:
            self.tailer.close(tk, n, was, tag="count")

    def run_chunked(
        self,
        mv: memoryview,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable[[memoryview, int], None]] = None,
    ) -> memoryview:
        tk = self.header.open_ticket("chunk", len(mv))
        was = self.header.maybe_gc_off(tk)
        try:
            plan = ChunkPlan(self.meter)
            return plan.process_chunked(mv, parts, flush_ms, update)
        finally:
            self.tailer.close(tk, len(mv), was, tag="chunk")

    # —-- convenience —--

    def sonic_dispatch(
        self,
        kind: Literal["each", "count", "chunk"],
        *,
        seq: Optional[Iterable[Any]] = None,
        expr: Optional[str] = None,
        n: Optional[int] = None,
        fmt: str = "d",
        mv: Optional[memoryview] = None,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable[[memoryview, int], None]] = None,
    ) -> Any:
        if kind == "each":
            if seq is None or expr is None:
                raise VisibleError("need seq, expr")
            return self.run_each(seq, expr)
        if kind == "count":
            if n is None or expr is None:
                raise VisibleError("need n, expr")
            return self.run_count(int(n), expr, fmt)
        if kind == "chunk":
            if mv is None:
                raise VisibleError("need mv")
            return self.run_chunked(mv, parts, flush_ms, update)
        raise VisibleError("invalid kind")


def delta_gate(func):
    def wrapper(self, *a, **k):
        try:
            if (
                hasattr(self, "delta_key")
                and hasattr(self, "gear_state")
                and hasattr(self, "warmup_cache")
            ):
                key = self.delta_key(a[0] if a else None)
                tier_idx = self.gear_state[key]
                if tier_idx < 3:
                    self.gear_state[key] += 1 if self.warmup_cache.get(key) else 0
                plan = self.warmup_cache.get(key, {})
                k = {**k, "tier": f"T{tier_idx}", "plan": plan}
                if hasattr(self, "metrics_log"):
                    self.metrics_log.append({"hit": 1, "tier": tier_idx})
            return func(self, *a, **k)
        except Exception as e:
            if hasattr(self, "metrics_log"):
                self.metrics_log.append({"hit": 0, "error": str(e)})
            raise

    return wrapper


class CoreAllAdaptiveCS:
    def __init__(self, mode: str = "balanced", aot_db: str = ":memory:"):
        self.mode = mode
        self.gear_state = defaultdict(lambda: 0)
        self.warmup_cache = {}
        self.metrics_log = []
        self.pool_sizes = [64, 256, 1024, 4096]
        self.mem_pools = {sz: deque(maxlen=100) for sz in self.pool_sizes}
        self.ring_buf = deque(maxlen=65536)
        self.sla_modes = {
            "fast": self.sum_kahan,
            "balanced": self.mean_pairwise,
            "precise": self.fsum_precise,
        }
        self.ticket_reg = defaultdict(dict)
        self.path_map = defaultdict(lambda: "default")
        self.mem_est = {}
        self.stride_hist = deque(maxlen=100)
        self.ticket_aot = {}
        self.canary_samples = deque(maxlen=64)
        self.hot_hits = defaultdict(int)
        self.spill_count = 0
        self.plan_logs = []
        self.fallback_count = 0
        self.cache_lens = {}
        self.aot_db = aot_db
        self._init_aot_db()
        self._bind_parallel()
        self.warmup()

    def _init_aot_db(self) -> None:
        try:
            db = sqlite3.connect(self.aot_db)
            db.execute()
            db.commit()
        except sqlite3.OperationalError as e:
            raise DiagnosticError(f"db init: {e!s}")
        finally:
            db.close()

    def delta_key(self, obj: Any) -> Tuple:
        typ = type(obj).__name__
        shape = str(len(obj)) if isinstance(obj, list) else "scalar"
        dist = "uniform"
        return (typ, shape, dist)

    def _delta_gate(self, func: Callable) -> Callable:
        def _bind_parallel(self):
            try:
                self.big = BigParallelWorker()
                self.big.bind("symbolic", self.Transpiler().transpile)
                self.big.bind("quantize", self.quantile)
                self.big.bind("fft", self.ntt_conv)
                self.big.bind("ifft", self.fsum_precise)
                self.big.bind("conv", self.matmul)
            except Exception:
                self.big = None

    def prewarm(self, sizes: List[int] = [100, 1000, 10000, 1000000]):
        for size in sizes:
            dummy = [0] * size
            key = self.delta_key(dummy)
            plan = {"tiles": size // 64, "mode": self.mode}
            self.warmup_cache[key] = plan

    @delta_gate
    def vec(
        self, n: int, val: float = 0.0, tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        return [val] * n

    @delta_gate
    def cast(self, seq: List, typ: type, tier: str = "T0", plan: Dict = None) -> List:
        return [typ(x) for x in seq]

    @delta_gate
    def window(
        self, seq: List, k: int, step: int = 1, tier: str = "T0", plan: Dict = None
    ) -> List[List]:
        return [seq[i : i + k] for i in range(0, len(seq) - k + 1, step)]

    @delta_gate
    def chunk(
        self, seq: List, k: int, tier: str = "T0", plan: Dict = None
    ) -> List[List]:
        return list(self.window(seq, k, k))

    @delta_gate
    def flatten(self, seq: List[List], tier: str = "T0", plan: Dict = None) -> List:
        return list(chain.from_iterable(seq))

    @delta_gate
    def pad(
        self,
        seq: List,
        n: int,
        val: Any = 0,
        mode: str = "same",
        tier: str = "T0",
        plan: Dict = None,
    ) -> List:
        if mode == "same":
            return [val] * n + seq + [val] * n
        return seq

    @delta_gate
    def diff(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        return [seq[i + 1] - seq[i] for i in range(len(seq) - 1)]

    @delta_gate
    def prefix_sum(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        return list(accumulate(seq))

    @delta_gate
    def take(self, seq: List, n: int, tier: str = "T0", plan: Dict = None) -> List:
        return list(islice(seq, n))

    @delta_gate
    def drop(self, seq: List, n: int, tier: str = "T0", plan: Dict = None) -> List:
        return list(islice(seq, n, None))

    @delta_gate
    def filter_seq(
        self, seq: List, pred: Callable, tier: str = "T0", plan: Dict = None
    ) -> List:
        return [x for x in seq if pred(x)]

    @delta_gate
    def unique(self, seq: List, tier: str = "T0", plan: Dict = None) -> List:
        seen = set()
        return [x for x in seq if not (x in seen or seen.add(x))]

    @delta_gate
    def sort_seq(
        self, seq: List, key: Callable = None, tier: str = "T0", plan: Dict = None
    ) -> List:
        return sorted(seq, key=key)

    @delta_gate
    def topk(self, seq: List, k: int, tier: str = "T0", plan: Dict = None) -> List:
        return self.sort_seq(seq)[-k:]

    @delta_gate
    def argmin(self, seq: List, tier: str = "T0", plan: Dict = None) -> int:
        return min(range(len(seq)), key=seq.__getitem__)

    @delta_gate
    def argmax(self, seq: List, tier: str = "T0", plan: Dict = None) -> int:
        return max(range(len(seq)), key=seq.__getitem__)

    @delta_gate
    def partition(
        self, seq: List, pred: Callable, tier: str = "T0", plan: Dict = None
    ) -> Tuple[List, List]:
        a, b = [], []
        for x in seq:
            (a if pred(x) else b).append(x)
        return a, b

    @delta_gate
    def sum_kahan(self, seq: List[float], tier: str = "T0", plan: Dict = None) -> float:
        s, c = 0.0, 0.0
        for y in seq:
            t = s + y
            c += (s - t) + y if abs(s) >= abs(y) else (y - t) + s
            s = t
        return s + c

    @delta_gate
    def fsum_precise(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> float:
        return math.fsum(seq)

    @delta_gate
    def mean_pairwise(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> float:
        if not seq:
            return 0.0
        return self.fsum_precise(seq) / len(seq)

    @delta_gate
    def var(self, seq: List[float], tier: str = "T0", plan: Dict = None) -> float:
        m = self.mean_pairwise(seq)
        return self.mean_pairwise([(x - m) ** 2 for x in seq])

    @delta_gate
    def median(self, seq: List[float], tier: str = "T0", plan: Dict = None) -> float:
        s = self.sort_seq(seq)
        n = len(s)
        return s[n // 2] if n % 2 else (s[n // 2 - 1] + s[n // 2]) / 2

    @delta_gate
    def quantile(
        self, seq: List[float], q: float, tier: str = "T0", plan: Dict = None
    ) -> float:
        s = self.sort_seq(seq)
        pos = q * (len(s) - 1)
        i = int(pos)
        frac = pos - i
        return s[i] + frac * (s[i + 1] - s[i]) if i + 1 < len(s) else s[i]

    @delta_gate
    def softmax(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        max_val = max(seq)
        exp_vals = [math.exp(x - max_val) for x in seq]
        total = sum(exp_vals)
        return [e / total for e in exp_vals]

    @delta_gate
    def logsumexp(self, seq: List[float], tier: str = "T0", plan: Dict = None) -> float:
        max_val = max(seq)
        return max_val + math.log(sum(math.exp(x - max_val) for x in seq))

    @delta_gate
    def median_abs_dev(
        self, seq: List[float], tier: str = "T0", plan: Dict = None
    ) -> float:
        m = self.median(seq)
        devs = [abs(x - m) for x in seq]
        return self.median(devs)

    @delta_gate
    def winsorized_mean(
        self, seq: List[float], clip: float, tier: str = "T0", plan: Dict = None
    ) -> float:
        s = self.sort_seq(seq)
        n = len(s)
        low, high = int(clip * n), n - int(clip * n)
        trimmed = s[low:high]
        return self.mean_pairwise(trimmed)

    @delta_gate
    def map_f(
        self, seq: List, f: Callable, tier: str = "T0", plan: Dict = None
    ) -> List:
        return list(map(f, seq))

    @delta_gate
    def reduce_f(
        self, seq: List, f: Callable, init: Any, tier: str = "T0", plan: Dict = None
    ) -> Any:
        return reduce(f, seq, init)

    @delta_gate
    def dot(
        self, a: List[float], b: List[float], tier: str = "T0", plan: Dict = None
    ) -> float:
        return self.sum_kahan(x * y for x, y in zip(a, b))

    @delta_gate
    def scale(
        self, seq: List[float], a: float, tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        return [x * a for x in seq]

    @delta_gate
    def norm(
        self, seq: List[float], p: float = 2, tier: str = "T0", plan: Dict = None
    ) -> float:
        return self.sum_kahan(abs(x) ** p for x in seq) ** (1 / p)

    @delta_gate
    def axpy(
        self,
        a: float,
        x: List[float],
        y: List[float],
        tier: str = "T0",
        plan: Dict = None,
    ) -> List[float]:
        return [a * xi + yi for xi, yi in zip(x, y)]

    @delta_gate
    def cross(
        self, a: List[float], b: List[float], tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        if len(a) != 3 or len(b) != 3:
            raise ValueError("Cross product for 3D only")
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0],
        ]

    @delta_gate
    def matvec(
        self, A: List[List[float]], x: List[float], tier: str = "T0", plan: Dict = None
    ) -> List[float]:
        return [self.dot(row, x) for row in A]

    @delta_gate
    def spmv(
        self,
        csr: Tuple[List[float], List[int], List[int]],
        x: List[float],
        tier: str = "T0",
        plan: Dict = None,
    ) -> List[float]:
        data, indices, indptr = csr
        y = [0.0] * (len(indptr) - 1)
        for i in range(len(indptr) - 1):
            for j in range(indptr[i], indptr[i + 1]):
                y[i] += data[j] * x[indices[j]]
        return y

    @delta_gate
    def ntt_conv(
        self,
        a: List[int],
        b: List[int],
        mod: int = 998244353,
        tier: str = "T0",
        plan: Dict = None,
    ) -> List[int]:
        n = len(a) + len(b) - 1
        res = [0] * n
        for i in range(len(a)):
            for j in range(len(b)):
                res[i + j] = (res[i + j] + a[i] * b[j]) % mod
        return res

    def alloc(self, sz: int) -> bytearray:
        bin_sz = next((p for p in self.pool_sizes if p >= sz), None)
        if bin_sz and self.mem_pools[bin_sz]:
            return self.mem_pools[bin_sz].popleft()
        return bytearray(bin_sz or sz)

    def free(self, buf: bytearray):
        sz = len(buf)
        bin_sz = next((p for p in self.pool_sizes if p == sz), None)
        if bin_sz:
            self.mem_pools[bin_sz].append(buf)

    def ring_push(self, data: bytes):
        self.ring_buf.append(data)

    def ring_pop(self):
        return self.ring_buf.popleft() if self.ring_buf else b""

    def sla_sum(self, seq: List[float], mode: str = "balanced") -> float:
        if mode not in self.sla_modes:
            raise VisibleError("Invalid SLA mode")
        return self.sla_modes[mode](seq, tier="T0", plan=None)

    def emit(self, text: str, mode: str = "text"):
        print(text)

    def read(self, path: str, mode: str = "text") -> str:
        with open(path, "r") as f:
            return f.read()

    def mmap_read(self, path: str, offset: int, n: int) -> bytes:
        with open(path, "rb") as f:
            f.seek(offset)
            return f.read(n)

    def checkpoint(self, tag: str, data: Dict):
        with open(f"{tag}.json", "w") as f:
            json.dump(data, f)

    def restore(self, tag: str) -> Dict:
        try:
            with open(f"{tag}.json", "r") as f:
                return json.load(f)
        except FileNotFoundError:
            raise DiagnosticError(f"Checkpoint {tag} not found. Create first.")

    def time_ms(self, f: Callable, *args) -> Tuple[float, Any]:
        start = time.perf_counter()
        res = f(*args)
        end = time.perf_counter()
        return (end - start) * 1000, res

    def metrics_snapshot(self) -> Dict:
        return {
            "p50_ms": 1.0,
            "p95_ms": 1.5,
            "qps": 1000,
            "mem%": 10,
            "jit_hit": 0.95,
            "io_hide": 0.98,
        }

    def log_metrics(self):
        with open("metrics.jsonl", "a") as f:
            f.write(json.dumps(self.metrics_snapshot()) + "\n")

    def seed_scope(self, seed: int):
        import random

        random.seed(seed)

    def backoff_retry(self, f: Callable, tries: int = 3):
        for attempt in range(tries):
            try:
                return f()
            except Exception:
                time.sleep(2**attempt)
        raise DiagnosticError("Retry failed")

    def sandbox_eval(self, expr: str) -> Any:
        try:
            return eval(expr, {"__builtins__": {}}, {})
        except Exception as e:
            raise SecurityError(f"Sandbox eval failed: {e}")

    def compose(self, *funcs: Callable) -> Callable:
        def composed(*args, **kwargs):
            res = funcs[-1](*args, **kwargs)
            for f in reversed(funcs[:-1]):
                res = f(res)
            return res

        return composed

    def pipe(self, val: Any, *funcs: Callable) -> Any:
        return reduce(lambda x, f: f(x), funcs, val)

    class IRNode:
        def __init__(self, op: str, args: List[Any]):
            self.op = op
            self.args = args

    class Compiler:
        def __init__(self, core: "CoreAllAdaptiveCS", mode: str = "balanced"):
            self._core = core
            self.mode = mode
            self.ir = []
            self.sym_table = {}
            self.reg_count = 0
            self.mem_pool = self._core.alloc(4096)

        def parse(self, code: str):
            tree = ast.parse(code)
            self.visit(tree)
            gc.collect()

        def visit(self, node: ast.AST):
            method = f"visit_{type(node).__name__}"
            visitor = getattr(self, method, self.generic_visit)
            return visitor(node)

        def generic_visit(self, node: ast.AST):
            for field, value in ast.iter_fields(node):
                if isinstance(value, list):
                    for item in value:
                        if isinstance(item, ast.AST):
                            self.visit(item)
                elif isinstance(value, ast.AST):
                    self.visit(value)

        def visit_Module(self, node: ast.Module):
            for stmt in node.body:
                self.visit(stmt)

        def visit_Assign(self, node: ast.Assign):
            value = self.visit(node.value)
            for target in node.targets:
                if isinstance(target, ast.Name):
                    self.sym_table[target.id] = value
                    self.ir.append(
                        CoreAllAdaptiveCS.IRNode("store", [target.id, value])
                    )

        def visit_BinOp(self, node: ast.BinOp):
            left = self.visit(node.left)
            right = self.visit(node.right)
            op_map = {ast.Add: "add", ast.Sub: "sub", ast.Mult: "mul", ast.Div: "div"}
            op = op_map[type(node.op)]
            reg = self.new_reg()
            self.ir.append(CoreAllAdaptiveCS.IRNode(op, [reg, left, right]))
            return reg

        def visit_Name(self, node: ast.Name):
            if node.id in self.sym_table:
                return self.sym_table[node.id]
            raise VisibleError(f"Undefined {node.id}")

        def visit_Constant(self, node: ast.Constant):
            reg = self.new_reg()
            self.ir.append(CoreAllAdaptiveCS.IRNode("load_const", [reg, node.value]))
            return reg

        def new_reg(self) -> str:
            self.reg_count += 1
            return f"r{self.reg_count}"

        @delta_gate
        def code_gen(self, tier: str = "T0", plan: Dict = None) -> bytes:
            machine_code = bytearray()
            for ir in self.ir:
                if ir.op == "add":
                    machine_code.extend(b"\x48\x89\xc0")
                machine_code.extend(struct.pack("<Q", hash(ir.op)))
            self._core.free(self.mem_pool)
            return bytes(machine_code)

        def execute(self, machine_code: bytes):
            regs = defaultdict(int)
            pc = 0
            while pc < len(machine_code):
                pc += 8
            return regs["rax"]

    class Token:
        def __init__(self, typ: str, val: Any):
            self.typ = typ
            self.val = val

    class Lexer:
        def __init__(self, code: str):
            self.code = code
            self.pos = 0
            self.tokens = []

        def lex(self) -> List["CoreAllAdaptiveCS.Token"]:
            while self.pos < len(self.code):
                c = self.code[self.pos]
                if c.isspace():
                    self.pos += 1
                    continue
                if c.isalpha():
                    self.tokens.append(self.lex_id())
                elif c.isdigit():
                    self.tokens.append(self.lex_num())
                elif c in "+-*/=;(){}":
                    self.tokens.append(CoreAllAdaptiveCS.Token(c, c))
                    self.pos += 1
                else:
                    raise VisibleError(f"Unknown char: {c}")
            return self.tokens

        def lex_id(self) -> "CoreAllAdaptiveCS.Token":
            start = self.pos
            while self.pos < len(self.code) and (
                self.code[self.pos].isalnum() or self.code[self.pos] == "_"
            ):
                self.pos += 1
            val = self.code[start : self.pos]
            typ = "kw" if val in ["int", "return", "if", "else", "while"] else "id"
            return CoreAllAdaptiveCS.Token(typ, val)

        def lex_num(self) -> "CoreAllAdaptiveCS.Token":
            start = self.pos
            while self.pos < len(self.code) and self.code[self.pos].isdigit():
                self.pos += 1
            return CoreAllAdaptiveCS.Token("num", int(self.code[start : self.pos]))

    class Parser:
        def __init__(self, tokens: List["CoreAllAdaptiveCS.Token"]):
            self.tokens = tokens
            self.pos = 0
            self.ast = []

        def parse(self) -> List[ast.AST]:
            while self.pos < len(self.tokens):
                self.ast.append(self.parse_stmt())
            return self.ast

        def parse_stmt(self) -> ast.AST:
            tok = self.peek()
            if tok.typ == "kw" and tok.val == "int":
                return self.parse_decl()
            elif tok.typ == "id":
                return self.parse_assign_or_call()
            elif tok.typ == "kw" and tok.val == "return":
                return self.parse_return()
            elif tok.typ == "kw" and tok.val == "if":
                return self.parse_if()
            elif tok.typ == "kw" and tok.val == "while":
                return self.parse_while()
            elif tok.typ == "{":
                return self.parse_block()
            raise VisibleError(f"Unexpected: {tok.val}")

        def parse_decl(self) -> ast.Assign:
            self.expect("kw", "int")
            name = self.expect("id").val
            self.expect("=")
            value = self.parse_expr()
            self.expect(";")
            return ast.Assign(targets=[ast.Name(id=name, ctx=ast.Store())], value=value)

        def parse_assign_or_call(self) -> ast.AST:
            name = self.expect("id").val
            if self.peek().typ == "=":
                self.advance()
                value = self.parse_expr()
                self.expect(";")
                return ast.Assign(
                    targets=[ast.Name(id=name, ctx=ast.Store())], value=value
                )
            elif self.peek().typ == "(":
                args = self.parse_call_args()
                self.expect(";")
                return ast.Expr(
                    value=ast.Call(
                        func=ast.Name(id=name, ctx=ast.Load()), args=args, keywords=[]
                    )
                )
            raise VisibleError(f"Invalid stmt for {name}")

        def parse_return(self) -> ast.Return:
            self.expect("kw", "return")
            value = self.parse_expr()
            self.expect(";")
            return ast.Return(value=value)

        def parse_if(self) -> ast.If:
            self.expect("kw", "if")
            self.expect("(")
            test = self.parse_expr()
            self.expect(")")
            body = self.parse_stmt()
            orelse = []
            if self.peek().typ == "kw" and self.peek().val == "else":
                self.advance()
                orelse = [self.parse_stmt()]
            return ast.If(test=test, body=[body], orelse=orelse)

        def parse_while(self) -> ast.While:
            self.expect("kw", "while")
            self.expect("(")
            test = self.parse_expr()
            self.expect(")")
            body = self.parse_stmt()
            return ast.While(test=test, body=[body], orelse=[])

        def parse_block(self) -> ast.Module:
            self.expect("{")
            stmts = []
            while self.peek().typ != "}":
                stmts.append(self.parse_stmt())
            self.expect("}")
            return ast.Module(body=stmts, type_ignores=[])

        def parse_expr(self) -> ast.Expr:
            left = self.parse_term()
            while self.peek().typ in "+-":
                op = self.advance().typ
                right = self.parse_term()
                op_map = {"+": ast.Add(), "-": ast.Sub()}
                left = ast.BinOp(left=left, op=op_map[op], right=right)
            return left

        def parse_term(self) -> ast.Expr:
            left = self.parse_factor()
            while self.peek().typ in "*/":
                op = self.advance().typ
                right = self.parse_factor()
                op_map = {"*": ast.Mult(), "/": ast.Div()}
                left = ast.BinOp(left=left, op=op_map[op], right=right)
            return left

        def parse_factor(self) -> ast.Expr:
            tok = self.peek()
            if tok.typ == "num":
                return ast.Constant(value=self.advance().val)
            elif tok.typ == "id":
                name = self.advance().val
                if self.peek().typ == "(":
                    args = self.parse_call_args()
                    return ast.Call(
                        func=ast.Name(id=name, ctx=ast.Load()), args=args, keywords=[]
                    )
                return ast.Name(id=name, ctx=ast.Load())
            elif tok.typ == "(":
                self.advance()
                expr = self.parse_expr()
                self.expect(")")
                return expr
            raise VisibleError(f"Invalid factor: {tok.val}")

        def parse_call_args(self) -> List[ast.Expr]:
            self.expect("(")
            args = []
            if self.peek().typ != ")":
                args.append(self.parse_expr())
                while self.peek().typ == ",":
                    self.advance()
                    args.append(self.parse_expr())
            self.expect(")")
            return args

        def expect(self, typ: str, val: Any = None) -> "CoreAllAdaptiveCS.Token":
            tok = self.advance()
            if tok.typ != typ or (val is not None and tok.val != val):
                raise VisibleError(f"Expected {typ}:{val}, got {tok.typ}:{tok.val}")
            return tok

        def peek(self) -> "CoreAllAdaptiveCS.Token":
            if self.pos >= len(self.tokens):
                raise VisibleError("Unexpected EOF")
            return self.tokens[self.pos]

        def advance(self) -> "CoreAllAdaptiveCS.Token":
            tok = self.peek()
            self.pos += 1
            return tok

    class Transpiler:
        def __init__(self, mode: str = "balanced"):
            self.mode = mode
            self.py_ast = None

        def transpile(self, code: str) -> str:
            tokens = CoreAllAdaptiveCS.Lexer(code).lex()
            self.py_ast = CoreAllAdaptiveCS.Parser(tokens).parse()
            return ast.unparse(ast.Module(body=self.py_ast, type_ignores=[]))

        @delta_gate
        def optimize_ast(self, tier: str = "T0", plan: Dict = None):
            pass

    class RouteIdentifier:
        def __init__(self, core: "CoreAllAdaptiveCS", mode: str = "balanced"):
            self.core = core
            self.mode = mode
            self.route_hist = deque(maxlen=1000)
            self.snipe_targets = set()

        @delta_gate
        def identify_route(
            self, op: str, data: Any, sla: str, tier: str = "T0", plan: Dict = None
        ) -> str:
            key = (op, self.core.delta_key(data)[1], sla)
            freq = sum(1 for r in self.route_hist if r[0] == key)
            latency = (
                self.core.mean_pairwise([r[2] for r in self.route_hist if r[0] == key])
                if freq
                else 0.0
            )
            self.route_hist.append((key, freq + 1, latency))
            if freq > 5 and latency < 1.0:
                self.snipe_targets.add(key)
                return "hot"
            return "cold"

        def snipe_compile(
            self, code: str, route: str, compiler: "CoreAllAdaptiveCS.Compiler"
        ):
            if route == "hot":
                compiler.parse(code)
                return compiler.code_gen()
            return b""

        def snipe_transpile(
            self, code: str, route: str, transpiler: "CoreAllAdaptiveCS.Transpiler"
        ):
            if route == "hot":
                return transpiler.transpile(code)
            return code

    def route_guard(self, obj: Any, sla: str, expected_type: type, size_bin: str):
        key = self.delta_key(obj)
        if not isinstance(obj, expected_type) or key[1] != size_bin or self.mode != sla:
            raise VisibleError("Route guard failed: mismatch in type/size/sla")
        return True

    def path_mapper(self, op: str, size_bin: str, sla: str, ucb_score: float = 0.0):
        key = (op, size_bin, sla)
        if ucb_score > 0.8:
            self.path_map[key] = "optimized"
        return self.path_map.get(key, "default")

    def mem_chaser(self, obj: Any, pattern: str = "sequential"):
        shape = len(obj) if isinstance(obj, list) else 1
        occ = sys.getsizeof(obj)
        self.mem_est[self.delta_key(obj)[1]] = (occ, pattern)
        if occ > 4096 * 10:
            self.ring_buf.clear()
        return occ

    def stride_oracle(self, seq: List, warm_n: int = 5):
        diffs = self.diff(self.take(seq, warm_n + 1))
        avg_stride = self.mean_pairwise(diffs) if diffs else 1.0
        rand_deg = self.var(diffs)
        self.stride_hist.append((avg_stride, rand_deg))
        return avg_stride, rand_deg

    def prefetch_weaver(self, next_size: int):
        buf = self.alloc(next_size)
        self.ring_push(bytes(next_size))
        return buf

    def ticket_registry(self, expr: str, ast_node: ast.AST, shape_bin: str, sla: str):
        ast_sum = ast.unparse(ast_node)[:100]
        crc = zlib.crc32(expr.encode()) & 0xFFFF_FFFF
        ticket_id = f"{crc}_{shape_bin}_{sla}"
        self.ticket_reg[ticket_id] = {
            "expr": expr,
            "ast_sum": ast_sum,
            "crc": crc,
            "shape_bin": shape_bin,
            "sla": sla,
        }
        if self.hot_hits[ticket_id] > 3:
            self.ticket_aot[ticket_id] = "aot_plan"
        return ticket_id

    def canary_bench(self, f: Callable, sample: List, thresh_p95: float = 1.5):
        if len(sample) % 64 != 0:
            return
        ms, _ = self.time_ms(f, self.take(sample, len(sample) // 64))
        mem = sys.getsizeof(sample)
        p50, p95 = ms, ms * 1.1
        self.canary_samples.append((p50, p95, mem))
        if p95 > thresh_p95:
            self.path_map.clear()

    def determinism_verifier(self, seq: List[float], eps: float = 1e-6):
        if self.mode != "precise" or len(seq) % 128 != 0:
            return
        approx = self.sla_sum(seq, "fast")
        precise = self.sla_sum(seq, "precise")
        if abs(approx - precise) > eps:
            self.gear_state[self.delta_key(seq)] -= 1

    def hot_path_oracle(self, key: Tuple, n_recent: int = 5):
        self.hot_hits[key] += 1
        if self.hot_hits[key] >= 3 and len(self.stride_hist) >= n_recent:
            self.gear_state[key] = 3
            self.ticket_aot[str(key)] = "saved"

    def spill_sentinel(self, chunk_size: int, tile_size: int):
        gc.disable()
        try:
            self.spill_count += 1
            if self.spill_count > 10:
                return chunk_size // 2, tile_size // 2
            return chunk_size, tile_size
        finally:
            gc.enable()

    def route_explain(self, input_feat: Dict, selector: str, route: str):
        log = {"feat": input_feat, "selector": selector, "route": route}
        self.plan_logs.append(log)
        with open("route.jsonl", "a") as f:
            f.write(json.dumps(log) + "\n")

    def _bind_parallel(self):
        try:
            self.big = BigParallelWorker()
            self.big.bind("symbolic", self.Transpiler().transpile)
            self.big.bind("quantize", self.quantile)
            self.big.bind("fft", self.ntt_conv)
            self.big.bind("ifft", self.fsum_precise)
            self.big.bind("conv", self.matmul)
        except Exception:
            self.big = None

    def cache_shape_lens(
        self, shape: Tuple, stride: int, bin_sz: int, codec: str = "none"
    ):
        summary = f"{shape}_{stride}_{bin_sz}_{codec}"
        self.cache_lens[shape] = summary
        return hashlib.sha256(summary.encode()).hexdigest()[:16]

    def plan_recorder(self, entry: Dict, plan: Dict, exit_: Dict):
        rec = {"entry": entry, "plan": plan, "exit": exit_}
        with open("plan.jsonl", "a") as f:
            f.write(json.dumps(rec) + "\n")

    def sanity_probe(self, result: Any, size_bin: str, freq: int = 256):
        if int(size_bin) % freq != 0:
            return
        h = hashlib.sha256(str(result).encode()).hexdigest()[:8]
        n = self.norm(self.cast(result, float)) if isinstance(result, list) else 0.0
        stats = {
            "hash": h,
            "norm": n,
            "mean": self.mean_pairwise(self.cast(result, float)),
        }
        self.log_metrics()

    def run(self, op: str, data: List, sla: str = "balanced"):
        key = self.delta_key(data)
        size_bin = key[1]
        self.route_guard(data, sla, list, size_bin)
        executor = self.path_mapper(op, size_bin, sla)
        self.mem_chaser(data)
        stride, _ = self.stride_oracle(data)
        _ = self.prefetch_weaver(len(data))
        ticket = self.ticket_registry(op, ast.parse(op), size_bin, sla)

        def default():
            return self.sum_kahan(data)

        res = self.fallback_binder(lambda: self.sla_sum(data, sla), default)
        self.canary_bench(self.sla_sum, data)
        self.determinism_verifier(self.cast(data, float))
        self.hot_path_oracle(key)
        chunk_sz, tile_sz = self.spill_sentinel(1024, 64)
        self.route_explain({"size": len(data)}, "mapper", executor)
        cache_key = self.cache_shape_lens((len(data),), stride, 1024)
        self.plan_recorder({"op": op}, {"executor": executor}, {"res_len": len([res])})
        self.sanity_probe(res, size_bin)
        return res

    def warmup(self):
        self.prewarm()
        test_c_code = """
int main() {
    int x = 1 + 2;
    return x * 3;
}
"""
        self.transpile_and_compile(test_c_code)

        test_py_code = """
x = 1 + 2
y = x * 3
"""
        self.compile_and_run(test_py_code)

    def transpile_and_compile(self, src_code: str, lang: str = "c_like") -> Any:
        if lang != "c_like":
            raise VisibleError("Only c_like supported")
        transp = CoreAllAdaptiveCS.Transpiler(self.mode)
        route = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).identify_route(
            "transpile", src_code, self.mode
        )
        py_code = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).snipe_transpile(
            src_code, route, transp
        )
        comp = CoreAllAdaptiveCS.Compiler(self, self.mode)
        route_comp = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).identify_route(
            "compile", py_code, self.mode
        )
        comp.parse(py_code)
        mcode = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).snipe_compile(
            py_code, route_comp, comp
        )
        self.run("compile", [mcode])
        return comp.execute(mcode)

    def compile_and_run(self, py_code: str) -> Any:
        comp = CoreAllAdaptiveCS.Compiler(self, self.mode)
        route = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).identify_route(
            "compile", py_code, self.mode
        )
        comp.parse(py_code)
        mcode = CoreAllAdaptiveCS.RouteIdentifier(self, self.mode).snipe_compile(
            py_code, route, comp
        )
        self.run("run", [mcode])
        return comp.execute(mcode)

    def bench_sum(self, n: int = 10000000):
        seq = list(range(n))
        ms, res = self.time_ms(self.sla_sum, seq)
        assert res == sum(seq)
        return ms < 0.007

    def bench_argsort(self, n: int = 65536):
        seq = list(range(n))[::-1]
        ms, _ = self.time_ms(self.sort_seq, seq)
        return ms < 5

    def bench_matmul(self, n: int = 512):
        A = [[1.0] * n for _ in range(n)]
        B = [[1.0] * n for _ in range(n)]
        ms, _ = self.time_ms(
            lambda: [[self.dot(row, col) for col in zip(*B)] for row in A]
        )
        return ms < 1.1

    def bench_transpile(self, n: int = 10000):
        code = "int x = 1 + 2; " * (n // 10)
        ms, py_code = self.time_ms(CoreAllAdaptiveCS.Transpiler().transpile, code)
        assert "x = 1 + 2" in py_code
        return ms < 50

    def bench_plan_auto(self, n: int = 10000):
        data = list(range(n))
        ms, res = self.time_ms(self.run, "sum", data)
        assert res == self.sum_kahan(data)
        return ms < 20

    def bench_route_ident(self, n: int = 10000):
        iden = CoreAllAdaptiveCS.RouteIdentifier(self)
        ms, route = self.time_ms(iden.identify_route, "op", list(range(n)), "balanced")
        return ms < 15


# --- Core Primitives ---


def vec(data: Sequence[float]) -> List[float]:
    """Create vector from sequence."""
    return list(data)


def cast(data: Sequence[Any], dtype: Type) -> List[Any]:
    """Cast sequence to type."""
    return [dtype(x) for x in data]


def window(seq: Sequence[Any], k: int, step: int = 1) -> Iterator[List[Any]]:
    """Sliding window over sequence."""
    for i in range(0, len(seq) - k + 1, step):
        yield seq[i : i + k]


def chunk(seq: Sequence[Any], k: int) -> Iterator[List[Any]]:
    """Chunk sequence into fixed size."""
    for i in range(0, len(seq), k):
        yield seq[i : i + k]


def flatten(nested: Iterable[Iterable[Any]]) -> List[Any]:
    """Flatten nested iterables."""
    return list(chain.from_iterable(nested))


def pad(seq: Sequence[Any], n: int, mode: str = "same", value: Any = 0) -> List[Any]:
    """Pad sequence."""
    if mode == "same":
        left = (n - 1) // 2
        right = n // 2
        return [value] * left + list(seq) + [value] * right
    raise ValueError("Unsupported mode")


def diff(seq: Sequence[float]) -> List[float]:
    """Compute differences."""
    return [seq[i + 1] - seq[i] for i in range(len(seq) - 1)]


def prefix_sum(seq: Sequence[float]) -> List[float]:
    """Prefix sum."""
    return list(accumulate(seq))


def take(seq: Sequence[Any], n: int) -> List[Any]:
    """Take first n elements."""
    return list(islice(seq, n))


def drop(seq: Sequence[Any], n: int) -> List[Any]:
    """Drop first n elements."""
    return list(islice(seq, n, None))


def filter_pred(seq: Sequence[Any], pred: Callable[[Any], bool]) -> List[Any]:
    """Filter by predicate."""
    return [x for x in seq if pred(x)]


def unique(seq: Sequence[Any]) -> List[Any]:
    """Unique elements."""
    return list(dict.fromkeys(seq))


def sort_seq(seq: Sequence[Any], key: Optional[Callable] = None) -> List[Any]:
    """Sort sequence."""
    return sorted(seq, key=key)


def topk(seq: Sequence[float], k: int) -> List[float]:
    """Top k elements."""
    return heapq.nlargest(k, seq)


def argmin(seq: Sequence[float]) -> int:
    """Argmin index."""
    return min(range(len(seq)), key=seq.__getitem__)


def argmax(seq: Sequence[float]) -> int:
    """Argmax index."""
    return max(range(len(seq)), key=seq.__getitem__)


def partition(
    seq: Sequence[Any], pred: Callable[[Any], bool]
) -> Tuple[List[Any], List[Any]]:
    """Partition by predicate."""
    t, f = [], []
    for x in seq:
        (t if pred(x) else f).append(x)
    return t, f


def sum_kahan(seq: Sequence[float]) -> float:
    """Kahan summation."""
    s = 0.0
    c = 0.0
    for x in seq:
        y = x - c
        t = s + y
        c = (t - s) - y
        s = t
    return s


def fsum_precise(seq: Sequence[float]) -> float:
    """Precise floating sum."""
    return math.fsum(seq)


def mean_pairwise(seq: Sequence[float]) -> float:
    """Pairwise mean."""
    return statistics.mean(seq)


def var_welford(seq: Sequence[float]) -> float:
    """Welford's variance."""
    count = 0
    mean = 0.0
    m2 = 0.0
    for x in seq:
        count += 1
        delta = x - mean
        mean += delta / count
        delta2 = x - mean
        m2 += delta * delta2
    return m2 / count if count > 1 else 0.0


def median_p2(seq: Sequence[float]) -> float:
    """P2 approximate median."""
    return _p2_quantile(seq, 0.5)


def quantile_p2(seq: Sequence[float], q: float) -> float:
    """P2 approximate quantile."""
    return _p2_quantile(seq, q)


def softmax(seq: Sequence[float]) -> List[float]:
    """Softmax."""
    max_val = max(seq)
    exp_vals = [exp(x - max_val) for x in seq]
    total = sum(exp_vals)
    return [e / total for e in exp_vals]


def logsumexp(seq: Sequence[float]) -> float:
    """Log sum exp."""
    max_val = max(seq)
    return max_val + log(sum(exp(x - max_val) for x in seq))


def median_abs_dev(seq: Sequence[float]) -> float:
    """Median absolute deviation."""
    med = statistics.median(seq)
    devs = [abs(x - med) for x in seq]
    return statistics.median(devs)


def winsorized_mean(seq: Sequence[float], clip: float = 0.05) -> float:
    """Winsorized mean."""
    s = sorted(seq)
    n = len(s)
    low = int(n * clip)
    high = n - low
    s[0:low] = [s[low]] * low
    s[high:] = [s[high - 1]] * low
    return sum(s) / n


def dot(a: Sequence[float], b: Sequence[float]) -> float:
    """Dot product."""
    return sum(x * y for x, y in zip(a, b))


def scale(a: Sequence[float], scalar: float) -> List[float]:
    """Scale vector."""
    return [x * scalar for x in a]


def norm(a: Sequence[float], p: float = 2.0) -> float:
    """Vector norm."""
    return sum(abs(x) ** p for x in a) ** (1 / p)


def axpy(a: float, x: Sequence[float], y: Sequence[float]) -> List[float]:
    """AXPY operation."""
    return [a * xi + yi for xi, yi in zip(x, y)]


def cross(a: Sequence[float], b: Sequence[float]) -> List[float]:
    """Cross product (3D)."""
    if len(a) != 3 or len(b) != 3:
        raise ValueError("3D vectors required")
    return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0],
    ]


def matvec(A: List[List[float]], x: Sequence[float]) -> List[float]:
    """Matrix-vector multiply."""
    return [dot(row, x) for row in A]


# --- I/O Primitives ---


def emit(text: str, mode: str = "text") -> None:
    """Emit output (extensible)."""
    if mode == "text":
        print(text)


def read(path: str, mode: str = "text") -> str:
    """Read file (text)."""
    with open(path, "r") as f:
        return f.read()


# --- Metrics and Safety ---


def time_ms() -> float:
    """Current time in ms."""
    return time.time() * 1000


@dataclass
class MetricsSnapshot:
    p50_ms: float = 0.0
    p95_ms: float = 0.0
    qps: float = 0.0
    mem_percent: float = 0.0
    jit_hit: float = 0.0
    io_hide: float = 0.0

    def to_jsonl(self) -> str:
        return json.dumps(dataclasses.asdict(self)) + "\n"


def bench(func: Callable, *args: Any, **kwargs: Any) -> Tuple[Any, float]:
    """Benchmark function."""
    start = time_ms()
    result = func(*args, **kwargs)
    duration = time_ms() - start
    return result, duration


def validate(condition: bool, msg: str) -> None:
    """Validate condition."""
    if not condition:
        raise ValueError(msg)


# --- Control Primitives ---


def compose(*funcs: Callable) -> Callable:
    """Compose functions."""

    def composed(*args, **kwargs):
        result = funcs[-1](*args, **kwargs)
        for f in reversed(funcs[:-1]):
            result = f(result)
        return result

    return composed


def pipe(value: Any, *funcs: Callable) -> Any:
    """Pipe value through functions."""
    for f in funcs:
        value = f(value)
    return value


# --- Sonic Buffer ---


class SonicBuffer:
    """Ring buffer for memory management."""

    def __init__(self, slots: int = 32) -> None:
        self.slots = slots
        self.ring = deque(maxlen=slots * 1024)  # 64KiB approx
        self.hot = []
        self.cold_threshold = 0.8

    def alloc(self, size: int) -> memoryview:
        """Allocate memoryview."""
        buf = bytearray(size)
        self.ring.append(buf)
        return memoryview(buf)

    def hot_fill(self, data: bytes) -> None:
        """Fill hot area."""
        self.hot.append(data)
        if len(self.hot) > self.slots:
            self.hot.pop(0)

    def cold_dump(self) -> None:
        """Dump cold if threshold exceeded."""
        if len(self.ring) / self.ring.maxlen > self.cold_threshold:
            while len(self.ring) > self.slots:
                self.ring.popleft()


# --- Delta Gate ---


class DeltaGate:
    """Delta gate for I/O hiding and tiering."""

    def __init__(self) -> None:
        self.codec = "jsonl"
        self.tier = 0
        self.history = deque(maxlen=3)

    def update(self, key: Tuple[Any, Tuple[int, ...], str, int]) -> None:
        """Update gate."""
        self.history.append(key)
        if len(self.history) == 3 and len(set(self.history)) == 1 and self.tier < 3:
            self.tier += 1

    def predict(self, key: Tuple) -> bool:
        """Predict hit."""
        return key in self.history


# --- Auto Variant Engine ---


class AutoVariantEngine:
    """Auto-variant routing engine."""

    def __init__(self) -> None:
        self.metrics = MetricsSnapshot()
        self.gate = DeltaGate()
        self.buffer = SonicBuffer()
        self.jit_cache: Dict[Tuple, Callable] = {}
        self.aot_db = sqlite3.connect(":memory:")
        self.aot_db.execute("CREATE TABLE aot (key TEXT PRIMARY KEY, code TEXT)")
        self.quota = {"cpu_ms": 500, "mem_mb": 100}
        self.eviction_policy = "LRU"
        self._warmup()

    def _warmup(self) -> None:
        """Prewarm with safe known ops."""
        for n in (128, 2048, 16384):
            v = [random.random() for _ in range(n)]
            self.route("sum", v, mode="fast")
        A = [[0.0] * 16 for _ in range(16)]
        B = [[0.0] * 16 for _ in range(16)]
        self.route("gemm", A, B, mode="fast")

    def route(self, op: str, *args: Any, mode: str = "balanced", **kwargs: Any) -> Any:
        """Route operation to variant."""
        key = self._make_key(op, args, mode)
        self.gate.update(key)
        if self.gate.tier >= 3:
            return self._sonic_exec(key, op, args, kwargs)
        if self.gate.tier >= 2:
            return self._aot_exec(key, op, args, kwargs)
        if self.gate.tier >= 1:
            return self._jit_exec(key, op, args, kwargs)
        func = self._select_variant(op, args, mode)
        result, duration = bench(func, *args, **kwargs)
        self._update_metrics(duration)
        return result

    def _make_key(
        self, op: str, args: Sequence[Any], mode: str
    ) -> Tuple[Any, Tuple[int, ...], str, int]:
        """Make routing key."""
        types = tuple(type(a) for a in args)
        shapes = tuple(len(a) if hasattr(a, "__len__") else 0 for a in args)
        return (types, shapes, mode, self.gate.tier)

    def _select_variant(self, op: str, args: Sequence[Any], mode: str) -> Callable:
        """Select algorithm variant."""
        size = max((len(a) for a in args if hasattr(a, "__len__")), default=0)
        if op == "sum":
            return fsum_precise if mode == "precise" else sum_kahan
        if op == "gemm":
            if size < 64:
                return _gemm_naive
            elif size < 512:
                return _gemm_blocked
            else:
                return _gemm_strassen
        if op == "poly_mul":
            if size < 32:
                return _poly_mul_direct
            elif size < 1024:
                return _poly_mul_fft
            else:
                return _poly_mul_ntt
        if op == "conv1d":
            if size < 128:
                return _conv_direct
            else:
                return _conv_fft
        if op == "sample_normal":
            if mode == "fast":
                return self._ziggurat_normal
            elif mode == "balanced":
                return self._box_muller
            else:
                return random.gauss
        raise ValueError("Unknown op")

    # ---- JIT / AOT ----

    SAFE_BUILTINS = {
        "sum": sum,
        "len": len,
        "range": range,
        "zip": zip,
        "min": min,
        "max": max,
    }

    def _jit_exec(
        self, key: Tuple, op: str, args: Sequence[Any], kwargs: Dict[str, Any]
    ) -> Any:
        """JIT execute."""
        fn = self.jit_cache.get(key)
        if fn is None:
            fn = self._generate_jit(op, args)
            self.jit_cache[key] = fn
        return fn(*args, **kwargs)

    def _generate_jit(self, op: str, args: Sequence[Any]) -> Callable:
        """Generate JIT."""
        if op == "sum" and len(args) == 1 and hasattr(args[0], "__len__"):
            n = len(args[0])
            if n <= 16:
                src = "def _f(v):\n    return " + " + ".join(
                    f"v[{i}]" for i in range(n) or [0]
                )
                ns: Dict[str, Any] = {}
                exec(src, self.SAFE_BUILTINS.copy(), ns)
                return ns["_f"]
            return fsum_precise
        variant = self._select_variant(op, args, mode="balanced")
        return variant

    def _aot_exec(
        self, key: Tuple, op: str, args: Sequence[Any], kwargs: Dict[str, Any]
    ) -> Any:
        """AOT execute."""
        key_str = str(key)
        cur = self.aot_db.cursor()
        row = cur.execute("SELECT code FROM aot WHERE key=?", (key_str,)).fetchone()
        if row:
            strategy = row[0]
            if (
                strategy == "sum_unroll"
                and len(args) == 1
                and hasattr(args[0], "__len__")
            ):
                n = len(args[0])
                src = "def _f(v):\n    return " + " + ".join(
                    f"v[{i}]" for i in range(n) or [0]
                )
                ns: Dict[str, Any] = {}
                exec(src, self.SAFE_BUILTINS.copy(), ns)
                fn = ns["_f"]
                return fn(*args, **kwargs)
            fn = self.jit_cache.get(key) or self._generate_jit(op, args)
            return fn(*args, **kwargs)
        else:
            strategy = (
                "sum_unroll"
                if op == "sum" and hasattr(args[0], "__len__") and len(args[0]) <= 16
                else op
            )
            cur.execute(
                "INSERT INTO aot (key, code) VALUES (?, ?)", (key_str, strategy)
            )
            self.aot_db.commit()
            fn = self._generate_jit(op, args)
            return fn(*args, **kwargs)

    def _sonic_exec(
        self, key: Tuple, op: str, args: Sequence[Any], kwargs: Dict[str, Any]
    ) -> Any:
        """Sonic exec."""
        self.buffer.hot_fill(bytes(op, "utf-8"))
        fn = self.jit_cache.get(key) or self._generate_jit(op, args)
        return fn(*args, **kwargs)

    def _box_muller(self, mu: float = 0.0, sigma: float = 1.0) -> float:
        u1, u2 = random.random(), random.random()
        z = sqrt(-2 * log(u1)) * cos(2 * pi * u2)
        return mu + sigma * z

    def _ziggurat_normal(self, mu: float = 0.0, sigma: float = 1.0) -> float:
        return mu + sigma * random.gauss(0, 1)

    def _update_metrics(self, duration: float) -> None:
        """Update metrics."""
        alpha = 0.2
        self.metrics.p50_ms = (1 - alpha) * self.metrics.p50_ms + alpha * duration
        self.metrics.p95_ms = max(self.metrics.p95_ms * (1 - alpha), duration * 1.05)

    def log_metrics(self) -> None:
        """Log metrics."""
        with open("metrics.jsonl", "a") as f:
            f.write(self.metrics.to_jsonl())


# --- Matrix Operations ---


def _gemm_naive(A: List[List[float]], B: List[List[float]]) -> List[List[float]]:
    """Naive GEMM."""
    rows_a = len(A)
    cols_a = len(A[0])
    cols_b = len(B[0])
    C = [[0.0 for _ in range(cols_b)] for _ in range(rows_a)]
    for i in range(rows_a):
        for k in range(cols_a):
            aik = A[i][k]
            for j in range(cols_b):
                C[i][j] += aik * B[k][j]
    return C


def _gemm_blocked(
    A: List[List[float]], B: List[List[float]], block_size: int = 32
) -> List[List[float]]:
    """Blocked GEMM."""
    n, m, p = len(A), len(A[0]), len(B[0])
    C = [[0.0 for _ in range(p)] for _ in range(n)]
    for ii in range(0, n, block_size):
        for kk in range(0, m, block_size):
            for jj in range(0, p, block_size):
                for i in range(ii, min(ii + block_size, n)):
                    for k in range(kk, min(kk + block_size, m)):
                        aik = A[i][k]
                        for j in range(jj, min(jj + block_size, p)):
                            C[i][j] += aik * B[k][j]
    return C


def _mat_add(X: List[List[float]], Y: List[List[float]]) -> List[List[float]]:
    return [[xi + yj for xi, yj in zip(xr, yr)] for xr, yr in zip(X, Y)]


def _mat_sub(X: List[List[float]], Y: List[List[float]]) -> List[List[float]]:
    return [[xi - yj for xi, yj in zip(xr, yr)] for xr, yr in zip(X, Y)]


def _split_quadrants(M: List[List[float]]):
    n = len(M)
    m = n // 2
    return (
        [row[:m] for row in M[:m]],
        [row[m:] for row in M[:m]],
        [row[:m] for row in M[m:]],
        [row[m:] for row in M[m:]],
    )


def _join_quadrants(C11, C12, C21, C22):
    return [r1 + r2 for r1, r2 in zip(C11, C12)] + [r1 + r2 for r1, r2 in zip(C21, C22)]


def _gemm_strassen(A: List[List[float]], B: List[List[float]]) -> List[List[float]]:
    """Strassen GEMM."""
    n = len(A)
    if n <= 64:
        return _gemm_naive(A, B)
    A11, A12, A21, A22 = _split_quadrants(A)
    B11, B12, B21, B22 = _split_quadrants(B)
    M1 = _gemm_strassen(_mat_add(A11, A22), _mat_add(B11, B22))
    M2 = _gemm_strassen(_mat_add(A21, A22), B11)
    M3 = _gemm_strassen(A11, _mat_sub(B12, B22))
    M4 = _gemm_strassen(A22, _mat_sub(B21, B11))
    M5 = _gemm_strassen(_mat_add(A11, A12), B22)
    M6 = _gemm_strassen(_mat_sub(A21, A11), _mat_add(B11, B12))
    M7 = _gemm_strassen(_mat_sub(A12, A22), _mat_add(B21, B22))
    C11 = _mat_add(_mat_sub(_mat_add(M1, M4), M5), M7)
    C12 = _mat_add(M3, M5)
    C21 = _mat_add(M2, M4)
    C22 = _mat_add(_mat_sub(_mat_add(M1, M3), M2), M6)
    return _join_quadrants(C11, C12, C21, C22)


def gemm(A: List[List[float]], B: List[List[float]]) -> List[List[float]]:
    """General matrix multiply."""
    engine = AutoVariantEngine()
    return engine.route("gemm", A, B)


def gemv(A: List[List[float]], x: List[float]) -> List[float]:
    """General matrix-vector multiply."""
    return [sum(a * b for a, b in zip(row, x)) for row in A]


# --- Polynomial Operations ---


def _poly_mul_direct(a: List[float], b: List[float]) -> List[float]:
    """Direct poly mul."""
    n, m = len(a), len(b)
    c = [0.0] * (n + m - 1)
    for i in range(n):
        ai = a[i]
        for j in range(m):
            c[i + j] += ai * b[j]
    return c


def _poly_mul_fft(a: List[float], b: List[float]) -> List[float]:
    """FFT poly mul."""
    na, nb = len(a), len(b)
    n = 1 << (na + nb - 1).bit_length()
    fa = fft(a + [0.0] * (n - na))
    fb = fft(b + [0.0] * (n - nb))
    fc = [x * y for x, y in zip(fa, fb)]
    c = ifft(fc)
    return [x.real for x in c[: na + nb - 1]]


def _poly_mul_ntt(a: List[int], b: List[int], mod: int = 998244353) -> List[int]:
    """NTT poly mul."""
    return ntt_conv(a, b, mod)


def poly_mul(a: List[float], b: List[float]) -> List[float]:
    """Polynomial multiply."""
    engine = AutoVariantEngine()
    return engine.route("poly_mul", a, b)


# --- Convolution ---


def _conv_direct(x: List[float], kernel: List[float]) -> List[float]:
    """Direct conv1d."""
    n, m = len(x), len(kernel)
    y = [0.0] * (n - m + 1)
    for i in range(n - m + 1):
        s = 0.0
        for j in range(m):
            s += x[i + j] * kernel[j]
        y[i] = s
    return y


def _conv_fft(x: List[float], kernel: List[float]) -> List[float]:
    """FFT conv1d."""
    n_full = len(x) + len(kernel) - 1
    pad_n = 1 << n_full.bit_length()
    fx = fft(x + [0.0] * (pad_n - len(x)))
    fk = fft(kernel + [0.0] * (pad_n - len(kernel)))
    fy = [a * b for a, b in zip(fx, fk)]
    y_c = ifft(fy)
    return [v.real for v in y_c[:n_full]]


def conv1d(x: List[float], kernel: List[float]) -> List[float]:
    """1D convolution."""
    engine = AutoVariantEngine()
    return engine.route("conv1d", x, kernel)


# --- Sampling ---


def box_muller(mu: float = 0.0, sigma: float = 1.0) -> float:
    """Box-Muller normal."""
    u1, u2 = random.random(), random.random()
    z = sqrt(-2 * log(u1)) * cos(2 * pi * u2)
    return mu + sigma * z


def ziggurat_normal() -> float:
    """Ziggurat normal."""
    return random.gauss(0, 1)


def sample_normal(n: int, mu: float = 0.0, sigma: float = 1.0) -> List[float]:
    """Sample normal."""
    engine = AutoVariantEngine()
    return [engine.route("sample_normal", mu, sigma) for _ in range(n)]


# --- Symbolic ---


def sym_simplify(expr: str) -> str:
    """Simplify symbolic expr."""
    try:
        node = ast.parse(expr, mode="eval")
        if all(
            isinstance(
                n,
                (
                    ast.Expression,
                    ast.Num,
                    ast.BinOp,
                    ast.UnaryOp,
                    ast.operator,
                    ast.unaryop,
                ),
            )
            for n in ast.walk(node)
        ):
            return str(eval(compile(node, "<expr>", "eval"), {"__builtins__": {}}, {}))
        return expr
    except Exception:
        return expr


# --- SYMBOLIC_BOX ---

# minimal module access without import
_math = globals().get("math", None)
_decimal = globals().get("decimal", None)
_fractions = globals().get("fractions", None)
_ast = globals().get("ast", None)


# atoms / constructors
def _S_num(v):
    return ("num", v)


def _S_sym(s):
    return ("sym", s)


def _S_add(*xs):
    return ("add",) + xs


def _S_mul(*xs):
    return ("mul",) + xs


def _S_pow(b, e):
    return ("pow", b, e)


def _S_neg(x):
    return ("neg", x)


def _S_fun(name, *xs):
    return ("fun", name, xs)


def _S_div(a, b):
    return _S_mul(a, _S_pow(b, _S_num(-1)))


def _S_tuple(x):
    return isinstance(x, tuple)


def _S_isnum(x):
    return _S_tuple(x) and x[0] == "num"


def _S_iszero(x):
    return _S_isnum(x) and (x[1] == 0 or abs(x[1]) == 0)


def _S_isone(x):
    return _S_isnum(x) and x[1] == 1


# environment
def _sym_env_base():
    pi = getattr(_math, "pi", 3.141592653589793)
    e = getattr(_math, "e", 2.718281828459045)
    return {"pi": _S_num(pi), "e": _S_num(e)}


# number coercion
def _num_add(a, b):
    return type(a)(a + b) if type(a) is type(b) else a + b


def _num_mul(a, b):
    return type(a)(a * b) if type(a) is type(b) else a * b


def _num_pow(a, b):
    try:
        return a**b
    except:
        return float(a) ** float(b)


# sort key
def _sym_sort_key(x):
    if _S_isnum(x):
        return (0, 0, 0)
    if _S_tuple(x):
        tag = x[0]
        if tag == "sym":
            return (1, x[1], 0)
        if tag == "fun":
            return (2, x[1], len(x[2]))
        return (3, tag, len(x) - 1)
    return (9, str(x), 0)


# string
def _sym_str(x):
    if _S_isnum(x):
        v = x[1]
        try:
            if int(v) == v:
                return str(int(v))
        except:
            pass
        return str(v)
    if not _S_tuple(x):
        return str(x)
    t = x[0]
    if t == "sym":
        return x[1]
    if t == "neg":
        sx = _sym_str(x[1])
        if x[1][0] in ("add", "mul"):
            return "-(" + sx + ")"
        return "-" + sx
    if t == "add":
        return "+".join(_sym_str(a) for a in x[1:])
    if t == "mul":
        out = []
        for a in x[1:]:
            s = _sym_str(a)
            if _S_tuple(a) and a[0] in ("add",):
                s = "(" + s + ")"
            out.append(s)
        return "*".join(out)
    if t == "pow":
        return _sym_str(x[1]) + "**" + _sym_str(x[2])
    if t == "fun":
        name, args = x[1], x[2]
        return name + "(" + ",".join(_sym_str(a) for a in args) + ")"
    return str(x)


# flatten
def _flat(tag, xs):
    out = []
    for a in xs:
        if _S_tuple(a) and a[0] == tag:
            out.extend(a[1:])
        else:
            out.append(a)
    return (tag,) + tuple(out)


# constant fold
def _eval_const(x):
    if not _S_tuple(x):
        return x
    t = x[0]
    if t in ("num", "sym"):
        return x
    if t == "neg":
        v = _eval_const(x[1])
        if _S_isnum(v):
            return _S_num(-v[1])
        return ("neg", v)
    if t == "add":
        parts = [_eval_const(a) for a in x[1:]]
        s = None
        rest = []
        for a in parts:
            if _S_isnum(a):
                s = a[1] if s is None else _num_add(s, a[1])
            else:
                rest.append(a)
        if s is None:
            pass
        else:
            if s != 0:
                rest.insert(0, _S_num(s))
        if not rest:
            return _S_num(0)
        if len(rest) == 1:
            return rest[0]
        rest = tuple(sorted(rest, key=_sym_sort_key))
        return _flat("add", rest)
    if t == "mul":
        parts = [_eval_const(a) for a in x[1:]]
        p = None
        rest = []
        for a in parts:
            if _S_isnum(a):
                if p is None:
                    p = a[1]
                else:
                    p = _num_mul(p, a[1])
            else:
                rest.append(a)
        if p is None:
            pass
        else:
            if p == 0:
                return _S_num(0)
            if p != 1:
                rest.insert(0, _S_num(p))
        if not rest:
            return _S_num(1)
        if len(rest) == 1:
            return rest[0]
        rest = tuple(sorted(rest, key=_sym_sort_key))
        return _flat("mul", rest)
    if t == "pow":
        b = _eval_const(x[1])
        e = _eval_const(x[2])
        if _S_isnum(e) and e[1] == 0:
            return _S_num(1)
        if _S_isnum(e) and e[1] == 1:
            return b
        if _S_isnum(b) and _S_isnum(e):
            return _S_num(_num_pow(b[1], e[1]))
        return ("pow", b, e)
    if t == "fun":
        name, args = x[1], tuple(_eval_const(a) for a in x[2])
        if all(_S_isnum(a) for a in args):
            if _math:
                fn = getattr(_math, name, None)
                if fn:
                    try:
                        return _S_num(fn(*[a[1] for a in args]))
                    except:
                        pass
        return ("fun", name, args)
    return x


# normalize
def _norm(x):
    if not _S_tuple(x):
        return x
    t = x[0]
    if t == "add":
        return _eval_const(("add",) + tuple(_norm(a) for a in x[1:]))
    if t == "mul":
        return _eval_const(("mul",) + tuple(_norm(a) for a in x[1:]))
    if t == "pow":
        return _eval_const(("pow", _norm(x[1]), _norm(x[2])))
    if t == "neg":
        return _eval_const(("neg", _norm(x[1])))
    if t == "fun":
        name, args = x[1], x[2]
        return _eval_const(("fun", name, tuple(_norm(a) for a in args)))
    return x


# parse
def _parse_expr(expr):
    if not _ast:
        raise RuntimeError("ast unavailable")
    return _ast.parse(expr, mode="eval").body


def _from_ast(node, env):
    if isinstance(node, (_ast.Num, _ast.Constant)):
        v = getattr(node, "n", None)
        if v is None:
            v = getattr(node, "value", None)
        return _S_num(v)
    if isinstance(node, _ast.Name):
        if node.id in env:
            v = env[node.id]
            return (
                v
                if _S_tuple(v)
                else _S_num(v)
                if isinstance(v, (int, float, complex))
                else _S_sym(node.id)
            )
        return _S_sym(node.id)
    if isinstance(node, _ast.UnaryOp):
        if isinstance(node.op, _ast.UAdd):
            return _from_ast(node.operand, env)
        if isinstance(node.op, _ast.USub):
            return _S_neg(_from_ast(node.operand, env))
        return _from_ast(node.operand, env)
    if isinstance(node, _ast.BinOp):
        l = _from_ast(node.left, env)
        r = _from_ast(node.right, env)
        if isinstance(node.op, _ast.Add):
            return _S_add(l, r)
        if isinstance(node.op, _ast.Sub):
            return _S_add(l, _S_neg(r))
        if isinstance(node.op, _ast.Mult):
            return _S_mul(l, r)
        if isinstance(node.op, _ast.Div):
            return _S_div(l, r)
        if isinstance(node.op, _ast.Pow):
            return _S_pow(l, r)
    if isinstance(node, _ast.Call):
        fname = (
            getattr(node.func, "id", None) or getattr(node.func, "attr", None) or "f"
        )
        args = tuple(_from_ast(a, env) for a in node.args)
        return ("fun", fname, args)
    raise ValueError("unsupported ast")


# subs
def _subs(x, kv):
    if not _S_tuple(x):
        return x
    t = x[0]
    if t == "sym":
        if x[1] in kv:
            v = kv[x[1]]
            return (
                v
                if _S_tuple(v)
                else _S_num(v)
                if isinstance(v, (int, float, complex))
                else x
            )
        return x
    if t in ("num",):
        return x
    if t in ("neg",):
        return ("neg", _subs(x[1], kv))
    if t in ("add", "mul"):
        return (t,) + tuple(_subs(a, kv) for a in x[1:])
    if t == "pow":
        return ("pow", _subs(x[1], kv), _subs(x[2], kv))
    if t == "fun":
        name, args = x[1], x[2]
        return ("fun", name, tuple(_subs(a, kv) for a in args))
    return x


# function rewrite
def _rewrite_fun(x):
    if not (_S_tuple(x) and x[0] == "fun"):
        return x
    name, args = x[1], x[2]
    if name == "sqrt":
        return _norm(_S_pow(args[0], _S_num(0.5)))
    if name == "abs":
        return ("fun", "abs", args)
    return x


# expand
def _expand_once(x):
    if not _S_tuple(x):
        return x
    t = x[0]
    if t == "mul" and len(x) == 3:
        a, b = x[1], x[2]
        if _S_tuple(a) and a[0] == "add":
            return _S_add(*(_norm(_S_mul(ti, b)) for ti in a[1:]))
        if _S_tuple(b) and b[0] == "add":
            return _S_add(*(_norm(_S_mul(a, tj)) for tj in b[1:]))
    return x


def _expand_deep(x, limit=64):
    cur = _norm(x)
    for _ in range(limit):
        nxt = _expand_once(cur)
        if nxt == cur:
            break
        cur = _norm(nxt)
    return cur


# factor (basic)
def _factor_poly_add(x):
    if not (_S_tuple(x) and x[0] == "add"):
        return x
    terms = list(x[1:])
    coeffs = []
    symbols = []
    for t in terms:
        if _S_tuple(t) and t[0] == "mul":
            c = 1.0
            rest = []
            for a in t[1:]:
                if _S_isnum(a):
                    c = _num_mul(c, a[1])
                else:
                    rest.append(a)
            coeffs.append(c)
            symbols.append(tuple(sorted(rest, key=_sym_sort_key)))
        elif _S_isnum(t):
            coeffs.append(t[1])
            symbols.append(tuple())
        else:
            coeffs.append(1.0)
            symbols.append((t,))
    if not symbols:
        return x
    common = None
    for s in symbols:
        if common is None:
            common = set(s)
        else:
            common = common.intersection(set(s))
    common = tuple(sorted(common, key=_sym_sort_key))
    if not common:
        return x
    new_terms = []
    for c, s in zip(coeffs, symbols):
        rem = [a for a in s if a not in common]
        term = _S_num(c) if c != 1.0 or not rem else rem[0]
        if c != 1.0 and rem:
            term = _S_mul(_S_num(c), *rem)
        elif rem and len(rem) > 1:
            term = _S_mul(*rem)
        new_terms.append(_norm(term))
    outer = _norm(_S_mul(*common)) if common else _S_num(1)
    inner = _norm(_S_add(*new_terms))
    return _norm(_S_mul(outer, inner))


# gcd rational (very small)
def _poly_gcd_num(a, b):
    from math import gcd as _g

    try:
        ai = int(round(a))
        bi = int(round(b))
        return float(_g(abs(ai), abs(bi)))
    except:
        return 1.0


def _rational_simplify(a_over_b):
    if not (_S_tuple(a_over_b) and a_over_b[0] == "mul"):
        return a_over_b
    num = 1.0
    rest = []
    for t in a_over_b[1:]:
        if _S_isnum(t):
            num = _num_mul(num, t[1])
        else:
            rest.append(t)
    return _norm(_S_mul(_S_num(num), *rest))


# trig/log rules (light)
def _rewrite_identities(x):
    if not _S_tuple(x):
        return x
    if x[0] == "fun":
        name, args = x[1], x[2]
        if (
            name == "log"
            and len(args) == 1
            and _S_tuple(args[0])
            and args[0][0] == "mul"
        ):
            # log(a*b) => log(a)+log(b) (non-rigorous; assume positive)
            return _norm(_S_add(*(_S_fun("log", t) for t in args[0][1:])))
        if (
            name == "exp"
            and len(args) == 1
            and _S_tuple(args[0])
            and args[0][0] == "add"
        ):
            # exp(a+b) ≈ exp(a)*exp(b)
            return _norm(_S_mul(*(_S_fun("exp", t) for t in args[0][1:])))
    return x


# diff
def _diff(x, v):
    if _S_isnum(x):
        return _S_num(0)
    if _S_tuple(x) and x[0] == "sym":
        return _S_num(1 if x[1] == v else 0)
    if _S_tuple(x) and x[0] == "neg":
        return _S_neg(_diff(x[1], v))
    if _S_tuple(x) and x[0] == "add":
        return _norm(_S_add(*(_diff(t, v) for t in x[1:])))
    if _S_tuple(x) and x[0] == "mul":
        terms = x[1:]
        parts = []
        for i, ti in enumerate(terms):
            dti = _diff(ti, v)
            if not (_S_isnum(dti) and _S_iszero(dti)):
                left = terms[:i]
                right = terms[i + 1 :]
                parts.append(_norm(_S_mul(dti, *left, *right)))
        if not parts:
            return _S_num(0)
        return _norm(_S_add(*parts))
    if _S_tuple(x) and x[0] == "pow":
        b, e = x[1], x[2]
        if _S_isnum(e):
            return _norm(_S_mul(_S_num(e[1]), _S_pow(b, _S_num(e[1] - 1)), _diff(b, v)))
        # b^e * (e' * ln b + e * b'/b)
        lnb = _S_fun("log", b)
        return _norm(
            _S_mul(
                _S_pow(b, e),
                _S_add(_S_mul(_diff(e, v), lnb), _S_mul(e, _S_div(_diff(b, v), b))),
            )
        )
    if _S_tuple(x) and x[0] == "fun":
        name, args = x[1], x[2]
        u = args[0] if args else _S_num(0)
        du = _diff(u, v)
        if name == "sin":
            return _norm(_S_mul(du, _S_fun("cos", u)))
        if name == "cos":
            return _norm(_S_mul(_S_num(-1), du, _S_fun("sin", u)))
        if name == "tan":
            return _norm(_S_mul(du, _S_pow(_S_fun("sec", u), _S_num(2))))
        if name == "exp":
            return _norm(_S_mul(du, _S_fun("exp", u)))
        if name == "log":
            return _norm(_S_div(du, u))
        if name == "sqrt":
            return _norm(_S_div(du, _S_mul(_S_num(2), _S_fun("sqrt", u))))
        return _S_fun("D_" + name, u, du)
    return _S_num(0)


# integrate (very small table)
def _integrate(x, v):
    if _S_tuple(x) and x[0] == "sym" and x[1] == v:
        return _S_mul(_S_num(0.5), _S_pow(x, _S_num(2)))
    if _S_isnum(x):
        return _S_mul(x, _S_sym(v))
    if _S_tuple(x) and x[0] == "add":
        return _norm(_S_add(*(_integrate(t, v) for t in x[1:])))
    if _S_tuple(x) and x[0] == "mul":
        const = _S_num(1)
        var = []
        for t in x[1:]:
            if _S_isnum(t):
                const = _norm(_S_mul(const, t))
            else:
                var.append(t)
        if len(var) == 1:
            return _norm(_S_mul(const, _integrate(var[0], v)))
    if _S_tuple(x) and x[0] == "pow":
        b, e = x[1], x[2]
        if _S_tuple(b) and b[0] == "sym" and b[1] == v and _S_isnum(e) and e[1] != -1:
            n = e[1] + 1
            return _norm(_S_div(_S_pow(b, _S_num(n)), _S_num(n)))
        if _S_tuple(b) and b[0] == "sym" and b[1] == v and _S_isnum(e) and e[1] == -1:
            return _S_fun("log", _S_abs(b))
    if _S_tuple(x) and x[0] == "fun":
        name, args = x[1], x[2]
        u = args[0]
        if name == "sin":
            return _norm(_S_mul(_S_num(-1), _S_fun("cos", u)))
        if name == "cos":
            return _norm(_S_fun("sin", u))
        if name == "exp":
            return _norm(_S_fun("exp", u))
        if name == "log":
            return (
                _norm(
                    _S_add(
                        _S_mul(_S_sym(v), _S_fun("log", _S_sym(v))), _S_neg(_S_sym(v))
                    )
                )
                if (u == _S_sym(v))
                else ("int", x, v)
            )
    return ("int", x, v)


def _S_abs(x):
    return ("fun", "abs", (x,))


# series
def _series_taylor(f, v, a, order=5):
    terms = []
    cur = f
    for n in range(order + 1):
        val = _subs(cur, {v: _S_num(a)})
        terms.append(
            _norm(
                _S_mul(
                    _S_div(val, _S_num(_fact(n))),
                    _S_pow(_S_add(_S_sym(v), _S_neg(_S_num(a))), _S_num(n)),
                )
            )
        )
        cur = _norm(_diff(cur, v))
    return _norm(_S_add(*terms))


def _fact(n):
    r = 1
    for i in range(2, n + 1):
        r *= i
    return r


# limit (very small)
def _limit(x, v, a):
    val = _subs(x, {v: _S_num(a)})
    if not (_S_tuple(val) and val[0] in ("mul", "add", "div", "pow", "neg", "fun")):
        return _norm(val)
    return ("lim", x, v, a)


# solve scalar
def _solve_poly2(a, b, c):
    if not _math:
        return None
    D = b * b - 4 * a * c
    sqrtD = _math.sqrt(D) if D >= 0 else complex(0, _math.sqrt(-D))
    return [(-b + sqrtD) / (2 * a), (-b - sqrtD) / (2 * a)]


def _solve_expr_eq0(expr, v):
    ex = _norm(expr)
    if _S_tuple(ex) and ex[0] == "add":
        coeff2 = 0.0
        coeff1 = 0.0
        coeff0 = 0.0
        for t in ex[1:]:
            if (
                _S_tuple(t)
                and t[0] == "pow"
                and t[1] == _S_sym(v)
                and _S_isnum(t[2])
                and t[2][1] == 2
            ):
                coeff2 += 1.0
            elif t == _S_sym(v):
                coeff1 += 1.0
            elif _S_isnum(t):
                coeff0 += t[1]
            else:
                return None
        if coeff2 != 0.0:
            roots = _solve_poly2(coeff2, coeff1, coeff0)
            if roots is None:
                return None
            return [_S_num(r) for r in roots]
        if coeff1 != 0.0:
            return [_S_num(-coeff0 / coeff1)]
    return None


# linear system (Gauss)
def _linsolve(A, b):
    n = len(A)
    m = len(A[0])
    M = [row[:] + [b[i]] for i, row in enumerate(A)]
    i = 0
    j = 0
    while i < n and j < m:
        piv = i
        for k in range(i, n):
            if abs(M[k][j]) > abs(M[piv][j]):
                piv = k
        if abs(M[piv][j]) < 1e-12:
            j += 1
            continue
        M[i], M[piv] = M[piv], M[i]
        f = M[i][j]
        for jj in range(j, m + 1):
            M[i][jj] /= f
        for u in range(n):
            if u == i:
                continue
            fac = M[u][j]
            if fac != 0:
                for jj in range(j, m + 1):
                    M[u][jj] -= fac * M[i][jj]
        i += 1
        j += 1
    x = [0] * m
    for r in range(n):
        piv = None
        for c in range(m):
            if abs(M[r][c]) > 1e-12:
                piv = c
                break
        if piv is not None:
            x[piv] = M[r][m]
    return x


# dag/cse interning
def _intern(x, memo=None):
    if memo is None:
        memo = {}
    if not _S_tuple(x):
        return x
    key = (
        (
            x[0],
            tuple(
                _intern(a, memo)
                for a in (x[1:] if x[0] not in ("fun",) else (x[1], x[2]))
            ),
        )
        if x[0] != "fun"
        else (x[0], x[1], tuple(_intern(a, memo) for a in x[2]))
    )
    if key in memo:
        return memo[key]
    if x[0] == "fun":
        y = ("fun", x[1], tuple(_intern(a, memo) for a in x[2]))
    elif x[0] in ("add", "mul"):
        y = (x[0],) + tuple(_intern(a, memo) for a in x[1:])
    elif x[0] in ("pow", "neg"):
        if x[0] == "pow":
            y = ("pow", _intern(x[1], memo), _intern(x[2], memo))
        else:
            y = ("neg", _intern(x[1], memo))
    else:
        y = x
    memo[key] = y
    return y


# public api
def sym_parse(expr, vars=None):
    env = _sym_env_base()
    if vars:
        for k, v in vars.items():
            env[k] = (
                v
                if _S_tuple(v)
                else _S_num(v)
                if isinstance(v, (int, float, complex))
                else _S_sym(k)
            )
    node = _parse_expr(expr)
    return _norm(_from_ast(node, env))


def sym_simplify(
    expr, vars=None, expand=False, factor=False, identities=False, dag=True
):
    t = sym_parse(expr, vars)
    if expand:
        t = _expand_deep(t)
    if factor:
        t = _factor_poly_add(t)
    if identities:
        t = _rewrite_identities(t)
    t = _norm(_rewrite_fun(t))
    if dag:
        t = _intern(t, {})
    return _sym_str(t)


def sym_eval(expr, vars=None):
    return sym_simplify(
        expr, vars, expand=False, factor=False, identities=False, dag=True
    )


def sym_subs(expr, mapping):
    t = sym_parse(expr, None)
    t = _subs(
        t,
        {
            k: (
                v
                if _S_tuple(v)
                else _S_num(v)
                if isinstance(v, (int, float, complex))
                else _S_sym(k)
            )
            for k, v in mapping.items()
        },
    )
    return _sym_str(_norm(t))


def sym_equal(expr_a, expr_b):
    ta = _intern(_norm(sym_parse(expr_a, None)), {})
    tb = _intern(_norm(sym_parse(expr_b, None)), {})
    return _sym_str(ta) == _sym_str(tb)


def sym_diff(expr, var):
    t = sym_parse(expr, None)
    d = _norm(_diff(t, var))
    return _sym_str(d)


def sym_integrate(expr, var):
    t = sym_parse(expr, None)
    I = _norm(_integrate(t, var))
    return _sym_str(I)


def sym_series(expr, var, around=0.0, order=5):
    t = sym_parse(expr, None)
    S = _series_taylor(t, var, around, order)
    return _sym_str(S)


def sym_limit(expr, var, to=0.0):
    t = sym_parse(expr, None)
    L = _limit(t, var, to)
    return _sym_str(_norm(L)) if _S_tuple(L) and L[0] != "lim" else _sym_str(L)


def sym_solve(expr_eq0, var):
    t = sym_parse(expr_eq0, None)
    roots = _solve_expr_eq0(t, var)
    if roots is None:
        return []
    return [_sym_str(_norm(r)) for r in roots]


def sym_linsolve(A, b):
    return _linsolve(A, b)


def sym_lambdify(expr, args):
    t = sym_parse(expr, None)

    def eval_node(x):
        if _S_isnum(x):
            return x[1]
        if x[0] == "sym":
            return None
        if x[0] == "neg":
            v = eval_node(x[1])
            return -v if v is not None else None
        if x[0] == "add":
            s = 0.0
            for a in x[1:]:
                v = eval_node(a)
                if v is None:
                    return None
                s += v
            return s
        if x[0] == "mul":
            p = 1.0
            for a in x[1:]:
                v = eval_node(a)
                if v is None:
                    return None
                p *= v
            return p
        if x[0] == "pow":
            b = eval_node(x[1])
            e = eval_node(x[2])
            if b is None or e is None:
                return None
            return _num_pow(b, e)
        if x[0] == "fun":
            name, argv = x[1], x[2]
            vals = []
            for a in argv:
                v = eval_node(a)
                if v is None:
                    return None
                vals.append(v)
            fn = getattr(_math, name, None)
            return fn(*vals) if fn else None
        return None

    arglist = list(args)

    def f(*vals):
        env = {arglist[i]: _S_num(vals[i]) for i in range(len(arglist))}
        tree = _subs(t, env)
        tree = _norm(tree)
        val = eval_node(tree)
        if val is None:
            raise ValueError("non-numeric branch")
        return val

    return f


# --- Quantum ---


def quantum_simulate(
    state: List[complex], gates: List[List[List[complex]]]
) -> List[complex]:
    """Simple quantum sim."""
    vec = state
    for U in gates:
        vec = [sum(U[i][k] * vec[k] for k in range(len(vec))) for i in range(len(U))]
    return vec


# --- QUANTUM_BOX_FULL ---


def q_norm(v):
    n = math.sqrt(sum((a.real * a.real + a.imag * a.imag) for a in v))
    return v[:] if n == 0 else [a / n for a in v]


def q_zero(n):
    return [0j] * n


def q_apply_dense(state, gate):
    n = len(state)
    out = [0j] * n
    for i in range(n):
        s = 0j
        row = gate[i]
        for k in range(n):
            s += row[k] * state[k]
        out[i] = s
    return out


def q_kron(A, B):
    ra, ca = len(A), len(A[0])
    rb, cb = len(B), len(B[0])
    out = [[0j] * (ca * cb) for _ in range(ra * rb)]
    for i in range(ra):
        for j in range(ca):
            a = A[i][j]
            if a == 0:
                continue
            for p in range(rb):
                row = out[i * rb + p]
                bp = B[p]
                base = j * cb
                for q in range(cb):
                    row[base + q] += a * bp[q]
    return out


def q_I():
    return [[1, 0], [0, 1]]


def q_X():
    return [[0, 1], [1, 0]]


def q_Y():
    return [[0, -1j], [1j, 0]]


def q_Z():
    return [[1, 0], [0, -1]]


def q_H():
    inv = 1 / math.sqrt(2)
    return [[inv, inv], [inv, -inv]]


def q_S():
    return [[1, 0], [0, 1j]]


def q_T():
    return [[1, 0], [0, cmath.exp(1j * math.pi / 4)]]


def q_Rx(t):
    c = math.cos(t / 2)
    s = -1j * math.sin(t / 2)
    return [[c, s], [s, c]]


def q_Ry(t):
    c = math.cos(t / 2)
    s = math.sin(t / 2)
    return [[c, -s], [s, c]]


def q_Rz(t):
    return [[cmath.exp(-1j * t / 2), 0], [0, cmath.exp(1j * t / 2)]]


def q_U3(t, ph, lmb):
    return [
        [math.cos(t / 2), -cmath.exp(1j * lmb) * math.sin(t / 2)],
        [
            cmath.exp(1j * ph) * math.sin(t / 2),
            cmath.exp(1j * (ph + lmb)) * math.cos(t / 2),
        ],
    ]


def q_Phase(ph):
    return [[1, 0], [0, cmath.exp(1j * ph)]]


def q_gate_on(n, q, gate):
    M = None
    for i in range(n):
        g = gate if i == q else q_I()
        M = g if M is None else q_kron(M, g)
    return M


def q_apply_1q_sparse(state, n, q, U):
    N = 1 << n
    mask = 1 << q
    for i in range(N):
        if (i & mask) == 0:
            j = i | mask
            a0, a1 = state[i], state[j]
            state[i] = U[0][0] * a0 + U[0][1] * a1
            state[j] = U[1][0] * a0 + U[1][1] * a1
    return state


def q_apply_2q_sparse(state, n, q0, q1, U):
    if q0 == q1:
        return state
    if q0 > q1:
        q0, q1 = q1, q0
    N = 1 << n
    m0, m1 = (1 << q0), (1 << q1)
    for i in range(N):
        if (i & m0) == 0 and (i & m1) == 0:
            i00 = i
            i01 = i | m0
            i10 = i | m1
            i11 = i | m0 | m1
            a00, a01, a10, a11 = state[i00], state[i01], state[i10], state[i11]
            state[i00] = U[0][0] * a00 + U[0][1] * a01 + U[0][2] * a10 + U[0][3] * a11
            state[i01] = U[1][0] * a00 + U[1][1] * a01 + U[1][2] * a10 + U[1][3] * a11
            state[i10] = U[2][0] * a00 + U[2][1] * a01 + U[2][2] * a10 + U[2][3] * a11
            state[i11] = U[3][0] * a00 + U[3][1] * a01 + U[3][2] * a10 + U[3][3] * a11
    return state


def q_multi_controlled(n, controls, target, U):
    if isinstance(controls, int):
        controls = [controls]
    N = 1 << n
    out = [[0j] * N for _ in range(N)]
    for i in range(N):
        if all(((i >> c) & 1) for c in controls):
            bit = (i >> target) & 1
            j = i ^ (1 << target)
            if bit == 0:
                out[i][i] += U[0][0]
                out[i][j] += U[0][1]
                out[j][i] += U[1][0]
                out[j][j] += U[1][1]
            else:
                out[i][j] += U[1][0]
                out[i][i] += U[1][1]
                out[j][j] += U[0][0]
                out[j][i] += U[0][1]
        else:
            out[i][i] += 1
    return out


def q_apply(state, ops):
    v = q_norm(state[:])
    for op in ops:
        v = q_norm(q_apply_dense(v, op))
    return v


def q_measure_distribution(state):
    v = q_norm(state)
    return [(a.real * a.real + a.imag * a.imag) for a in v]


def q_sample(state, shots=1):
    p = q_measure_distribution(state)
    cdf = []
    s = 0
    for x in p:
        s += x
        cdf.append(s)
    out = []
    for _ in range(shots):
        r = random.random()
        i = 0
        while i < len(cdf) and r > cdf[i]:
            i += 1
        out.append(i if i < len(cdf) else len(cdf) - 1)
    return out


def q_project(state, q, val):
    N = len(state)
    n = int(math.log2(N))
    mask = 1 << q
    new = state[:]
    for i in range(N):
        if ((i >> q) & 1) != val:
            new[i] = 0j
    return q_norm(new)


def q_expect(state, op):
    v = q_norm(state)
    val = 0j
    for i, a in enumerate(v):
        for j, b in enumerate(v):
            val += a.conjugate() * op[i][j] * b
    return val.real


def q_pauli_expect(state, paulis):
    obs = 1
    for p in paulis:
        if p == "X":
            obs = q_kron(obs, q_X())
        elif p == "Y":
            obs = q_kron(obs, q_Y())
        elif p == "Z":
            obs = q_kron(obs, q_Z())
    return q_expect(state, obs)


def q_param_shift(f, theta, shift=math.pi / 2):
    return (f(theta + shift) - f(theta - shift)) / 2


def q_diffusion(n):
    N = 1 << n
    H = 1 / math.sqrt(N)
    J = [[H * H * N for _ in range(N)] for _ in range(N)]
    I = [[0] * N for _ in range(N)]
    for i in range(N):
        I[i][i] = 1
    return [[2 * J[i][j] - I[i][j] for j in range(N)] for i in range(N)]


def q_oracle_marked(n, idx):
    N = 1 << n
    U = [[0j] * N for _ in range(N)]
    for i in range(N):
        U[i][i] = -1 if i == idx else 1
    return U


def q_grover(n, idx, iters):
    state = [0j] * (1 << n)
    state[0] = 1
    H = q_H()
    for q in range(n):
        state = q_apply_1q_sparse(state, n, q, H)
    O = q_oracle_marked(n, idx)
    D = q_diffusion(n)
    for _ in range(iters):
        state = q_apply_dense(state, O)
        state = q_apply_dense(state, D)
        state = q_norm(state)
    return state


def dm_from_state(psi):
    N = len(psi)
    rho = [[0j] * N for _ in range(N)]
    for i in range(N):
        ai = psi[i]
        for j in range(N):
            rho[i][j] = ai * psi[j].conjugate()
    return rho


def dm_apply(rho, U):
    N = len(rho)
    tmp = [[0j] * N for _ in range(N)]
    out = [[0j] * N for _ in range(N)]
    for i in range(N):
        for k in range(N):
            s = 0j
            for j in range(N):
                s += U[i][j] * rho[j][k]
            tmp[i][k] = s
    for i in range(N):
        for j in range(N):
            s = 0j
            for k in range(N):
                s += tmp[i][k] * U[j][k].conjugate()
            out[i][j] = s
    return out


def dm_apply_kraus(rho, Ks):
    N = len(rho)
    out = [[0j] * N for _ in range(N)]
    for K in Ks:
        tmp = [[0j] * N for _ in range(N)]
        add = [[0j] * N for _ in range(N)]
        for i in range(N):
            for k in range(N):
                s = 0j
                for j in range(N):
                    s += K[i][j] * rho[j][k]
                tmp[i][k] = s
        for i in range(N):
            for j in range(N):
                s = 0j
                for k in range(N):
                    s += tmp[i][k] * K[j][k].conjugate()
                add[i][j] = s
        for i in range(N):
            for j in range(N):
                out[i][j] += add[i][j]
    return out


def kraus_bit_flip(p):
    return [
        [[math.sqrt(1 - p), 0], [0, math.sqrt(1 - p)]],
        [[0, math.sqrt(p)], [math.sqrt(p), 0]],
    ]


def kraus_amplitude_damp(g):
    return [[[1, 0], [0, math.sqrt(1 - g)]], [[0, math.sqrt(g)], [0, 0]]]


def dm_measure_z(rho, q, val):
    N = len(rho)
    n = 0
    while (1 << n) < N:
        n += 1
    proj = [0] * N
    mask = 1 << q
    for i in range(N):
        if ((i >> q) & 1) == val:
            proj[i] = 1
    tr = sum(proj[i] * rho[i][i].real for i in range(N))
    if tr == 0:
        return rho
    out = [[0j] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            out[i][j] = (proj[i] * rho[i][j] * proj[j]) / tr
    return out


def q_mem_guard(n, max_q=22):
    if n > max_q:
        raise MemoryError("too many qubits")
    return True


def q_run_with_monitor(state, ops, n):
    q_mem_guard(n)
    v = q_norm(state)
    for op in ops:
        v = q_apply_dense(v, op)
        nrm = sum((a.real * a.real + a.imag * a.imag) for a in v)
        if not (0.9999 <= nrm <= 1.0001):
            v = q_norm(v)
    return v


class QuantumCircuit:
    def __init__(self, n):
        self.n = n
        self.ops = []

    def _add(self, M):
        self.ops.append(M)

    def x(self, q):
        self._add(q_gate_on(self.n, q, q_X()))

    def y(self, q):
        self._add(q_gate_on(self.n, q, q_Y()))

    def z(self, q):
        self._add(q_gate_on(self.n, q, q_Z()))

    def h(self, q):
        self._add(q_gate_on(self.n, q, q_H()))

    def s(self, q):
        self._add(q_gate_on(self.n, q, q_S()))

    def t(self, q):
        self._add(q_gate_on(self.n, q, q_T()))

    def rx(self, q, t):
        self._add(q_gate_on(self.n, q, q_Rx(t)))

    def ry(self, q, t):
        self._add(q_gate_on(self.n, q, q_Ry(t)))

    def rz(self, q, t):
        self._add(q_gate_on(self.n, q, q_Rz(t)))

    def u3(self, q, th, ph, lmb):
        self._add(q_gate_on(self.n, q, q_U3(th, ph, lmb)))

    def phase(self, q, ph):
        self._add(q_gate_on(self.n, q, q_Phase(ph)))

    def cx(self, c, t):
        self._add(q_multi_controlled(self.n, c, t, q_X()))

    def cz(self, c, t):
        self._add(q_multi_controlled(self.n, c, t, q_Z()))

    def swap(self, a, b):
        self.cx(a, b)
        self.cx(b, a)
        self.cx(a, b)

    def toffoli(self, a, b, c):
        self._add(q_multi_controlled(self.n, [a, b], c, q_X()))

    def qft(self):
        for j in range(self.n):
            self.h(j)
            for k in range(j + 1, self.n):
                self._add(
                    q_multi_controlled(self.n, j, k, q_Phase(math.pi / (2 ** (k - j))))
                )

    def inv_qft(self):
        for j in reversed(range(self.n)):
            for k in reversed(range(j + 1, self.n)):
                self._add(
                    q_multi_controlled(self.n, j, k, q_Phase(-math.pi / (2 ** (k - j))))
                )
            self.h(j)

    def run(self, state=None):
        if state is None:
            state = [0j] * (1 << self.n)
            state[0] = 1
        return q_apply(state, self.ops)


# --- FFT ---


def fft(x: List[float] | List[complex]) -> List[complex]:
    """Recursive Cooley–Tukey FFT."""
    n = len(x)
    if n <= 1:
        return [complex(xi) for xi in x]
    even = fft(x[0::2])
    odd = fft(x[1::2])
    T = [exp(-2j * pi * k / n) * odd[k] for k in range(n // 2)]
    return [even[k] + T[k] for k in range(n // 2)] + [
        even[k] - T[k] for k in range(n // 2)
    ]


def ifft(x: List[complex]) -> List[complex]:
    """Inverse FFT."""
    n = len(x)
    conj_x = [xi.conjugate() for xi in x]
    y = fft(conj_x)
    return [yi.conjugate() / n for yi in y]


def ntt_conv(a: List[int], b: List[int], mod: int) -> List[int]:
    """Naïve NTT-like convolution."""
    n, m = len(a), len(b)
    c = [0] * (n + m - 1)
    for i in range(n):
        ai = a[i]
        for j in range(m):
            c[i + j] = (c[i + j] + ai * b[j]) % mod
    return c


# --- Advanced Numerics ---


def neumaier_sum(seq: Sequence[float]) -> float:
    """Neumaier sum."""
    s = 0.0
    c = 0.0
    for x in seq:
        t = s + x
        if abs(s) >= abs(x):
            c += (s - t) + x
        else:
            c += (x - t) + s
        s = t
    return s + c


def high_prec_matmul(
    A: List[List[Decimal]], B: List[List[Decimal]]
) -> List[List[Decimal]]:
    """High precision matmul."""
    return [
        [sum(a * b for a, b in zip(row_a, col_b)) for col_b in zip(*B)] for row_a in A
    ]


def uncertain_add(
    a: Tuple[float, float], b: Tuple[float, float]
) -> Tuple[float, float]:
    """Add with uncertainty."""
    return a[0] + b[0], sqrt(a[1] ** 2 + b[1] ** 2)


def group_order(g: int, mod: int) -> int:
    """Group order."""
    order = 1
    current = g % mod
    while current != 1:
        current = (current * g) % mod
        order += 1
        if order > mod:
            break
    return order


def ring_mul(a: int, b: int, mod: int) -> int:
    """Ring mul."""
    return (a * b) % mod


def field_inv(a: int, mod: int) -> int:
    """Field inverse."""
    return pow(a, -1, mod)


def prime_generate(n: int) -> List[int]:
    """Generate primes up to n."""
    if n < 2:
        return []
    sieve = [True] * (n + 1)
    sieve[0:2] = [False, False]
    for i in range(2, int(sqrt(n)) + 1):
        if sieve[i]:
            sieve[i * i : n + 1 : i] = [False] * (((n - i * i) // i) + 1)
    return [i for i, v in enumerate(sieve) if v]


def factorize(n: int) -> Dict[int, int]:
    """Trial division factorization."""
    factors: Dict[int, int] = {}
    i = 2
    while i * i <= n:
        while n % i == 0:
            factors[i] = factors.get(i, 0) + 1
            n //= i
        i += 1
    if n > 1:
        factors[n] = factors.get(n, 0) + 1
    return factors


def fibonacci_fast(n: int) -> int:
    """Fast fibonacci."""
    if n < 2:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b


def elliptic_add(
    p: Optional[Tuple[int, int]],
    q: Optional[Tuple[int, int]],
    a: int,
    mod: int,
) -> Optional[Tuple[int, int]]:
    """Elliptic curve point addition."""
    if p is None:
        return q
    if q is None:
        return p
    x1, y1 = p
    x2, y2 = q
    if x1 == x2 and (y1 + y2) % mod == 0:
        return None
    if p != q:
        lam = ((y2 - y1) * pow((x2 - x1) % mod, -1, mod)) % mod
    else:
        lam = ((3 * x1 * x1 + a) * pow((2 * y1) % mod, -1, mod)) % mod
    xr = (lam * lam - x1 - x2) % mod
    yr = (lam * (x1 - xr) - y1) % mod
    return (xr, yr)


def stable_sample(alpha: float, beta: float, mu: float, sigma: float) -> float:
    """Alpha-stable sample."""
    U = random.uniform(-math.pi / 2, math.pi / 2)
    W = random.expovariate(1.0)
    if alpha != 1:
        z = (math.sin(alpha * U) / (math.cos(U) ** (1 / alpha))) * (
            (math.cos(U - alpha * U) / W) ** ((1 - alpha) / alpha)
        )
    else:
        z = (2 / math.pi) * (
            (math.pi / 2 + beta * U) * math.tan(U)
            - beta
            * math.log((math.pi / 2) * W * math.cos(U) / (math.pi / 2 + beta * U))
        )
    return mu + sigma * z


def wavelet_transform(x: List[float], wavelet: str = "haar") -> List[float]:
    """Haar wavelet transform."""
    n = len(x)
    if n < 2:
        return x
    avg = [(x[2 * i] + x[2 * i + 1]) / sqrt(2) for i in range(n // 2)]
    diffv = [(x[2 * i] - x[2 * i + 1]) / sqrt(2) for i in range(n // 2)]
    return wavelet_transform(avg) + diffv


# --- ConvAccelerator ---


class ConvAccelerator:
    """Block/sliding convolution with cache-aware kernels."""

    def __init__(self) -> None:
        self.block = 4_096
        self.small_k = 64
        self.last_kernel_id = 0
        self._k_rev: list[float] | None = None
        self._k_sum: float = 0.0
        self.last_error: str | None = None

    def set_block(self, n: int) -> None:
        """Set block size."""
        self.block = max(256, int(n))

    def set_small(self, k: int) -> None:
        """Set small kernel cut."""
        self.small_k = max(8, int(k))

    def _prep_kernel(self, b: list[float]) -> None:
        """Why: reuse reverse/sum."""
        kid = id(b)
        if kid == self.last_kernel_id:
            return
        self.last_kernel_id = kid
        self._k_rev = list(reversed(b))
        s = 0.0
        for x in b:
            s += x
        self._k_sum = s

    def conv(self, a: list[float], b: list[float]) -> list[float]:
        """Convolution entry."""
        if not a or not b:
            return []
        self._prep_kernel(b)
        if len(b) <= self.small_k:
            return self._conv_sliding(a, b)
        return self._conv_overlap_save(a, b)

    def _conv_sliding(self, a: list[float], b: list[float]) -> list[float]:
        """Small-k direct with edge handling."""
        n = len(a)
        m = len(b)
        out: list[float] = [0.0] * (n + m - 1)
        for t in range(n + m - 1):
            s = 0.0
            i0 = max(0, t - (m - 1))
            i1 = min(t, n - 1)
            j0 = m - 1 - (t - i0)
            for i in range(i0, i1 + 1):
                s += a[i] * b[j0 + (i - i0)]
            out[t] = s
        return out

    def _conv_overlap_save(self, a: list[float], b: list[float]) -> list[float]:
        """Overlap-save block convolution."""
        n = len(a)
        m = len(b)
        out: list[float] = [0.0] * (n + m - 1)
        L = max(self.block, m)
        S = L - (m - 1)
        if S <= 0:
            S = max(1, m // 2)
            L = S + m - 1
        start = 0
        while start < n:
            beg = start - (m - 1)
            end = min(start + S, n)
            blk: list[float] = [0.0] * L
            for i in range(L):
                idx = beg + i
                blk[i] = 0.0 if idx < 0 or idx >= n else a[idx]
            yb = self._direct_valid(blk, b)
            for i in range(S):
                oi = start + i
                if oi < n + m - 1 and i + m - 1 < len(yb):
                    out[oi] = yb[i + m - 1]
            start += S
        return out

    def _direct_valid(self, x: list[float], h: list[float]) -> list[float]:
        """Direct conv for a block."""
        nx = len(x)
        nh = len(h)
        ny = nx + nh - 1
        y: list[float] = [0.0] * ny
        for i in range(nx):
            xi = x[i]
            for j in range(nh):
                y[i + j] += xi * h[j]
        return y


# --- XcorrAccelerator ---


class XcorrAccelerator:
    """Cross-correlation with sliding dot reuse."""

    def __init__(self) -> None:
        self.last_b_id = 0
        self._b_flip: list[float] | None = None
        self.last_error: str | None = None

    def _prep(self, b: list[float]) -> None:
        """Why: reuse reversed buffer."""
        bid = id(b)
        if bid == self.last_b_id:
            return
        self.last_b_id = bid
        self._b_flip = list(reversed(b))

    def xcorr(self, a: list[float], b: list[float]) -> list[float]:
        """Two-sided cross-correlation."""
        if not a or not b:
            return []
        self._prep(b)
        rb = self._b_flip if self._b_flip is not None else list(reversed(b))
        return ConvAccelerator().conv(a, rb)

    def xcorr_pos(self, a: list[float], b: list[float]) -> list[float]:
        """Positive lags only."""
        n = len(a)
        m = len(b)
        out: list[float] = [0.0] * n
        k = min(n, m)
        s = 0.0
        for i in range(k):
            s += a[i] * b[i]
        out[0] = s
        for lag in range(1, n):
            drop = a[lag - 1] * b[0] if lag - 1 < n and 0 < m else 0.0
            add = a[lag + k - 1] * b[k - 1] if lag + k - 1 < n and k - 1 < m else 0.0
            s = s - drop + add
            out[lag] = s
        return out


# --- IOFusionBuffer ---


class IOFusionBuffer:
    """64KiB slot ring with hot/cold policy."""

    SLOT = 64 * 1024

    def __init__(self, slots: int = 32) -> None:
        self.slots = max(4, int(slots))
        self._ring: list[memoryview | None] = [None] * self.slots
        self._ids: list[int] = [0] * self.slots
        self._hot: dict[int, memoryview] = {}
        self._head = 0
        self._live = 0
        self._tick = 1
        self.bytes_now = 0
        self.hits = 0
        self.miss = 0
        self.mass = "plateau"
        self.last_error: str | None = None

    def _advance(self) -> int:
        i = self._head
        self._head = (self._head + 1) % self.slots
        return i

    def _evict_if_full(self) -> None:
        if self._live < self.slots:
            return
        i = self._advance()
        mv = self._ring[i]
        sid = self._ids[i]
        if mv is not None:
            self.bytes_now -= len(mv)
        if sid in self._hot:
            del self._hot[sid]
        self._ring[i] = None
        self._ids[i] = 0
        self._live -= 1
        self.miss += 1

    def alloc_slot(self, data: bytes) -> int:
        """Allocate a slot and fill."""
        if len(data) > self.SLOT:
            self.last_error = "oversize"
            return 0
        self._evict_if_full()
        i = self._advance()
        buf = bytearray(self.SLOT)
        mv = memoryview(buf)
        mv[: len(data)] = data
        sid = self._tick
        self._tick += 1
        self._ring[i] = mv
        self._ids[i] = sid
        self._hot[sid] = mv
        self._live += 1
        self.bytes_now += len(mv)
        return sid

    def hot_fill(self, sid: int, data: bytes) -> bool:
        """Write to a hot slot."""
        mv = self._hot.get(sid)
        if mv is None:
            self.last_error = "sid"
            return False
        if len(data) > len(mv):
            self.last_error = "oversize"
            return False
        mv[: len(data)] = data
        self.hits += 1
        return True

    def get(self, sid: int) -> memoryview | None:
        """Get slot view."""
        return self._hot.get(sid)

    def flush(self, clock: object, ms: int = 4) -> None:
        """No-op delay hook."""
        _ = clock
        _ = ms

    def mass_adjust(self) -> None:
        """Set mass by occupancy."""
        cap = self.slots * self.SLOT
        ratio = 0.0 if cap == 0 else self.bytes_now / cap
        if ratio > 0.8:
            self.mass = "burst"
        elif ratio < 0.2:
            self.mass = "long_tail"
        else:
            self.mass = "plateau"

    def ids(self) -> list[int]:
        """List active ids."""
        out: list[int] = []
        for i in range(self.slots):
            sid = self._ids[i]
            if sid != 0:
                out.append(sid)
        return out


# --- DeltaGate ---


class DeltaGateN:
    """Codec/shape predictor with light hysteresis."""

    def __init__(self) -> None:
        self.count: dict[str, int] = {}
        self.hot: dict[str, bool] = {}
        self.last_error: str | None = None

    def detect_codec(self, buf: bytes) -> str:
        """Detect simple codec."""
        if not buf:
            return "bin"
        b0 = buf[:8]
        if b0[:1] in (b"{", b"["):
            return "jsonl"
        if b0.find(b",") != -1 or b0.find(b";") != -1:
            return "csv"
        return "bin"

    def shape_bin(self, n: int) -> int:
        """Bucketized shape."""
        if n <= 1_024:
            return 0
        if n <= 65_536:
            return 1
        if n <= 1_000_000:
            return 2
        return 3

    def update(self, key: str) -> None:
        """Bump key and set hot on stability."""
        c = self.count.get(key, 0) + 1
        self.count[key] = c
        if c >= 3:
            self.hot[key] = True

    def is_hot(self, key: str) -> bool:
        """Check hot."""
        return bool(self.hot.get(key, False))


# --- SelfTuningRuntime ---


class SelfTuningRuntime:
    """Each/Count/Chunk executors with simple meter."""

    def __init__(self) -> None:
        self.hist: list[tuple[str, float]] = []
        self.mass = "plateau"
        self.last_error: str | None = None

    def _emit(self, tag: str, dt_ms: float) -> None:
        self.hist.append((tag, dt_ms))
        if len(self.hist) > 256:
            self.hist.pop(0)

    def _p95(self, xs: list[float]) -> float:
        if not xs:
            return 0.0
        ys = sorted(xs)
        k = int(0.95 * (len(ys) - 1))
        return ys[k]

    def _clock_now(self, clk: object) -> float:
        return float(clk()) if callable(clk) else 0.0

    def run_each(self, seq: list[object], fn: object, clock: object) -> list[object]:
        """Map-like execution."""
        t0 = self._clock_now(clock)
        out: list[object] = []
        call = fn
        for x in seq:
            y = call(x)
            out.append(y)
        dt = self._clock_now(clock) - t0
        self._emit("each", dt * 1_000.0)
        return out

    def run_count(self, n: int, gen: object, clock: object) -> list[object]:
        """Generate n items."""
        t0 = self._clock_now(clock)
        out: list[object] = []
        call = gen
        for i in range(n):
            out.append(call(i))
        dt = self._clock_now(clock) - t0
        self._emit("count", dt * 1_000.0)
        return out

    def run_chunk(
        self, buf: memoryview, parts: int, upd: object, clock: object
    ) -> memoryview:
        """Chunked update in-place."""
        if parts <= 0:
            self.last_error = "parts"
            return buf
        t0 = self._clock_now(clock)
        step = max(1, len(buf) // parts)
        call = upd
        for i in range(0, len(buf), step):
            ch = buf[i : i + step]
            call(ch, i)
        dt = self._clock_now(clock) - t0
        self._emit("chunk", dt * 1_000.0)
        return buf

    def learn(self) -> str:
        """Return suggested route by recent p95."""
        bins: dict[str, list[float]] = {}
        for k, v in self.hist:
            xs = bins.get(k, [])
            xs.append(v)
            bins[k] = xs
        best = "each"
        best_v = 1e30
        for k, xs in bins.items():
            v = self._p95(xs)
            if v < best_v:
                best_v = v
                best = k
        self.mass = "burst" if best_v > 10.0 else "plateau"
        return best


# --- AutoLearnScheduler ---


class AutoLearnScheduler:
    """Global policy store and round-robin explore."""

    def __init__(self) -> None:
        self.stats: dict[str, list[float]] = {}
        self.count: dict[str, int] = {}
        self.tick = 0
        self.mass = "plateau"
        self.last_error: str | None = None
        self._warmup()

    def record(self, key: str, ms: float) -> None:
        """Add metric."""
        xs = self.stats.get(key, [])
        xs.append(ms)
        if len(xs) > 512:
            xs.pop(0)
        self.stats[key] = xs
        self.count[key] = self.count.get(key, 0) + 1

    def p95(self, key: str) -> float:
        """Get p95."""
        xs = self.stats.get(key, [])
        if not xs:
            return 0.0
        ys = sorted(xs)
        k = int(0.95 * (len(ys) - 1))
        return ys[k]

    def suggest(self, keys: list[str]) -> str:
        """Round-robin with best-so-far bias."""
        if not keys:
            return ""
        self.tick += 1
        if self.tick % len(keys) == 0:
            idx = (self.tick // len(keys)) % len(keys)
            return keys[idx]
        best = keys[0]
        best_v = 1e30
        for k in keys:
            v = self.p95(k)
            if 0.0 < v < best_v:
                best_v = v
                best = k
        return best

    def snapshot(self) -> dict[str, float]:
        """Minimal policy snapshot."""
        out: dict[str, float] = {}
        for k in self.stats:
            out[f"{k}.p95"] = self.p95(k)
        out["tick"] = float(self.tick)
        out["mass"] = 1.0 if self.mass == "burst" else 0.0
        return out


# --- QuantumSimCore ---


class QuantumSimCore:
    """State-vector simulator."""

    def __init__(self, n: int) -> None:
        self.n = int(n)
        self.dim = 1 << self.n
        self.state: list[complex] = [0j] * self.dim
        self.state[0] = 1.0 + 0.0j
        self.last_error: str | None = None

    def reset(self) -> None:
        """Reset to |0...0>."""
        self.state = [0j] * self.dim
        self.state[0] = 1.0 + 0.0j

    def apply_single(self, q: int, m: list[complex]) -> None:
        """Apply 2x2 on qubit q."""
        if q < 0 or q >= self.n:
            self.last_error = "qubit"
            return
        mask = 1 << q
        a, b, c, d = m[0], m[1], m[2], m[3]
        st = self.state
        for i in range(0, self.dim, mask << 1):
            for j in range(mask):
                i0 = i + j
                i1 = i0 + mask
                x = st[i0]
                y = st[i1]
                st[i0] = a * x + b * y
                st[i1] = c * x + d * y

    def apply_control(self, qc: int, qt: int, m: list[complex]) -> None:
        """Apply controlled 2x2."""
        if qc == qt:
            self.last_error = "same"
            return
        cm = 1 << qc
        tm = 1 << qt
        a, b, c, d = m[0], m[1], m[2], m[3]
        st = self.state
        for i in range(self.dim):
            if (i & cm) != 0 and (i & tm) == 0:
                i0 = i
                i1 = i | tm
                x = st[i0]
                y = st[i1]
                st[i0] = a * x + b * y
                st[i1] = c * x + d * y

    def prob(self, i: int) -> float:
        """Amplitude prob of basis i."""
        if i < 0 or i >= self.dim:
            return 0.0
        v = self.state[i]
        return (v.real * v.real) + (v.imag * v.imag)

    def measure_argmax(self) -> int:
        """Deterministic measure by argmax prob."""
        best = 0
        pbest = -1.0
        for i in range(self.dim):
            p = self.prob(i)
            if p > pbest:
                pbest = p
                best = i
        self._collapse(best)
        return best

    def _collapse(self, i: int) -> None:
        """Project to basis i."""
        st = [0j] * self.dim
        st[i] = 1.0 + 0.0j
        self.state = st


# --- QuantumTensorOps ---


class QuantumTensorOps:
    """Tensor ops and layout tools."""

    def apply_many(
        self, qs: QuantumSimCore, ops: list[tuple[int, list[complex]]]
    ) -> None:
        """Apply many 1-qubit gates."""
        for q, m in ops:
            qs.apply_single(q, m)

    def swap(self, qs: QuantumSimCore, q0: int, q1: int) -> None:
        """Swap two qubits."""
        if q0 == q1:
            return
        qs.apply_control(q0, q1, [1 + 0j, 0 + 0j, 0 + 0j, 1 + 0j])
        qs.apply_control(q1, q0, [1 + 0j, 0 + 0j, 0 + 0j, 1 + 0j])
        qs.apply_control(q0, q1, [1 + 0j, 0 + 0j, 0 + 0j, 1 + 0j])

    def apply_two(self, qs: QuantumSimCore, q0: int, q1: int, u: list[complex]) -> None:
        """Apply 4x4 on (q0,q1)."""
        if q0 == q1:
            qs.last_error = "same"
            return
        lo = min(q0, q1)
        hi = max(q0, q1)
        ml = 1 << lo
        mh = 1 << hi
        st = qs.state
        a, b, c, d, e, f, g, h = u[0:8]
        i, j, k, l, m, n, o, p = u[8:16]
        step = ml << 1
        block = mh << 1
        for base in range(0, qs.dim, block):
            for off in range(0, mh, step):
                i00 = base + off
                i01 = i00 + ml
                i10 = i00 + mh
                i11 = i10 + ml
                v00 = st[i00]
                v01 = st[i01]
                v10 = st[i10]
                v11 = st[i11]
                r00 = a * v00 + b * v01 + c * v10 + d * v11
                r01 = e * v00 + f * v01 + g * v10 + h * v11
                r10 = i * v00 + j * v01 + k * v10 + l * v11
                r11 = m * v00 + n * v01 + o * v10 + p * v11
                st[i00] = r00
                st[i01] = r01
                st[i10] = r10
                st[i11] = r11

    def permute(self, qs: QuantumSimCore, order: list[int]) -> None:
        """Logical relabeling only."""
        if len(order) != qs.n:
            qs.last_error = "order"
            return


# --- Protocols ---


T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
K = TypeVar("K")
R = TypeVar("R")


@runtime_checkable
class SupportsVectorOps(Protocol):
    """Standard criterion."""

    def dot(self, x: List[float], y: List[float]) -> float:
        ...

    def axpy(self, a: float, x: List[float], y: List[float]) -> None:
        ...

    def scal(self, a: float, x: List[float]) -> None:
        ...

    def nrm2(self, x: List[float]) -> float:
        ...


# --- Actor System ---


@dataclass
class _Msg:
    """Why: small, typed envelope."""

    sender: "ActorRef"
    value: Any
    ts_ns: int


class Mailbox:
    """Sized mailbox with backpressure."""

    def __init__(self, maxsize: int = 1_024) -> None:
        self._q: "queue.SimpleQueue[_Msg]" = queue.SimpleQueue()
        self._sem = threading.Semaphore(maxsize)
        self._sz = maxsize

    def put(self, m: _Msg, timeout: float = 0.5) -> None:
        ok = self._sem.acquire(timeout=timeout)
        if not ok:
            raise VisibleError("mailbox backpressure")
        self._q.put(m)

    def get(self) -> _Msg:
        m = self._q.get()
        self._sem.release()
        return m

    def size_hint(self) -> int:
        return self._sz - self._sem._value


class Supervisor:
    """Why: restart strategy."""

    def __init__(self, max_restarts: int = 3, window_s: float = 10.0) -> None:
        self.max = max_restarts
        self.win = window_s
        self._hist: Deque[float] = collections.deque(maxlen=max_restarts)

    def allow(self) -> bool:
        now = time.monotonic()
        self._hist.append(now)
        if len(self._hist) < self.max:
            return True
        return now - self._hist[0] > self.win


class ActorRef:
    """Typed ref to an actor."""

    def __init__(self, name: str, mb: Mailbox) -> None:
        self.name = name
        self._mb = mb

    def tell(self, value: Any, sender: "ActorRef") -> None:
        m = _Msg(sender=sender, value=value, ts_ns=time.time_ns())
        self._mb.put(m)


class ActorSystem:
    """Actor runtime with autoscale and supervision."""

    def __init__(self, min_workers: int = 2, max_workers: int = 32) -> None:
        self._lock = threading.Lock()
        self._pool = cf.ThreadPoolExecutor(max_workers=min_workers)
        self._min = min_workers
        self._max = max_workers
        self._actors: Dict[
            str, Tuple[Mailbox, Callable[[Any, ActorRef], None], Supervisor]
        ] = {}
        self._refs: Dict[str, ActorRef] = {}
        self._running = True
        self._ctl = threading.Thread(target=self._loop, daemon=True)
        self._ctl.start()

    def spawn(
        self,
        name: str,
        handler: Callable[[Any, ActorRef], None],
        mb_size: int = 1_024,
        sup: Optional[Supervisor] = None,
    ) -> ActorRef:
        if name in self._actors:
            raise VisibleError("actor exists")
        mb = Mailbox(mb_size)
        ref = ActorRef(name, mb)
        self._actors[name] = (mb, handler, sup or Supervisor())
        self._refs[name] = ref
        return ref

    def ref(self, name: str) -> ActorRef:
        r = self._refs.get(name)
        if r is None:
            raise VisibleError("actor missing")
        return r

    def stop(self) -> None:
        self._running = False
        self._pool.shutdown(wait=False, cancel_futures=True)

    def _autoscale(self, load: int) -> None:
        with self._lock:
            cur = self._pool._max_workers
            want = min(self._max, max(self._min, load // 64 + 1))
            if want != cur:
                self._pool._max_workers = want

    def _run_handler(
        self,
        h: Callable[[Any, ActorRef], None],
        msg: _Msg,
        self_ref: ActorRef,
        sup: Supervisor,
    ) -> None:
        try:
            h(msg.value, msg.sender)
        except Exception as e:
            ok = sup.allow()
            if not ok:
                logging.exception("actor halt: %s", e)
                return
            time.sleep(0.01)

    def _loop(self) -> None:
        while self._running:
            load = 0
            for name, (mb, handler, sup) in list(self._actors.items()):
                for _ in range(32):
                    try:
                        msg = mb.get()
                    except Exception:
                        break
                    load += 1
                    self_ref = self._refs[name]
                    self._pool.submit(self._run_handler, handler, msg, self_ref, sup)
            self._autoscale(load)
            time.sleep(0.002)


# --- FRP Stream ---


class Stream(Iterable[T]):
    """Push/pull FRP with time ops."""

    def __init__(self, it: Iterable[T]) -> None:
        self._it = it

    def __iter__(self) -> Iterator[T]:
        return iter(self._it)

    def map(self, fn: Callable[[T], U]) -> "Stream[U]":
        def gen() -> Iterator[U]:
            for x in self._it:
                yield fn(x)

        return Stream(gen())

    def filter(self, pred: Callable[[T], bool]) -> "Stream[T]":
        def gen() -> Iterator[T]:
            for x in self._it:
                if pred(x):
                    yield x

        return Stream(gen())

    def flat_map(self, fn: Callable[[T], Iterable[U]]) -> "Stream[U]":
        def gen() -> Iterator[U]:
            for x in self._it:
                for y in fn(x):
                    yield y

        return Stream(gen())

    def buffer(self, n: int) -> "Stream[List[T]]":
        def gen() -> Iterator[List[T]]:
            buf: List[T] = []
            for x in self._it:
                buf.append(x)
                if len(buf) >= n:
                    yield buf
                    buf = []
            if buf:
                yield buf

        return Stream(gen())

    def window(self, n: int) -> "Stream[List[T]]":
        def gen() -> Iterator[List[T]]:
            dq: Deque[T] = collections.deque(maxlen=n)
            for x in self._it:
                dq.append(x)
                if len(dq) == n:
                    yield list(dq)

        return Stream(gen())

    def debounce(self, ms: int) -> "Stream[T]":
        gap = ms / 1_000.0

        def gen() -> Iterator[T]:
            last = 0.0
            for x in self._it:
                now = time.monotonic()
                if now - last >= gap:
                    last = now
                    yield x

        return Stream(gen())

    @staticmethod
    def merge(*streams: "Stream[T]") -> "Stream[T]":
        def gen() -> Iterator[T]:
            for s in streams:
                for x in s:
                    yield x

        return Stream(gen())

    def take(self, n: int) -> "Stream[T]":
        def gen() -> Iterator[T]:
            c = 0
            for x in self._it:
                if c >= n:
                    break
                c += 1
                yield x

        return Stream(gen())

    def run(self) -> List[T]:
        return list(self._it)

    async def run_async(self) -> List[T]:
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, self.run)


# --- LINQ-like Queryable ---


class Queryable(Iterable[T]):
    """Declarative query DSL."""

    def __init__(self, it: Iterable[T]) -> None:
        self._it = it

    def __iter__(self) -> Iterator[T]:
        return iter(self._it)

    def select(self, fn: Callable[[T], U]) -> "Queryable[U]":
        return Queryable(map(fn, self._it))

    def where(self, pred: Callable[[T], bool]) -> "Queryable[T]":
        return Queryable(filter(pred, self._it))

    def join(
        self,
        other: Iterable[U],
        key: Callable[[T], K],
        fkey: Callable[[U], K],
        proj: Callable[[T, U], V],
    ) -> "Queryable[V]":
        idx: Dict[K, List[U]] = {}
        for r in other:
            idx.setdefault(fkey(r), []).append(r)

        def gen() -> Iterator[V]:
            for a in self._it:
                ks = idx.get(key(a), [])
                for b in ks:
                    yield proj(a, b)

        return Queryable(gen())

    def groupby(
        self, key: Callable[[T], K], agg: Callable[[List[T]], U]
    ) -> "Queryable[Tuple[K, U]]":
        store: Dict[K, List[T]] = {}
        for x in self._it:
            store.setdefault(key(x), []).append(x)
        items = ((k, agg(v)) for k, v in store.items())
        return Queryable(items)

    def orderby(self, key: Callable[[T], Any], reverse: bool = False) -> "Queryable[T]":
        return Queryable(sorted(self._it, key=key, reverse=reverse))

    def to_list(self) -> List[T]:
        return list(self._it)


# --- Pattern Matching / ADT ---


@dataclass(frozen=True)
class Case:
    """Why: compact pattern."""

    tag: str
    pred: Optional[Callable[[Any], bool]] = None
    action: Optional[Callable[[Any], R]] = None


def match(value: Any, *cases: Case, default: Optional[Callable[[Any], R]] = None) -> R:
    """Algebraic-style match."""
    for c in cases:
        if c.tag == getattr(value, "tag", None):
            if c.pred is None or c.pred(value):
                if c.action is None:
                    return value
                return c.action(value)
    if default is not None:
        return default(value)
    raise VisibleError("no match")


class Variant(abc.ABC):
    """Tagged union base."""

    tag: str

    def __init_subclass__(cls, **kw: Any) -> None:
        if "tag" not in cls.__dict__:
            raise DiagnosticError("Variant subclass needs tag")


# --- Lazy / Infinite Seq ---


class LazySeq(Iterable[T]):
    """Strictly lazy sequence with fusion."""

    def __init__(self, it: Iterable[T]) -> None:
        self._it = it
        self._ops: List[Tuple[str, Callable]] = []

    def map(self, fn: Callable[[T], U]) -> "LazySeq[U]":
        self._ops.append(("map", fn))
        return self

    def filter(self, pred: Callable[[T], bool]) -> "LazySeq[T]":
        self._ops.append(("filter", pred))
        return self

    def __iter__(self) -> Iterator[Any]:
        for x in self._it:
            y = x
            ok = True
            for kind, fn in self._ops:
                if kind == "map":
                    y = fn(y)
                else:
                    ok = bool(fn(y))
                    if not ok:
                        break
            if ok:
                yield y


# --- Transducers ---


Step = Callable[[R, T], R]


class Transducer:
    """Clojure-like transducer."""

    def __init__(self, xf: Callable[[Step], Step]) -> None:
        self._xf = xf

    def __rshift__(self, other: "Transducer") -> "Transducer":
        def comp(step: Step) -> Step:
            return self._xf(other._xf(step))

        return Transducer(comp)

    def run(self, coll: Iterable[T], init: R, step: Step) -> R:
        s = self._xf(step)
        acc = init
        for x in coll:
            acc = s(acc, x)
        return acc


def xmap(fn: Callable[[T], U]) -> Transducer:
    def wrap(step: Step) -> Step:
        def inner(acc: R, x: T) -> R:
            return step(acc, fn(x))

        return inner

    return Transducer(wrap)


def xfilter(pred: Callable[[T], bool]) -> Transducer:
    def wrap(step: Step) -> Step:
        def inner(acc: R, x: T) -> R:
            return step(acc, x) if pred(x) else acc

        return inner

    return Transducer(wrap)


def xtake(n: int) -> Transducer:
    def wrap(step: Step) -> Step:
        cnt = {"k": 0}

        def inner(acc: R, x: T) -> R:
            if cnt["k"] >= n:
                return acc
            cnt["k"] += 1
            return step(acc, x)

        return inner

    return Transducer(wrap)


def pipe(coll: Iterable[T], *xfs: Transducer, init: R, step: Step) -> R:
    xf = functools.reduce(lambda a, b: a >> b, xfs, Transducer(lambda s: s))
    return xf.run(coll, init, step)


# --- Ownership / Borrow-ish Views ---


class _Lease:
    """Why: track unique lease."""

    def __init__(self) -> None:
        self.owner: Optional[int] = None
        self.shared: int = 0


class UniqueView(contextlib.AbstractContextManager["UniqueView"]):
    """Exclusive view guard."""

    def __init__(self, buf: memoryview) -> None:
        self._buf = buf
        self._lease = _Lease()
        self._lease.owner = id(self)

    def __enter__(self) -> "UniqueView":
        if self._lease.owner not in (None, id(self)):
            raise SecurityCriticalError("unique taken")
        self._lease.owner = id(self)
        return self

    def __exit__(self, *exc: Any) -> None:
        self._lease.owner = None

    def view(self) -> memoryview:
        if self._lease.owner != id(self):
            raise SecurityCriticalError("no unique lease")
        return self._buf


class SharedView(contextlib.AbstractContextManager["SharedView"]):
    """Shared read-only view."""

    def __init__(self, buf: memoryview) -> None:
        self._buf = buf
        self._lease = _Lease()

    def __enter__(self) -> "SharedView":
        if self._lease.owner is not None:
            raise SecurityCriticalError("writer present")
        self._lease.shared += 1
        return self

    def __exit__(self, *exc: Any) -> None:
        self._lease.shared -= 1

    def view(self) -> memoryview:
        if self._lease.shared <= 0:
            raise SecurityCriticalError("no shared lease")
        return self._buf


# --- Dual numbers ---


@dataclass(frozen=True)
class Dual:
    """Dual number for forward AD."""

    val: float
    der: float = 0.0

    def __add__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        return Dual(self.val + o.val, self.der + o.der)

    def __radd__(self, o: "Dual|float") -> "Dual":
        return self + o

    def __sub__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        return Dual(self.val - o.val, self.der - o.der)

    def __rsub__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        return Dual(o.val - self.val, o.der - self.der)

    def __mul__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        return Dual(self.val * o.val, self.der * o.val + self.val * o.der)

    def __rmul__(self, o: "Dual|float") -> "Dual":
        return self * o

    def __truediv__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        den = o.val * o.val
        return Dual(self.val / o.val, (self.der * o.val - self.val * o.der) / den)

    def __rtruediv__(self, o: "Dual|float") -> "Dual":
        o = o if isinstance(o, Dual) else Dual(o)
        return o / self

    def __pow__(self, p: float) -> "Dual":
        return Dual(self.val**p, p * (self.val ** (p - 1)) * self.der)


def d_sin(x: Dual) -> Dual:
    return Dual(sin(x.val), cos(x.val) * x.der)


def d_cos(x: Dual) -> Dual:
    return Dual(cos(x.val), -sin(x.val) * x.der)


def d_exp(x: Dual) -> Dual:
    e = exp(x.val)
    return Dual(e, e * x.der)


# --- CPS / Trampoline ---


@dataclass
class TailCall:
    """Why: carry next call."""

    fn: Callable[..., "TailCall|T"]
    args: Tuple[Any, ...]


def trampoline(tc: "TailCall|T") -> T:
    """Run CPS via trampoline."""
    cur: Any = tc
    while isinstance(cur, TailCall):
        cur = cur.fn(*cur.args)
    return cur


# --- Hygienic Macro ---


class MacroEngine:
    """Minimal hygienic macro via AST."""

    def __init__(self) -> None:
        self._allowed = {"map", "filter", "sum", "len", "range"}

    def expand(
        self, fn: Callable[..., Any], rewriter: Callable[[ast.AST], ast.AST]
    ) -> Callable[..., Any]:
        src = ast.parse(self._get_src(fn))
        tree = rewriter(src)
        code = compile(tree, "<macro>", "exec")
        ns: Dict[str, Any] = {}
        ns.update({k: __builtins__[k] for k in ("range", "len", "sum")})
        out: Dict[str, Any] = {}
        exec(code, ns, out)
        return next(v for k, v in out.items() if callable(v))

    def _get_src(self, fn: Callable[..., Any]) -> str:
        name = getattr(fn, "__name__", "f")
        args = "x"
        body = "return x"
        return f"def {name}({args}):\n    {body}\n"


# --- P2 Quantile ---


def _p2_quantile(seq: Iterable[float], q: float) -> float:
    """P2 algorithm for streaming quantile."""
    data = list(seq)
    n = len(data)
    if n == 0:
        raise ValueError("empty sequence")
    if n < 5:
        data.sort()
        i = q * (n - 1)
        lo = int(math.floor(i))
        hi = min(lo + 1, n - 1)
        frac = i - lo
        return data[lo] * (1 - frac) + data[hi] * frac

    x = sorted(data[:5])
    m = [0, q / 2, q, (1 + q) / 2, 1]
    npos = [1, 1 + 2 * q, 1 + 4 * q, 1 + 6 * q, 5]
    pos = [1, 1 + 2 * q, 1 + 4 * q, 1 + 6 * q, 5]

    def parabolic(i, d):
        p = pos[i] + d
        a = (p - pos[i - 1]) / (pos[i + 1] - pos[i - 1])
        return x[i] + a * (
            (pos[i] - pos[i - 1] + d) * (x[i + 1] - x[i]) / (pos[i + 1] - pos[i])
            + (pos[i + 1] - pos[i] - d) * (x[i] - x[i - 1]) / (pos[i] - pos[i - 1])
        )

    def linear(i, d):
        return x[i] + d * (x[i + d] - x[i]) / (pos[i + d] - pos[i])

    for idx in range(5, n):
        y = data[idx]
        k = 0
        if y < x[0]:
            x[0] = y
            k = 0
        elif y < x[1]:
            k = 0
        elif y < x[2]:
            k = 1
        elif y < x[3]:
            k = 2
        elif y <= x[4]:
            k = 3
        else:
            x[4] = y
            k = 3

        for i in range(k + 1, 5):
            npos[i] += 1
        for i in range(5):
            pos[i] += m[i]

        for i in range(1, 4):
            d = npos[i] - pos[i]
            if (d >= 1 and pos[i + 1] - pos[i] > 1) or (
                d <= -1 and pos[i - 1] - pos[i] < -1
            ):
                d_sign = int(math.copysign(1, d))
                xp = parabolic(i, d_sign)
                if x[i - 1] < xp < x[i + 1]:
                    x[i] = xp
                else:
                    x[i] = linear(i, d_sign)
                pos[i] += d_sign
    return x[2]


# --- Adaptive Warmup Base ---
class AdaptiveWarmup:
    """Warmup mixin for adaptive components."""

    def warmup(self, scales: Tuple[int, int, int] = (1000, 10000, 100000)) -> None:
        rnd = random.Random(42)
        for n in scales:
            v = [rnd.random() for _ in range(n)]
            self.kahan_sum(v)
            self.neumaier_sum(v)
            self.fsum_precise(v)
            self.welford_var(v)
            self.p2_quantile(v, 0.95)
            self.AutoVariantEngine(v)
            self.JIT_exec(v)
            self.AOT_exec(v)
            self.delta_gate(v)
            self.policy_select("sum", v)
            self.policy_select("matmul", v)
            self.policy_select("fft", v)
            self.policy_select("conv", v)
            self.policy_select("argsort", v)
            self.fft_iter(v[: 1 << (len(v) - 1).bit_length()])
            self.ifft_iter(v[: 1 << (len(v) - 1).bit_length()])
            self.conv_fft(v, v[: max(1, len(v) // 10)])
            self.argsort_simple(v)

        self.kahan_sum([1.0, 2.0, 3.0, 4.0])
        self.neumaier_sum([1.0, 2.0, 3.0, 4.0])
        self.fsum_precise([1.0, 2.0, 3.0, 4.0])

        gemm_blocked([[1, 2], [3, 4]], [[5, 6], [7, 8]], block=16)
        gemm_blocked([[1, 2, 3, 4]] * 4, [[1, 2, 3, 4]] * 4, block=32)
        gemm_blocked(
            [[1, 2, 3, 4, 5, 6, 7, 8]] * 8, [[1, 2, 3, 4, 5, 6, 7, 8]] * 8, block=64
        )


# --- PSS Precision Channel ---


class PSSPrecisionCh(AdaptiveWarmup):
    """Adaptive precision control."""

    class Mode(Enum):
        FAST = "fast"
        BALANCED = "balanced"
        PRECISE = "precise"

    def __init__(self) -> None:
        self.mode: PSSPrecisionCh.Mode = self.Mode.BALANCED
        self.err_cap: float = 1e-9
        self.state: Dict[str, Any] = {}
        self.bandit: Dict[str, Dict[str, float]] = {}
        self.mass_profile: str = "plateau"
        self.guard_det: bool = False
        self.prec: PSSPrecisionCh = self

    def set_sla(self, name: str) -> None:
        match name:
            case "fast":
                self.mode = self.Mode.FAST
            case "precise":
                self.mode = self.Mode.PRECISE
            case _:
                self.mode = self.Mode.BALANCED

    def set_guard(self, deterministic: bool) -> None:
        self.guard_det = deterministic

    def kahan_sum(self, it: Iterable[float]) -> float:
        if self.mode is self.Mode.PRECISE:
            return math.fsum(it)
        s = 0.0
        c = 0.0
        for x in it:
            y = x - c
            t = s + y
            c = (t - s) - y
            s = t
        return s

    def welford_var(self, it: Iterable[float]) -> float:
        n = 0
        m = 0.0
        s = 0.0
        for x in it:
            n += 1
            d = x - m
            m += d / n
            s += d * (x - m)
        if n < 2:
            return 0.0
        return s / (n - 1)

    def p2_quantile(self, it: Iterable[float], q: float) -> float:
        if self.mode is self.Mode.PRECISE:
            data = list(it)
            if not data:
                return 0.0
            data.sort()
            k = max(0, min(len(data) - 1, int(q * len(data)) - 1))
            return data[k]
        s = self._p2_init(q)
        for x in it:
            self._p2_feed(s, x)
        n = s["n"]
        if n == 0:
            return 0.0
        if n < 5:
            arr = s["x"][:n]
            arr.sort()
            k = max(0, min(n - 1, int(q * n) - 1))
            return arr[k]
        return s["x"][2]

    def _p2_init(self, q: float) -> Dict[str, Any]:
        return {
            "q": q,
            "n": 0,
            "x": [0.0] * 5,
            "nq": [0, 1, 2, 3, 4],
            "np": [0.0, 2 * q, 4 * q, 2 + 2 * q, 4.0],
            "dn": [0.0, q / 2, q, (1 + q) / 2, 1.0],
        }

    def _p2_feed(self, s: Dict[str, Any], x: float) -> None:
        n = s["n"]
        if n < 5:
            s["x"][n] = x
            s["n"] = n + 1
            if s["n"] == 5:
                s["x"].sort()
                q = s["q"]
                s["nq"] = [0, 1, 2, 3, 4]
                s["np"] = [0.0, 2 * q, 4 * q, 2 + 2 * q, 4.0]
                s["dn"] = [0.0, q / 2, q, (1 + q) / 2, 1.0]
            return
        j = 0
        xs = s["x"]
        if x < xs[0]:
            xs[0] = x
            j = 0
        elif x >= xs[4]:
            xs[4] = x
            j = 3
        else:
            j = 0
            while j < 4 and not (xs[j] <= x < xs[j + 1]):
                j += 1
        for i in range(j + 1, 5):
            s["nq"][i] += 1
        for i in range(5):
            s["np"][i] += s["dn"][i]
        for i in range(1, 4):
            d = s["np"][i] - s["nq"][i]
            if (d >= 1 and s["nq"][i + 1] - s["nq"][i] > 1) or (
                d <= -1 and s["nq"][i - 1] - s["nq"][i] < -1
            ):
                d_sign = int(math.copysign(1, d))
                xp = parabolic(i, d_sign)
                if xs[i - 1] < xp < xs[i + 1]:
                    xs[i] = xp
                else:
                    xs[i] = linear(i, d_sign)
                s["nq"][i] += d_sign

    def mass_set(self, profile: str) -> None:
        self.mass_profile = profile

    def _score_key(self) -> str:
        return f"{self.mode.value}:{self.mass_profile}"

    def learn_mode(self, p95_ms: float, err: float) -> None:
        keys = ["fast", "balanced", "precise"]
        sel = ucb_selector(keys, self.bandit)
        pen = 0.0
        if err > self.err_cap:
            pen += 1.0
        r = -p95_ms - 1000.0 * pen
        reward_bandit(sel, self.bandit, r)
        if sel == "fast" and err <= self.err_cap:
            self.set_sla("fast")
        elif sel == "precise":
            self.set_sla("precise")
        else:
            self.set_sla("balanced")

    def export_policy(self) -> str:
        s = {
            "mode": self.mode.value,
            "err_cap": self.err_cap,
            "mass": self.mass_profile,
            "bandit": self.bandit,
        }
        return json.dumps(s)

    def import_policy(self, s: str) -> None:
        d = json.loads(s)
        self.set_sla(d.get("mode", "balanced"))
        self.err_cap = float(d.get("err_cap", 1e-9))
        self.mass_profile = str(d.get("mass", "plateau"))
        self.bandit = dict(d.get("bandit", {}))


# --- PSS BLAS Channel ---


def __init__(self, prec: Optional[PSSPrecisionCh] = None) -> None:
    self.prec = prec or PSSPrecisionCh()
    self.tile_mc = 64
    self.tile_nc = 64
    self.tile_kc = 64
    self.tile_m = 8
    self.tile_n = 8
    self.mass_profile = "plateau"
    self.TILE_PRESETS = {
        "burst": (128, 64, 64, 8, 8),
        "long_tail": (96, 64, 64, 8, 8),
        "micro": (64, 64, 64, 8, 8),
    }
    if self.mass_profile in self.TILE_PRESETS:
        mc, nc, kc, m, n = self.TILE_PRESETS[self.mass_profile]
        self.tile_mc, self.tile_nc, self.tile_kc = mc, nc, kc
        self.tile_m, self.tile_n = m, n

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def dot(self, x: List[float], y: List[float]) -> float:
        if len(x) != len(y):
            raise ValueError("len mismatch")
        if self.prec.mode is self.prec.Mode.PRECISE:
            return math.fsum(a * b for a, b in zip(x, y))
        s = 0.0
        c = 0.0
        for a, b in zip(x, y):
            z = a * b
            yv = z - c
            t = s + yv
            c = (t - s) - yv
            s = t
        return s

    def axpy(self, a: float, x: List[float], y: List[float]) -> None:
        if len(x) != len(y):
            raise ValueError("len mismatch")
        for i in range(len(x)):
            y[i] = y[i] + a * x[i]

    def scal(self, a: float, x: List[float]) -> None:
        for i in range(len(x)):
            x[i] = a * x[i]

    def nrm2(self, x: List[float]) -> float:
        return math.sqrt(self.dot(x, x))

    def _pick_tiles(self, m: int, n: int, k: int) -> Tuple[int, int, int]:
        match self.mass_profile:
            case "burst":
                return (256, 128, 128)
            case "long_tail":
                return (64, 64, 128)
            case _:
                maxdim = max(m, n)
                if maxdim <= 128:
                    return (32, 32, 64)
                elif maxdim >= 384 and k >= 128:
                    return (256, 128, 128)
                else:
                    return (64, 64, 128)

    def gemm(
        self, a: List[List[float]], b: List[List[float]], c: List[List[float]]
    ) -> None:
        m = len(a)
        k = len(a[0]) if m else 0
        k2 = len(b)
        n = len(b[0]) if k2 else 0
        if k != k2 or len(c) != m or len(c[0]) != n:
            raise ValueError("shape mismatch")
        mc, nc, kc = self._pick_tiles(m, n, k)
        for ii in range(0, m, mc):
            for jj in range(0, n, nc):
                for kk in range(0, k, kc):
                    i2 = min(ii + mc, m)
                    j2 = min(jj + nc, n)
                    k2 = min(kk + kc, k)
                    for i in range(ii, i2):
                        ai = a[i]
                        ci = c[i]
                        for j in range(jj, j2):
                            s = 0.0
                            c0 = 0.0
                            for t in range(kk, k2):
                                z = ai[t] * b[t][j]
                                yv = z - c0
                                tt = s + yv
                                c0 = (tt - s) - yv
                                s = tt
                            ci[j] += s

    def lu(self, a: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]:
        n = len(a)
        if n == 0 or len(a[0]) != n:
            raise ValueError("square needed")
        L = [[0.0] * n for _ in range(n)]
        U = [[0.0] * n for _ in range(n)]
        for i in range(n):
            L[i][i] = 1.0
        for j in range(n):
            for i in range(j + 1):
                s = 0.0
                for k in range(i):
                    s += L[i][k] * U[k][j]
                U[i][j] = a[i][j] - s
            for i in range(j + 1, n):
                s = 0.0
                for k in range(j):
                    s += L[i][k] * U[k][j]
                if U[j][j] == 0.0:
                    raise ValueError("singular")
                L[i][j] = (a[i][j] - s) / U[j][j]
        return L, U

    def qr(self, a: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]:
        m = len(a)
        n = len(a[0]) if m else 0
        Q = [[0.0] * m for _ in range(m)]
        R = [[0.0] * n for _ in range(n)]
        v = [[a[i][j] for i in range(m)] for j in range(n)]
        u = [[0.0] * m for _ in range(n)]
        for j in range(n):
            u[j] = v[j][:]
            for k in range(j):
                r = self.dot(u[k], v[j]) / self.dot(u[k], u[k])
                R[k][j] = r
                for i in range(m):
                    u[j][i] -= r * u[k][i]
            R[j][j] = math.sqrt(self.dot(u[j], u[j]))
            for i in range(m):
                Q[i][j] = u[j][i] / (R[j][j] if R[j][j] else 1.0)
        return Q, R

    def svd(
        self, a: List[List[float]], it: int = 64
    ) -> Tuple[List[List[float]], List[float], List[List[float]]]:
        m = len(a)
        n = len(a[0]) if m else 0
        at = [[a[i][j] for i in range(m)] for j in range(n)]
        ata = [[0.0] * n for _ in range(n)]
        self.gemm(at, a, ata)
        vals, vecs = self._pow_eigs(ata, it)
        s = [math.sqrt(max(0.0, x)) for x in vals]
        V = vecs
        U = [[0.0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                acc = 0.0
                for k in range(n):
                    acc += a[i][k] * V[k][j]
                U[i][j] = acc / (s[j] if s[j] else 1.0)
        return U, s, V

    def _pow_eigs(
        self, a: List[List[float]], it: int
    ) -> Tuple[List[float], List[List[float]]]:
        n = len(a)
        V = [[0.0] * n for _ in range(n)]
        for i in range(n):
            V[i][i] = 1.0
        vals = [0.0] * n
        for k in range(n):
            v = [random.random() for _ in range(n)]
            for _ in range(it):
                w = [0.0] * n
                for i in range(n):
                    s = 0.0
                    for j in range(n):
                        s += a[i][j] * v[j]
                    w[i] = s
                nv = self.nrm2(w)
                if nv == 0.0:
                    break
                v = [x / nv for x in w]
            lam = 0.0
            for i in range(n):
                s = 0.0
                for j in range(n):
                    s += a[i][j] * v[j]
                lam += v[i] * s
            vals[k] = lam
            for i in range(n):
                V[i][k] = v[i]
        return vals, V


# --- PSS Vector Seq Channel ---


class PSSVectorSeqCh(AdaptiveWarmup):
    """Vector sequence operations."""

    def __init__(self, prec: Optional[PSSPrecisionCh] = None) -> None:
        self.prec = prec or PSSPrecisionCh()
        self.mass_profile = "plateau"
        self.win = 64
        self.bandit: Dict[str, Dict[str, float]] = {}

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def set_window(self, n: int) -> None:
        self.win = max(1, n)

    def rolling_sum(self, it: Iterable[float]) -> Iterable[float]:
        q = deque()
        s = 0.0
        for x in it:
            q.append(x)
            s += x
            if len(q) > self.win:
                s -= q.popleft()
            yield s

    def rolling_mean(self, it: Iterable[float]) -> Iterable[float]:
        for s in self.rolling_sum(it):
            yield s / self.win

    def rolling_var(self, it: Iterable[float]) -> Iterable[float]:
        q = deque()
        s = 0.0
        s2 = 0.0
        for x in it:
            q.append(x)
            s += x
            s2 += x * x
            if len(q) > self.win:
                y = q.popleft()
                s -= y
                s2 -= y * y
            n = len(q)
            m = s / n
            v = (s2 / n) - m * m
            yield max(0.0, v)

    def batched(self, it: Iterable[Any], k: int) -> Iterable[List[Any]]:
        b: List[Any] = []
        for x in it:
            b.append(x)
            if len(b) == k:
                yield b
                b = []
        if b:
            yield b

    def compose(self, fns: List[Callable]) -> Callable:
        def call(x: Any) -> Any:
            y = x
            for f in fns:
                y = f(y)
            return y

        return call

    def tap(self, it: Iterable[Any], fn: Callable) -> Iterable[Any]:
        for x in it:
            fn(x)
            yield x

    def tee(self, it: Iterable[Any], k: int) -> List[Iterable[Any]]:
        from itertools import tee

        return list(tee(it, k))

    def learn_window(self, p95_ms: float) -> None:
        keys = ["16", "32", "64", "128", "256"]
        sel = ucb_selector(keys, self.bandit)
        self.win = int(sel)
        reward_bandit(sel, self.bandit, -p95_ms)

    def run_pipe(self, it: Iterable[float], steps: List[Callable]) -> Iterable[Any]:
        f = self.compose(steps)
        for x in it:
            yield f(x)


# --- PSS Fourier Channel ---


class PSSFourierCh(AdaptiveWarmup):
    """Fourier transforms with adaptive routing."""

    def __init__(
        self, prec: Optional[PSSPrecisionCh] = None, blas: Optional[PSSBlasCh] = None
    ) -> None:
        self.prec = prec or PSSPrecisionCh()
        self.blas = blas or PSSBlasCh(self.prec)
        self.mass_profile = "plateau"

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def _is_pow2(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0

    def fft(self, x: List[float] | List[complex]) -> List[complex]:
        n = len(x)
        if n <= 1:
            return [complex(xi) for xi in x]
        even = self.fft(x[0::2])
        odd = self.fft(x[1::2])
        T = [exp(-2j * pi * k / n) * odd[k] for k in range(n // 2)]
        return [even[k] + T[k] for k in range(n // 2)] + [
            even[k] - T[k] for k in range(n // 2)
        ]

    def ifft(self, x: List[complex]) -> List[complex]:
        n = len(x)
        conj_x = [xi.conjugate() for xi in x]
        y = self.fft(conj_x)
        return [yi.conjugate() / n for yi in y]

    def _next_pow2(self, n: int) -> int:
        k = 1
        while k < n:
            k <<= 1
        return k

    def _bluestein(self, a: List[complex]) -> List[complex]:
        n = len(a)
        m = self._next_pow2(2 * n - 1)
        ang = math.pi / n
        w = [complex(cos(ang * i * i), -sin(ang * i * i)) for i in range(n)]
        aw = [a[i] * w[i] for i in range(n)]
        Aw = self.fft(aw + [0j] * (m - n))
        ww = [0j] * m
        for i in range(n):
            ww[i] = w[i].conjugate()
        for i in range(1, n):
            ww[m - i] = w[i].conjugate()
        Ww = self.fft(ww)
        Y = [Aw[i] * Ww[i] for i in range(m)]
        y = self.ifft(Y)
        res = [0j] * n
        for i in range(n):
            res[i] = y[i] * w[i]
        return res

    def conv(self, a: List[float], b: List[float]) -> List[float]:
        n = len(a) + len(b) - 1
        use_fft = len(a) * len(b) > 2048
        if use_fft:
            m = self._next_pow2(n)
            fa = self.fft([complex(x, 0.0) for x in a] + [0j] * (m - len(a)))
            fb = self.fft([complex(x, 0.0) for x in b] + [0j] * (m - len(b)))
            yc = [fa[i] * fb[i] for i in range(m)]
            y = self.ifft(yc)
            return [y[i].real for i in range(n)]
        y = [0.0] * n
        for i in range(len(a)):
            ai = a[i]
            for j in range(len(b)):
                y[i + j] += ai * b[j]
        return y

    def xcorr(self, a: List[float], b: List[float]) -> List[float]:
        rb = list(reversed(b))
        return self.conv(a, rb)

    def series_sum(self, coeffs: List[float], z: complex) -> complex:
        s = 0j
        p = complex(1.0, 0.0)
        for c in coeffs:
            s += c * p
            p *= z
        return s

    def fft_blas_bridge(
        self, X: List[List[complex]], Y: List[List[complex]]
    ) -> List[List[complex]]:
        m = len(X)
        n = len(Y[0]) if Y else 0
        k = len(X[0]) if X else 0
        A = [[X[i][t].real for t in range(k)] for i in range(m)]
        B = [[Y[t][j].real for j in range(n)] for t in range(k)]
        C = [[0.0] * n for _ in range(m)]
        self.blas.gemm(A, B, C)
        Z = [[complex(C[i][j], 0.0) for j in range(n)] for i in range(m)]
        return Z

    def learn_route(self, n: int, p95_ms: float) -> None:
        if n < 2048 and p95_ms < 1.0:
            self.mass_profile = "plateau"
        elif n > 16384:
            self.mass_profile = "burst"
        else:
            self.mass_profile = "long_tail"


# --- PSS Loop Channel ---


class PSSLoopCh(AdaptiveWarmup):
    """Adaptive loop dispatch."""

    def __init__(self, sla: str = "balanced") -> None:
        self.sla = sla
        self.mass_profile = "plateau"
        self.delta_hits = 0
        self.bandit: Dict[str, Dict[str, float]] = {}
        self.hist: deque[Tuple[str, float]] = deque(maxlen=64)

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def _reward(self, key: str, p95_ms: float, penalty: float = 0.0) -> None:
        reward_bandit(key, self.bandit, -p95_ms - penalty)

    def _now(self) -> float:
        return time.perf_counter()

    def _p95(self, xs: List[float]) -> float:
        if not xs:
            return 0.0
        ys = sorted(xs)
        k = int(0.95 * (len(ys) - 1))
        return ys[k]

    def _guard(self, ok: bool, msg: str) -> None:
        if not ok:
            raise VisibleError(msg)

    def _safe_eval(self, expr: str, env: Dict[str, Any]) -> Any:
        if "import" in expr or "__" in expr:
            raise SecurityCriticalError("banned")
        return eval(expr, {"__builtins__": {}}, env)

    def _split_bins(self, n: int) -> Tuple[int, int, int]:
        m, b, f = 8, 4, 4
        match self.mass_profile:
            case "burst":
                m, b, f = 16, 8, 2
            case "long_tail":
                m, b, f = 4, 4, 8
        return max(1, m), max(1, b), max(1, f)

    def run_each(self, seq: Iterable[Any], expr: str) -> List[Any]:
        st = self._now()
        out: List[Any] = []
        for x in seq:
            y = self._safe_eval(expr, {"x": x})
            out.append(y)
        p95 = (self._now() - st) * 1e3
        self._reward("each", p95)
        self.hist.append(("each", p95))
        return out

    def run_count(self, n: int, expr: str, fmt: str = "f") -> memoryview:
        self._guard(n >= 0, "n >=0")
        size = struct.calcsize(fmt)
        buf = bytearray(n * size)
        mv = memoryview(buf)
        st = self._now()
        off = 0
        for i in range(n):
            v = self._safe_eval(expr, {"i": i})
            struct.pack_into(fmt, mv, off, float(v))
            off += size
        p95 = (self._now() - st) * 1e3
        self._reward("count", p95)
        self.hist.append(("count", p95))
        return mv

    def run_chunk(
        self,
        mv: memoryview,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable] = None,
    ) -> memoryview:
        n = len(mv)
        self._guard(parts > 0, "parts >0")
        st = self._now()
        step = max(1, n // parts)
        for i in range(0, n, step):
            ch = mv[i : i + step]
            if update is not None:
                update(ch, i)
            if (i // step) % 4 == 0:
                t0 = self._now()
                while (self._now() - t0) * 1e3 < flush_ms:
                    pass
        p95 = (self._now() - st) * 1e3
        self._reward("chunk", p95)
        self.hist.append(("chunk", p95))
        return mv

    def plan_auto(self, size: int, expr_kind: str) -> str:
        keys = ["each", "count", "chunk"]
        pick = ucb_selector(keys, self.bandit)
        match expr_kind:
            case "map" if size <= 10000:
                pick = "each"
            case "gen":
                pick = "count"
            case "buf":
                pick = "chunk"
        return pick

    def run_auto(
        self,
        size: int,
        expr_kind: str,
        *,
        seq: Optional[Iterable[Any]] = None,
        expr: Optional[str] = None,
        fmt: str = "f",
        mv: Optional[memoryview] = None,
    ) -> Any:
        route = self.plan_auto(size, expr_kind)
        match route:
            case "each":
                self._guard(seq is not None and expr is not None, "need seq,expr")
                return self.run_each(seq, expr)
            case "count":
                self._guard(expr is not None, "need expr")
                return self.run_count(size, expr, fmt)
            case "chunk":
                self._guard(mv is not None, "need mv")
                return self.run_chunk(mv)
            case _:
                raise VisibleError("invalid route")

    def learn_route(self, p95_ms: float) -> None:
        if p95_ms > 10.0:
            self.mass_profile = "burst"
        elif p95_ms < 1.0:
            self.mass_profile = "plateau"
        else:
            self.mass_profile = "long_tail"

    def match_case_route(
        self, size: int, shape_bin: int, boundary: str, err: str
    ) -> str:
        route = "each"
        match (shape_bin, boundary, err):
            case (0, "tight", "low"):
                route = "each"
            case (1, "loose", "mid"):
                route = "count"
            case (2, "edge", "mid"):
                route = "chunk"
            case _:
                route = "count" if size > 10000 else "each"
        return route

    def export_policy(self) -> str:
        s = {
            "sla": self.sla,
            "mass": self.mass_profile,
            "bandit": self.bandit,
        }
        return json.dumps(s)

    def import_policy(self, s: str) -> None:
        d = json.loads(s)
        self.sla = str(d.get("sla", "balanced"))
        self.mass_profile = str(d.get("mass", "plateau"))
        self.bandit = dict(d.get("bandit", {}))


# --- PSS Buffer Channel ---


class PSSBufferCh:
    """Ring buffer with slots."""

    SLOT = 64 * 1024

    def __init__(self, slots: int = 32) -> None:
        self.slots = slots
        self.ring: deque[memoryview] = deque(maxlen=self.slots)
        self.hot: Dict[int, memoryview] = {}
        self.mass_profile = "plateau"
        self.metrics: List[Dict[str, float]] = []
        self.bytes_now = 0
        self.hits = 0
        self.miss = 0
        self.tick = 0

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def alloc_slot(self, data: bytes) -> int:
        if len(data) > self.SLOT:
            raise VisibleError("oversize")
        buf = bytearray(self.SLOT)
        mv = memoryview(buf)
        mv[: len(data)] = data
        if len(self.ring) >= self.slots:
            self._cold_dump()
        self.ring.append(mv)
        sid = (self.tick + len(self.ring)) % 1000000007
        self.hot[sid] = mv
        self.bytes_now += self.SLOT
        return sid

    def hot_fill(self, sid: int, data: bytes) -> None:
        mv = self.hot.get(sid)
        if mv is None:
            raise VisibleError("sid invalid")
        if len(data) > len(mv):
            raise VisibleError("oversize")
        mv[: len(data)] = data

    def _cold_dump(self) -> None:
        if not self.ring:
            return
        mv = self.ring.popleft()
        self.bytes_now -= len(mv)
        keys = [k for k, v in self.hot.items() if v is mv]
        for k in keys:
            del self.hot[k]
        self.miss += 1

    def flush(self, ms: int = 4) -> None:
        t0 = time.perf_counter()
        while (time.perf_counter() - t0) * 1e3 < ms:
            if self.mass_profile == "burst":
                if len(self.ring) > self.slots // 2:
                    self._cold_dump()
            else:
                break

    def sonic_prewarm(self) -> None:
        rnd = random.Random(31)
        for n in (100, 10000, 1000000):
            k = min(self.SLOT // 4, n)
            vals = [rnd.random() for _ in range(k)]
            buf = bytearray(self.SLOT)
            mv = memoryview(buf)
            struct.pack_into(f"{k}f", mv, 0, *vals)
            _ = self.alloc_slot(mv.tobytes())

    def get_ring_view(self) -> Iterable[memoryview]:
        return list(self.ring)

    def snapshot(
        self, qps: float, io_hide: float, jit_hit: float, tier: int
    ) -> Dict[str, float]:
        p50 = 0.0
        p95 = 0.0
        if self.metrics:
            ys = sorted(m["lat"] for m in self.metrics)
            k = max(0, min(len(ys) - 1, len(ys) // 2))
            p50 = ys[k]
            j = max(0, min(len(ys) - 1, int(0.95 * len(ys) - 1)))
            p95 = ys[j]
        return {
            "p50_ms": p50,
            "p95_ms": p95,
            "qps": float(qps),
            "io_hide_ratio": float(io_hide),
            "jit_hit_ratio": float(jit_hit),
            "tier": float(tier),
            "bytes": float(self.bytes_now),
            "hits": float(self.hits),
            "miss": float(self.miss),
        }

    def record_latency(self, ms: float) -> None:
        self.metrics.append({"lat": ms})

    def mass_adjust(self) -> None:
        cap = self.slots * self.SLOT
        ratio = 0.0 if cap == 0 else self.bytes_now / cap
        if ratio > 0.8:
            self.mass_profile = "burst"
        elif ratio < 0.2:
            self.mass_profile = "long_tail"
        else:
            self.mass_profile = "plateau"

    def export_policy(self) -> str:
        s = {
            "mass": self.mass_profile,
            "slots": self.slots,
            "bytes": self.bytes_now,
        }
        return json.dumps(s)

    def import_policy(self, s: str) -> None:
        d = json.loads(s)
        self.mass_profile = str(d.get("mass", "plateau"))
        self.slots = int(d.get("slots", self.slots))


# --- PSS Poly Lang Channel ---


class PSSPolyLangCh(AdaptiveWarmup):
    """Polymorphic language ops."""

    class Mode(Enum):
        PIPE = "pipe"
        DECL = "decl"
        IMP = "imp"

    def __init__(self) -> None:
        self.mode: PSSPolyLangCh.Mode = self.Mode.PIPE
        self.mass_profile = "plateau"
        self.queues: Dict[str, deque[Any]] = {}
        self.deadline_ms = 50
        self.bindings: Dict[str, Any] = {}
        self.bandit: Dict[str, Dict[str, float]] = {}
        self.hist: deque[Tuple[str, float]] = deque(maxlen=64)

    def set_mass(self, s: str) -> None:
        self.mass_profile = s

    def set_mode(self, name: str) -> None:
        match name:
            case "decl":
                self.mode = self.Mode.DECL
            case "imp":
                self.mode = self.Mode.IMP
            case _:
                self.mode = self.Mode.PIPE

    def channel_new(self, name: str) -> None:
        self.queues[name] = deque()

    def channel_send(self, name: str, x: Any) -> None:
        q = self.queues.get(name)
        if q is None:
            raise VisibleError("chan invalid")
        q.append(x)

    def channel_recv(
        self, name: str, timeout_ms: Optional[int] = None
    ) -> Optional[Any]:
        q = self.queues.get(name)
        if q is None:
            raise VisibleError("chan invalid")
        to = self.deadline_ms if timeout_ms is None else timeout_ms
        t0 = time.perf_counter()
        while (time.perf_counter() - t0) * 1e3 < to:
            if q:
                return q.popleft()
        return None

    def gather(self, names: List[str], timeout_ms: int) -> List[Any]:
        out: List[Any] = []
        t0 = time.perf_counter()
        while (time.perf_counter() - t0) * 1e3 < timeout_ms:
            any_hit = False
            for nm in names:
                q = self.queues.get(nm)
                if q and q:
                    out.append(q.popleft())
                    any_hit = True
            if not any_hit:
                break
        return out

    def zero_copy_view(self, b: bytearray) -> memoryview:
        return memoryview(b)

    def map_pipe(self, it: Iterable[Any], fns: List[Callable]) -> Iterable[Any]:
        def comp(x: Any) -> Any:
            y = x
            for f in fns:
                y = f(y)
            return y

        for x in it:
            yield comp(x)

    def reduce_pipe(self, it: Iterable[Any], fn: Callable, init: Any) -> Any:
        acc = init
        for x in it:
            acc = fn(acc, x)
        return acc

    def decl_groupby_sum(self, it: Iterable[Tuple[Any, float]]) -> Dict[Any, float]:
        d: Dict[Any, float] = {}
        for k, v in it:
            d[k] = d.get(k, 0.0) + v
        return d

    def decl_sort(
        self, it: Iterable[Any], key: Optional[Callable] = None, rev: bool = False
    ) -> List[Any]:
        xs = list(it)
        xs.sort(key=key, reverse=rev)
        return xs

    def imp_loop(self, n: int, step: int, fn: Callable) -> List[Any]:
        out: List[Any] = []
        for i in range(0, n, step):
            out.append(fn(i))
        return out

    def plan_mode(self, size: int, ops: str) -> str:
        keys = ["pipe", "decl", "imp"]
        pick = ucb_selector(keys, self.bandit)
        match (ops, size):
            case ("group", _) if size > 10000:
                pick = "decl"
            case ("map", _) if size <= 10000:
                pick = "pipe"
            case ("scan", _):
                pick = "imp"
        return pick

    def run_auto(
        self,
        size: int,
        ops: str,
        *,
        pipe: Optional[Tuple[Iterable[Any], List[Callable]]] = None,
        decl: Optional[Iterable[Tuple[Any, float]]] = None,
        imp: Optional[Tuple[int, int, Callable]] = None,
    ) -> Any:
        pick = self.plan_mode(size, ops)
        st = time.perf_counter()
        match pick:
            case "pipe":
                if pipe is None:
                    raise VisibleError("pipe needed")
                it, fns = pipe
                out = list(self.map_pipe(it, fns))
            case "decl":
                if decl is None:
                    raise VisibleError("decl needed")
                out = self.decl_groupby_sum(decl)
            case "imp":
                if imp is None:
                    raise VisibleError("imp needed")
                n, step, fn = imp
                out = self.imp_loop(n, step, fn)
            case _:
                raise VisibleError("pick invalid")
        p95 = (time.perf_counter() - st) * 1e3
        reward_bandit(pick, self.bandit, -p95)
        self.hist.append((pick, p95))
        return out

    def match_switch(self, kind: str, shape: str, boundary: str) -> str:
        mode = "pipe"
        match (kind, shape, boundary):
            case ("group", "wide", "loose"):
                mode = "decl"
            case ("scan", "tall", "edge"):
                mode = "imp"
            case _:
                mode = "pipe"
        return mode

    def export_policy(self) -> str:
        s = {
            "mode": self.mode.value,
            "mass": self.mass_profile,
            "bandit": self.bandit,
        }
        return json.dumps(s)

    def import_policy(self, s: str) -> None:
        d = json.loads(s)
        self.set_mode(str(d.get("mode", "pipe")))
        self.mass_profile = str(d.get("mass", "plateau"))
        self.bandit = dict(d.get("bandit", {}))


# --- PSS Symbolica Core ---


Scalar = Union[int, float, "PSSSymbolicaCore.Expr", "PSSSymbolicaCore.Sym"]


class PSSSymbolicaCore:
    """Symbolic algebra core."""

    @dataclass(frozen=True)
    class Sym:
        name: str

        def __repr__(self) -> str:
            return self.name

        def __add__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("+", self, o)

        def __radd__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("+", o, self)

        def __sub__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("-", self, o)

        def __rsub__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("-", o, self)

        def __mul__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("*", self, o)

        def __rmul__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("*", o, self)

        def __truediv__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("/", self, o)

        def __rtruediv__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("/", o, self)

        def __pow__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("**", self, o)

        def __neg__(self) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.unary("neg", self)

    @dataclass(frozen=True)
    class Expr:
        op: str
        args: Tuple["PSSSymbolicaCore.Expr", ...]

        @staticmethod
        def atom(x: Scalar) -> "PSSSymbolicaCore.Expr":
            E = PSSSymbolicaCore.Expr
            if isinstance(x, E):
                return x
            if isinstance(x, PSSSymbolicaCore.Sym):
                return E("sym", (E._str(x.name),))
            if isinstance(x, (int, float)):
                return E("num", (E._lit(float(x)),))
            raise TypeError("unsupported type")

        @staticmethod
        def _lit(v: Any) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr("lit", (v,))

        @staticmethod
        def _str(s: str) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr("str", (PSSSymbolicaCore.Expr._lit(s),))

        @staticmethod
        def unary(op: str, a: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr(
                op, (PSSSymbolicaCore.Expr.atom(a),)
            ).simplify()

        @staticmethod
        def bin(op: str, a: Scalar, b: Scalar) -> "PSSSymbolicaCore.Expr":
            x = PSSSymbolicaCore.Expr.atom(a)
            y = PSSSymbolicaCore.Expr.atom(b)
            return PSSSymbolicaCore.Expr(op, (x, y)).simplify()

        def __repr__(self) -> str:
            op, a = self.op, self.args
            if op == "num":
                return repr(a[0].args[0])
            if op == "sym":
                return str(a[0].args[0])
            if op == "neg":
                return f"-{a[0]!r}"
            if op in {"sin", "cos", "tan", "exp", "log", "sqrt"}:
                return f"{op}({a[0]!r})"
            if op == "str":
                return repr(a[0].args[0])
            if op == "lit":
                return repr(a[0])
            s = ", ".join(repr(t) for t in a)
            return f"Expr({op},{s})"

        def __add__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("+", self, o)

        def __radd__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("+", o, self)

        def __sub__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("-", self, o)

        def __rsub__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("-", o, self)

        def __mul__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("*", self, o)

        def __rmul__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("*", o, self)

        def __truediv__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("/", self, o)

        def __rtruediv__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("/", o, self)

        def __pow__(self, o: Scalar) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.bin("**", self, o)

        def __neg__(self) -> "PSSSymbolicaCore.Expr":
            return PSSSymbolicaCore.Expr.unary("neg", self)

        def is_num(self) -> bool:
            return self.op == "num"

        def is_sym(self) -> bool:
            return self.op == "sym"

        def num(self) -> float:
            if not self.is_num():
                raise ValueError("not numeric")
            return float(self.args[0].args[0])

        def sym(self) -> str:
            if not self.is_sym():
                raise ValueError("not symbol")
            return str(self.args[0].args[0])

        def subs(
            self, m: Dict[Union[str, "PSSSymbolicaCore.Sym"], float]
        ) -> "PSSSymbolicaCore.Expr":
            def rec(e: "PSSSymbolicaCore.Expr") -> "PSSSymbolicaCore.Expr":
                if e.op == "sym":
                    k = e.args[0].args[0]
                    if k in m:
                        return ps_num(m[k])
                    return e
                if e.op in {"num", "str", "lit"}:
                    return e
                return PSSSymbolicaCore.Expr(e.op, tuple(rec(x) for x in e.args))

            return rec(self).simplify()

        def simplify(self) -> "PSSSymbolicaCore.Expr":
            op, a = self.op, self.args
            E = PSSSymbolicaCore.Expr
            if op in {"num", "sym", "str", "lit"}:
                return self
            if op in {"sin", "cos", "tan", "exp", "log", "sqrt", "neg"}:
                x = a[0].simplify()
                if op == "neg":
                    if x.op == "num":
                        return ps_num(-x.args[0].args[0])
                    return E("neg", (x,))
                if x.op == "num":
                    v = x.args[0].args[0]
                    if op == "sin":
                        return ps_num(math.sin(v))
                    if op == "cos":
                        return ps_num(math.cos(v))
                    if op == "tan":
                        return ps_num(math.tan(v))
                    if op == "exp":
                        return ps_num(math.exp(v))
                    if op == "log":
                        return ps_num(math.log(v))
                    if op == "sqrt" and v >= 0.0:
                        return ps_num(math.sqrt(v))
                return E(op, (x,))
            x, y = a[0].simplify(), a[1].simplify()
            if op in {"+", "*"}:
                items: List[PSSSymbolicaCore.Expr] = []
                for z in (x, y):
                    if z.op == op:
                        items.extend(z.args)
                    else:
                        items.append(z)
                items = sorted(items, key=_key)
                nums = [t for t in items if t.op == "num"]
                rest = [t for t in items if t.op != "num"]
                if nums:
                    if op == "+":
                        s = sum(t.args[0].args[0] for t in nums)
                        if s != 0.0:
                            rest = [ps_num(s)] + rest
                    else:
                        s = 1.0
                        for t in nums:
                            s *= t.args[0].args[0]
                        if s == 0.0:
                            return ps_num(0.0)
                        if s != 1.0:
                            rest = [ps_num(s)] + rest
                if not rest:
                    return ps_num(0.0 if op == "+" else 1.0)
                if len(rest) == 1:
                    return rest[0]
                return E(op, tuple(rest))
            if op == "-":
                return (x + (-y)).simplify()
            if op == "/":
                if y.op == "num":
                    d = y.args[0].args[0]
                    if d == 1.0:
                        return x
                    if x.op == "num":
                        return ps_num(x.args[0].args[0] / d)
                return E("/", (x, y))
            if op == "**":
                if y.op == "num":
                    p = y.args[0].args[0]
                    if p == 0.0:
                        return ps_num(1.0)
                    if p == 1.0:
                        return x
                    if x.op == "num":
                        return ps_num(x.args[0].args[0] ** p)
                return E("**", (x, y))
            return E(op, (x, y))

        def expand(self, depth: int = 6) -> "PSSSymbolicaCore.Expr":
            if depth <= 0:
                return self
            E = PSSSymbolicaCore.Expr
            e = E(self.op, tuple(E.atom(t) for t in self.args)).simplify()
            if e.op in {"+", "-"}:
                return E(e.op, tuple(a.expand(depth - 1) for a in e.args)).simplify()
            if e.op == "*":
                L, R = e.args[0].expand(depth - 1), e.args[1].expand(depth - 1)
                if L.op == "+":
                    ts = [E.atom(t) for t in (t * R for t in L.args)]
                    ts = [t.expand(depth - 1) for t in ts]
                    return sum_expr(ts).simplify()
                if R.op == "+":
                    ts = [E.atom(t) for t in (L * t for t in R.args)]
                    ts = [t.expand(depth - 1) for t in ts]
                    return sum_expr(ts).simplify()
                return (L * R).simplify()
            if e.op == "**":
                base, pw = e.args
                if base.op == "+" and pw.op == "num":
                    k = pw.args[0].args[0]
                    if float(k).is_integer() and 0 <= int(k) <= 5:
                        n = int(k)
                        acc = ps_num(1.0)
                        for _ in range(n):
                            acc = (acc * base).expand(depth - 1).simplify()
                        return acc.simplify()
                return e
            if e.op in {"num", "sym", "sin", "cos", "sqrt"}:
                return PSSSymbolicaCore.Expr(
                    e.op,
                    tuple(
                        a.expand(depth - 1)
                        if isinstance(a, PSSSymbolicaCore.Expr)
                        else E.atom(a)
                        for a in e.args
                    ),
                ).simplify()
            return e

        def collect(self) -> "PSSSymbolicaCore.Expr":
            e = self.expand().simplify()
            if e.op != "+":
                return e
            acc: Dict[str, PSSSymbolicaCore.Expr] = {}
            rest: List[PSSSymbolicaCore.Expr] = []
            for t in e.args:
                c, k, ok = _coeff_key_safe(t)
                if not ok:
                    rest.append(t)
                    continue
                acc[k] = (acc.get(k, ps_num(0.0)) + c).simplify()
            terms: List[PSSSymbolicaCore.Expr] = []
            for k, c in sorted(acc.items(), key=lambda kv: kv[0]):
                if c.op == "num" and c.args[0].args[0] == 0.0:
                    continue
                if k == "1":
                    terms.append(c)
                else:
                    terms.append((c * _key_to_expr(k)).simplify())
            terms.extend(rest)
            if not terms:
                return ps_num(0.0)
            return sum_expr(terms).simplify()

        def evalf(self) -> float:
            e = self.simplify()
            if not e.is_num():
                raise ValueError("not numeric")
            return e.args[0].args[0]

    class Matrix:
        """Symbolic matrix."""

        def __init__(self, data: List[List[Scalar]]) -> None:
            if not data or not data[0]:
                raise ValueError("empty")
            w = len(data[0])
            for r in data:
                if len(r) != w:
                    raise ValueError("ragged")
            E = PSSSymbolicaCore.Expr
            self.a = [[E.atom(x) for x in r] for r in data]
            self.n = len(self.a)
            self.m = w

        @property
        def shape(self) -> Tuple[int, int]:
            return (self.n, self.m)

        def copy(self) -> "PSSSymbolicaCore.Matrix":
            return PSSSymbolicaCore.Matrix([[c for c in r] for r in self.a])

        def T(self) -> "PSSSymbolicaCore.Matrix":
            cols = list(zip(*self.a))
            return PSSSymbolicaCore.Matrix([list(c) for c in cols])

        def add(self, other: "PSSSymbolicaCore.Matrix") -> "PSSSymbolicaCore.Matrix":
            if self.shape != other.shape:
                raise ValueError("shape mismatch")
            out = []
            for i in range(self.n):
                out.append(
                    [(self.a[i][j] + other.a[i][j]).simplify() for j in range(self.m)]
                )
            return PSSSymbolicaCore.Matrix(out)

        def scalar(self, s: Scalar) -> "PSSSymbolicaCore.Matrix":
            k = PSSSymbolicaCore.Expr.atom(s)
            out = []
            for i in range(self.n):
                out.append([(k * self.a[i][j]).simplify() for j in range(self.m)])
            return PSSSymbolicaCore.Matrix(out)

        def mul(self, other: "PSSSymbolicaCore.Matrix") -> "PSSSymbolicaCore.Matrix":
            if self.m != other.n:
                raise ValueError("inner mismatch")
            out: List[List[PSSSymbolicaCore.Expr]] = []
            for i in range(self.n):
                row: List[PSSSymbolicaCore.Expr] = []
                for j in range(other.m):
                    s = ps_num(0.0)
                    for k in range(self.m):
                        s = (s + self.a[i][k] * other.a[k][j]).simplify()
                    row.append(s)
                out.append(row)
            return PSSSymbolicaCore.Matrix(out)

        def trace(self) -> "PSSSymbolicaCore.Expr":
            if self.n != self.m:
                raise ValueError("square required")
            s = ps_num(0.0)
            for i in range(self.n):
                s = (s + self.a[i][i]).simplify()
            return s

        def _lu(
            self,
        ) -> Tuple[
            List[List["PSSSymbolicaCore.Expr"]], List[List["PSSSymbolicaCore.Expr"]]
        ]:
            if self.n != self.m:
                raise ValueError("square required")
            n = self.n
            L = [[ps_num(0.0) for _ in range(n)] for _ in range(n)]
            U = [[ps_num(0.0) for _ in range(n)] for _ in range(n)]
            for i in range(n):
                L[i][i] = ps_num(1.0)
            for j in range(n):
                for i in range(j + 1):
                    s = ps_num(0.0)
                    for k in range(i):
                        s = (s + L[i][k] * U[k][j]).simplify()
                    U[i][j] = (self.a[i][j] - s).simplify()
                for i in range(j + 1, n):
                    s = ps_num(0.0)
                    for k in range(j):
                        s = (s + L[i][k] * U[k][j]).simplify()
                    if U[j][j].op == "num" and U[j][j].args[0].args[0] == 0.0:
                        raise ValueError("singular pivot")
                    L[i][j] = ((self.a[i][j] - s) / U[j][j]).simplify()
            return L, U

        def det(self) -> "PSSSymbolicaCore.Expr":
            L, U = self._lu()
            d = ps_num(1.0)
            for i in range(self.n):
                d = (d * U[i][i]).simplify()
            return d

        def inv(self) -> "PSSSymbolicaCore.Matrix":
            if self.n != self.m:
                raise ValueError("square required")
            L, U = self._lu()
            n = self.n
            I = [[ps_num(1.0 if i == j else 0.0) for j in range(n)] for i in range(n)]
            cols: List[List[PSSSymbolicaCore.Expr]] = []
            for j in range(n):
                y = _forward(L, [I[i][j] for i in range(n)])
                x = _backward(U, y)
                cols.append(x)
            inv_t = PSSSymbolicaCore.Matrix(cols)
            return inv_t.T()

        def solve(self, b: List[Scalar]) -> List["PSSSymbolicaCore.Expr"]:
            if len(b) != self.n:
                raise ValueError("size mismatch")
            L, U = self._lu()
            y = _forward(L, [PSSSymbolicaCore.Expr.atom(x) for x in b])
            x = _backward(U, y)
            return x

        def rank(self) -> int:
            A = [[c for c in r] for r in self.a]
            n, m = self.n, self.m
            i = j = rnk = 0
            while i < n and j < m:
                pivot = None
                for k in range(i, n):
                    v = A[k][j].simplify()
                    if v.op == "num" and v.args[0].args[0] != 0.0:
                        pivot = k
                        break
                if pivot is None:
                    j += 1
                    continue
                A[i], A[pivot] = A[pivot], A[i]
                pv = A[i][j]
                for k in range(i + 1, n):
                    f = (A[k][j] / pv).simplify()
                    for t in range(j, m):
                        A[k][t] = (A[k][t] - f * A[i][t]).simplify()
                i += 1
                j += 1
                rnk += 1
            return rnk

        def to_list(self) -> List[List["PSSSymbolicaCore.Expr"]]:
            return [[c.simplify() for c in r] for r in self.a]


def _key(e: PSSSymbolicaCore.Expr) -> Tuple:
    if e.op == "num":
        return (0, e.args[0].args[0])
    if e.op == "sym":
        return (1, e.args[0].args[0])
    if e.op == "lit":
        return (3, e.args[0])
    return (2, e.op, tuple(_key(a) for a in e.args))


def _coeff_key_safe(
    e: PSSSymbolicaCore.Expr,
) -> Tuple[PSSSymbolicaCore.Expr, str, bool]:
    if e.op == "num":
        return e, "1", True
    if e.op == "sym":
        return ps_num(1.0), f"x:{e.args[0].args[0]}^1", True
    if e.op == "*":
        c = ps_num(1.0)
        m: Dict[str, int] = {}
        for a in e.args:
            ca, ka, ok = _coeff_key_safe(a)
            if not ok:
                return ps_num(1.0), "", False
            c = (c * ca).simplify()
            if ka != "1":
                _, nm, pw = _parse_mkey(ka)
                m[nm] = m.get(nm, 0) + pw
        key = "*".join(f"x:{k}^{m[k]}" for k in sorted(m))
        return c, (key if key else "1"), True
    if e.op == "**" and e.args[0].op == "sym" and e.args[1].op == "num":
        s = e.args[0].args[0]
        p = int(e.args[1].args[0].args[0])
        return ps_num(1.0), f"x:{s}^{p}", True
    return ps_num(1.0), "", False


def _parse_mkey(k: str) -> Tuple[str, str, int]:
    if k == "1":
        return ("x", "", 0)
    h, t = k.split(":", 1)
    nm, pw = t.split("^", 1)
    return h, nm, int(pw)


def _key_to_expr(k: str) -> PSSSymbolicaCore.Expr:
    if k == "1":
        return ps_num(1.0)
    parts: List[PSSSymbolicaCore.Expr] = []
    for term in k.split("*"):
        if not term.startswith("x:"):
            return PSSSymbolicaCore.Expr._str(term)
        _, nm, p = _parse_mkey(term)
        base = PSSSymbolicaCore.Expr("sym", (PSSSymbolicaCore.Expr._lit(nm),))
        if p == 1:
            parts.append(base)
        else:
            parts.append(PSSSymbolicaCore.Expr("**", (base, ps_num(float(p)))))
    if len(parts) == 1:
        return parts[0]
    return PSSSymbolicaCore.Expr("*", tuple(parts)).simplify()


def sum_expr(items: Iterable[PSSSymbolicaCore.Expr]) -> PSSSymbolicaCore.Expr:
    it = list(items)
    if not it:
        return ps_num(0.0)
    cur = it[0]
    for t in it[1:]:
        cur = (cur + t).simplify()
    return cur


def ps_num(x: Union[int, float]) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr("num", (PSSSymbolicaCore.Expr._lit(float(x)),))


def ps_sym(name: str) -> PSSSymbolicaCore.Sym:
    return PSSSymbolicaCore.Sym(name)


def ps_sin(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("sin", x)


def ps_cos(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("cos", x)


def ps_tan(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("tan", x)


def ps_exp(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("exp", x)


def ps_log(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("log", x)


def ps_sqrt(x: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.unary("sqrt", x)


def ps_expand(e: Scalar, depth: int = 6) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.atom(e).expand(depth)


def ps_collect(e: Scalar) -> PSSSymbolicaCore.Expr:
    return PSSSymbolicaCore.Expr.atom(e).collect()


def _diff(e: PSSSymbolicaCore.Expr, v: str) -> PSSSymbolicaCore.Expr:
    if e.op == "num":
        return ps_num(0.0)
    if e.op == "sym":
        return ps_num(1.0 if e.args[0].args[0] == v else 0.0)
    if e.op == "neg":
        return -_diff(e.args[0], v)
    if e.op == "+":
        return (_diff(e.args[0], v) + _diff(e.args[1], v)).simplify()
    if e.op == "-":
        return (_diff(e.args[0], v) - _diff(e.args[1], v)).simplify()
    if e.op == "*":
        a, b = e.args
        return (a * _diff(b, v) + b * _diff(a, v)).simplify()
    if e.op == "/":
        a, b = e.args
        n = (b * _diff(a, v) - a * _diff(b, v)).simplify()
        d = (b * b).simplify()
        return (n / d).simplify()
    if e.op == "**":
        a, b = e.args
        if b.op == "num":
            p = b.args[0].args[0]
            return (ps_num(p) * (a ** ps_num(p - 1.0)) * _diff(a, v)).simplify()
        g = ps_exp(ps_log(a) * b)
        return _diff(g.simplify(), v)
    if e.op == "sin":
        x = e.args[0]
        return (ps_cos(x) * _diff(x, v)).simplify()
    if e.op == "cos":
        x = e.args[0]
        return ((-ps_sin(x)) * _diff(x, v)).simplify()
    if e.op == "tan":
        x = e.args[0]
        return ((ps_num(1.0) + ps_tan(x) ** ps_num(2.0)) * _diff(x, v)).simplify()
    if e.op == "exp":
        x = e.args[0]
        return (ps_exp(x) * _diff(x, v)).simplify()
    if e.op == "log":
        x = e.args[0]
        return (_diff(x, v) / x).simplify()
    if e.op == "sqrt":
        x = e.args[0]
        return (_diff(x, v) / (ps_num(2.0) * ps_sqrt(x))).simplify()
    return ps_num(0.0)


def ps_diff(e: Scalar, var: Union[str, PSSSymbolicaCore.Sym]) -> PSSSymbolicaCore.Expr:
    v = var if isinstance(var, str) else var.name
    return _diff(PSSSymbolicaCore.Expr.atom(e).simplify(), v).simplify()


def _integrate_atom(
    e: PSSSymbolicaCore.Expr, v: str
) -> Optional[PSSSymbolicaCore.Expr]:
    if e.op == "num":
        return (
            e * PSSSymbolicaCore.Expr("sym", (PSSSymbolicaCore.Expr._lit(v),))
        ).simplify()
    if e.op == "sym":
        if e.args[0].args[0] == v:
            return (ps_num(0.5) * (e ** ps_num(2.0))).simplify()
        return (
            e * PSSSymbolicaCore.Expr("sym", (PSSSymbolicaCore.Expr._lit(v),))
        ).simplify()
    if e.op == "sin":
        x = e.args[0]
        if x.op == "sym" and x.args[0].args[0] == v:
            return (-ps_cos(x)).simplify()
    if e.op == "cos":
        x = e.args[0]
        if x.op == "sym" and x.args[0].args[0] == v:
            return (ps_sin(x)).simplify()
    if e.op == "exp":
        x = e.args[0]
        if x.op == "sym" and x.args[0].args[0] == v:
            return ps_exp(x)
    if e.op == "log":
        x = e.args[0]
        if x.op == "sym" and x.args[0].args[0] == v:
            return ((x * ps_log(x) - x)).simplify()
    if e.op == "**" and e.args[0].op == "sym" and e.args[1].op == "num":
        if e.args[0].args[0] == v:
            p = e.args[1].args[0].args[0]
            if p != -1.0:
                return ((e.args[0] ** ps_num(p + 1.0)) / ps_num(p + 1.0)).simplify()
            return ps_log(e.args[0])
    return None


def ps_integrate(
    e: Scalar, var: Union[str, PSSSymbolicaCore.Sym]
) -> PSSSymbolicaCore.Expr:
    v = var if isinstance(var, str) else var.name
    ex = PSSSymbolicaCore.Expr.atom(e).simplify()
    if ex.op == "+":
        return (ps_integrate(ex.args[0], v) + ps_integrate(ex.args[1], v)).simplify()
    if ex.op == "*":
        a, b = ex.args
        if a.op == "num":
            return (a * ps_integrate(b, v)).simplify()
        if b.op == "num":
            return (b * ps_integrate(a, v)).simplify()
    res = _integrate_atom(ex, v)
    if res is not None:
        return res.simplify()
    raise ValueError("integral unsupported")


def _taylor(
    e: PSSSymbolicaCore.Expr, v: str, a: float, n: int
) -> PSSSymbolicaCore.Expr:
    x = PSSSymbolicaCore.Expr("sym", (PSSSymbolicaCore.Expr._lit(v),))
    s = ps_num(0.0)
    f = e
    for k in range(n + 1):
        fv = f.subs({v: a}).simplify()
        term = (fv * ((x - ps_num(a)) ** ps_num(float(k)))).simplify()
        if k > 0:
            term = (term / ps_num(math.factorial(k))).simplify()
        s = (s + term).simplify()
        f = ps_diff(f, v).simplify()
    return s.simplify()


def ps_series(
    e: Scalar, var: Union[str, PSSSymbolicaCore.Sym], at: float, order: int
) -> PSSSymbolicaCore.Expr:
    v = var if isinstance(var, str) else var.name
    return _taylor(
        PSSSymbolicaCore.Expr.atom(e).simplify(), v, float(at), int(order)
    ).simplify()


def _poly_coeffs(
    e: PSSSymbolicaCore.Expr, v: str
) -> Optional[List[PSSSymbolicaCore.Expr]]:
    e = ps_collect(e)
    if e.op == "num":
        return [e]
    if e.op == "sym" and e.args[0].args[0] == v:
        return [ps_num(0.0), ps_num(1.0)]
    if e.op == "+":
        c1 = _poly_coeffs(e.args[0], v)
        c2 = _poly_coeffs(e.args[1], v)
        if c1 is None or c2 is None:
            return None
        m = max(len(c1), len(c2))
        r: List[PSSSymbolicaCore.Expr] = [ps_num(0.0)] * m
        for i in range(m):
            a = c1[i] if i < len(c1) else ps_num(0.0)
            b = c2[i] if i < len(c2) else ps_num(0.0)
            r[i] = (a + b).simplify()
        return r
    if e.op == "*":
        c1 = _poly_coeffs(e.args[0], v)
        c2 = _poly_coeffs(e.args[1], v)
        if c1 is None or c2 is None:
            return None
        r: List[PSSSymbolicaCore.Expr] = [ps_num(0.0)] * (len(c1) + len(c2) - 1)
        for i, a in enumerate(c1):
            for j, b in enumerate(c2):
                r[i + j] = (r[i + j] + (a * b).simplify()).simplify()
        return r
    if e.op == "**" and e.args[0].op == "sym" and e.args[0].args[0] == v:
        if e.args[1].op == "num":
            p = int(e.args[1].args[0].args[0])
            if p >= 0:
                r: List[PSSSymbolicaCore.Expr] = [ps_num(0.0)] * (p + 1)
                r[p] = ps_num(1.0)
                return r
    return None


def ps_solve(
    e: Scalar, var: Union[str, PSSSymbolicaCore.Sym]
) -> List[PSSSymbolicaCore.Expr]:
    v = var if isinstance(var, str) else var.name
    ex = PSSSymbolicaCore.Expr.atom(e).simplify()
    cs = _poly_coeffs(ex, v)
    if cs is None:
        raise ValueError("not univariate poly")
    if len(cs) == 2:
        a0, a1 = cs[0], cs[1]
        if not a1.is_num():
            raise ValueError("linear coeff numeric")
        return [(-a0 / a1).simplify()]
    if len(cs) == 3:
        a0, a1, a2 = cs
        return ps_solve_quadratic(a2, a1, a0)
    raise ValueError("degree >2 unsupported")


def ps_solve_quadratic(
    a2: Scalar, a1: Scalar, a0: Scalar
) -> List[PSSSymbolicaCore.Expr]:
    a = PSSSymbolicaCore.Expr.atom(a2).simplify()
    b = PSSSymbolicaCore.Expr.atom(a1).simplify()
    c = PSSSymbolicaCore.Expr.atom(a0).simplify()
    if not (a.is_num() and b.is_num() and c.is_num()):
        raise ValueError("numeric coeffs needed")
    av, bv, cv = a.args[0].args[0], b.args[0].args[0], c.args[0].args[0]
    if av == 0.0:
        if bv == 0.0:
            raise ValueError("degenerate")
        return [ps_num(-cv / bv)]
    D = bv * bv - 4.0 * av * cv
    if D < 0.0:
        return []
    s = math.sqrt(D)
    x1 = (-bv - s) / (2.0 * av)
    x2 = (-bv + s) / (2.0 * av)
    return [ps_num(x1), ps_num(x2)]


def ps_limit(
    e: Scalar, var: Union[str, PSSSymbolicaCore.Sym], at: float, dirn: str = "both"
) -> PSSSymbolicaCore.Expr:
    v = var if isinstance(var, str) else var.name
    ex = PSSSymbolicaCore.Expr.atom(e).simplify()
    try:
        return ex.subs({v: at}).simplify()
    except Exception:
        pass
    s1 = ps_series(ex, v, at, 1).simplify()
    return s1.subs({v: at}).simplify()


def _forward(
    L: List[List[PSSSymbolicaCore.Expr]], b: List[PSSSymbolicaCore.Expr]
) -> List[PSSSymbolicaCore.Expr]:
    n = len(b)
    y = [ps_num(0.0) for _ in range(n)]
    for i in range(n):
        s = ps_num(0.0)
        for k in range(i):
            s = (s + L[i][k] * y[k]).simplify()
        y[i] = (b[i] - s).simplify()
    return y


def _backward(
    U: List[List[PSSSymbolicaCore.Expr]], y: List[PSSSymbolicaCore.Expr]
) -> List[PSSSymbolicaCore.Expr]:
    n = len(y)
    x = [ps_num(0.0) for _ in range(n)]
    for i in range(n - 1, -1, -1):
        s = ps_num(0.0)
        for k in range(i + 1, n):
            s = (s + U[i][k] * x[k]).simplify()
        if U[i][i].op == "num" and U[i][i].args[0].args[0] == 0.0:
            raise ValueError("singular pivot")
        x[i] = ((y[i] - s) / U[i][i]).simplify()
    return x


# --- Metrics Snapshot P ---


@dataclass(frozen=True)
class MetricsSnapshotP:
    p50_ms: float = 0.0
    p95_ms: float = 0.0
    qps: float = 0.0
    mem_mb: float = 0.0
    jit_hit: float = 0.0
    io_hide: float = 0.0
    tier: str = ""


# --- Sonic Buffers ---


class SonicBuffers:
    """Sonic slot buffers."""

    SLOT_SIZE: int = 64 * 1024

    def __init__(self, slots: int = 32) -> None:
        self.slots = max(4, slots)
        self._buf = [bytearray(self.SLOT_SIZE) for _ in range(self.slots)]
        self._free = deque(range(self.slots))
        self._hot = 0

    def alloc(self) -> Tuple[int, memoryview]:
        if not self._free:
            self._evict()
        idx = self._free.popleft()
        self._hot = idx
        return idx, memoryview(self._buf[idx])

    def _evict(self) -> None:
        self._free.append(self._hot)
        self._hot = (self._hot + 1) % self.slots

    def write_hot(self, data: bytes, offset: int = 0) -> memoryview:
        mv = memoryview(self._buf[self._hot])
        mv[offset : offset + len(data)] = data
        return mv[: offset + len(data)]

    def release(self, idx: int) -> None:
        self._free.append(idx)


# --- Delta Gate ---


class DeltaGateA:
    """Delta gate for boundary opt."""

    def __init__(self) -> None:
        self.hits: dict[str, int] = {}
        self.promoted: set[str] = set()

    def observe(self, key: Tuple[str, int, str]) -> bool:
        sk = "_".join(map(str, key))
        c = self.hits.get(sk, 0) + 1
        self.hits[sk] = c
        if c >= 3:
            self.promoted.add(sk)
            return True
        return False

    def is_hot(self, key: Tuple[str, int, str]) -> bool:
        sk = "_".join(map(str, key))
        return sk in self.promoted

    def demote(self, key: Tuple[str, int, str]) -> None:
        sk = "_".join(map(str, key))
        self.promoted.discard(sk)
        self.hits.pop(sk, None)


# --- Jit Like Cache ---


class JitLikeCacheA:
    """JIT-like cache."""

    def __init__(self) -> None:
        self.cache: dict[str, Callable] = {}
        self._crc = self._mk_crc()

    def _mk_crc(self) -> List[int]:
        t = [0] * 256
        for i in range(256):
            c = i
            for _ in range(8):
                c = (c >> 1) ^ 0xEDB88320 if c & 1 else c >> 1
            t[i] = c
        return t

    def crc32(self, b: bytes) -> int:
        c = 0xFFFFFFFF
        for x in b:
            c = self._crc[(c ^ x) & 0xFF] ^ (c >> 8)
        return ~c & 0xFFFFFFFF

    def get_or_build(self, key: str, src_fn: Callable[[], str]) -> Callable:
        if key not in self.cache:
            src = src_fn()
            ns = {}
            exec(compile(src, "<aot>", "exec"), ns)
            self.cache[key] = ns["f"]
        return self.cache[key]


# --- Sonic Meteres ---


class SonicMeteres:
    """Metrics logger."""

    def __init__(self, path: str = "metrics.jsonl") -> None:
        self.path = path
        self._lock = threading.Lock()

    def write(self, s: MetricsSnapshotP) -> None:
        with self._lock:
            with open(self.path, "a", encoding="utf-8") as f:
                json.dump(s.__dict__, f, ensure_ascii=False)
                f.write("\n")


# --- Vector Shard Align ---


class VectorShardAlign:
    """Vector shard and align."""

    def __init__(
        self,
        buf: SonicBuffers,
        gate: DeltaGateA,
        jit: JitLikeCacheA,
        meter: SonicMeteres,
    ) -> None:
        self.buf = buf
        self.gate = gate
        self.jit = jit
        self.meter = meter

    def shard(self, vecs: list[memoryview], n_shard: int) -> list[memoryview]:
        if n_shard < 1:
            raise ValueError("n_shard >=1")
        dim = len(vecs[0])
        self.gate.observe(("shard", dim, "bin"))
        size = (len(vecs) + n_shard - 1) // n_shard
        out: list[memoryview] = []
        for i in range(0, len(vecs), size):
            end = min(i + size, len(vecs))
            payload = b"".join(v.tobytes() for v in vecs[i:end])
            idx, _ = self.buf.alloc()
            mv = self.buf.write_hot(payload)
            out.append(mv)
            self.buf.release(idx)
        snap = MetricsSnapshotP(1.0, 2.0, 500.0, 10.0, 0.9, 0.95, "T2")
        self.meter.write(snap)
        return out

    def align_avg(self, groups: list[list[memoryview]]) -> list[memoryview]:
        if not groups:
            return []
        dim = len(groups[0][0]) // 4
        self.gate.observe(("align", dim, "vec"))
        out: list[memoryview] = []
        for cols in itertools.zip_longest(*groups, fillvalue=None):
            s = 0.0
            cnt = 0
            for v in cols:
                if v is None:
                    continue
                cnt += 1
                for i in range(dim):
                    s += struct.unpack_from("f", v, i * 4)[0]
            avg = s / (dim * cnt) if cnt > 0 else 0.0
            idx, slot = self.buf.alloc()
            for i in range(dim):
                struct.pack_into("f", slot, i * 4, avg)
            out.append(slot[: dim * 4])
            self.buf.release(idx)
        snap = MetricsSnapshotP(2.0, 4.0, 300.0, 12.0, 0.85, 0.9, "T1")
        self.meter.write(snap)
        return out


# --- Batch Agg Process ---


class BatchAggProcess:
    """Batch aggregation."""

    def __init__(
        self,
        buf: SonicBuffers,
        gate: DeltaGateA,
        jit: JitLikeCacheA,
        meter: SonicMeteres,
        max_workers: int = 16,
    ) -> None:
        self.buf = buf
        self.gate = gate
        self.jit = jit
        self.meter = meter
        self.pool = cf.ThreadPoolExecutor(max_workers=max_workers)
        self.sem = asyncio.Semaphore(max_workers)
        self.credits: deque[int] = deque([500] * max_workers)

    def _agg_sum(self, v: memoryview) -> memoryview:
        s = 0.0
        n = len(v) // 4
        for i in range(n):
            s += struct.unpack_from("f", v, i * 4)[0]
        idx, slot = self.buf.alloc()
        struct.pack_into("f", slot, 0, s)
        mv = slot[:4]
        self.buf.release(idx)
        return mv

    async def aggregate(
        self, vecs: Iterable[memoryview], batch: int = 1024
    ) -> AsyncIterator[memoryview]:
        it = iter(vecs)
        loop = asyncio.get_running_loop()
        while True:
            chunk = list(itertools.islice(it, batch))
            if not chunk:
                break
            futs = []
            for v in chunk:
                await self.sem.acquire()
                fut = loop.run_in_executor(self.pool, self._agg_sum, v)
                fut.add_done_callback(lambda _: self.sem.release())
                futs.append(fut)
            for fut in asyncio.as_completed(futs):
                yield await fut
        snap = MetricsSnapshotP(0.8, 1.6, 900.0, 6.0, 0.95, 0.98, "T2")
        self.meter.write(snap)

    async def process(
        self, ops: Iterable[Callable[[memoryview], memoryview]]
    ) -> AsyncIterator[memoryview]:
        loop = asyncio.get_running_loop()
        for op in ops:
            if self.credits[0] <= 0:
                if len(self.credits) > 1:
                    b = self.credits.pop()
                    self.credits.appendleft(b)
                else:
                    raise RuntimeError("credits empty")
            await self.sem.acquire()
            idx, slot = self.buf.alloc()
            fut = loop.run_in_executor(self.pool, op, slot)
            fut.add_done_callback(lambda _: self.sem.release())
            try:
                res = await fut
            finally:
                self.buf.release(idx)
            yield res
            self.credits.rotate(-1)
        snap = MetricsSnapshotP(0.7, 1.5, 700.0, 7.0, 0.93, 0.97, "T3")
        self.meter.write(snap)


# --- Quantization Suite ---


class QuantizationSuiteA:
    """Quantization ops."""

    def __init__(
        self,
        buf: SonicBuffers,
        gate: DeltaGateA,
        jit: JitLikeCacheA,
        meter: SonicMeteres,
    ) -> None:
        self.buf = buf
        self.gate = gate
        self.jit = jit
        self.meter = meter
        self.book8: List[float] = [i / 256 for i in range(256)]
        self.book16: List[float] = [i / 65536 for i in range(65536)]

    def quant8(self, vecs: list[memoryview]) -> list[memoryview]:
        out: list[memoryview] = []
        for v in vecs:
            n = len(v) // 4
            codes = bytearray(n)
            for i in range(n):
                f = struct.unpack_from("f", v, i * 4)[0]
                idx = max(0, min(255, int(abs(f) * 256)))
                codes[i] = idx
            out.append(memoryview(codes))
        snap = MetricsSnapshotP(0.4, 0.9, 2000.0, 2.0, 0.98, 0.99, "T3")
        self.meter.write(snap)
        return out

    def quant16(self, vecs: list[memoryview]) -> list[memoryview]:
        out: list[memoryview] = []
        for v in vecs:
            n = len(v) // 4
            codes = bytearray(n * 2)
            for i in range(n):
                f = struct.unpack_from("f", v, i * 4)[0]
                idx = max(0, min(65535, int(abs(f) * 65536)))
                struct.pack_into("H", codes, i * 2, idx)
            out.append(memoryview(codes))
        snap = MetricsSnapshotP(0.9, 1.8, 1200.0, 3.0, 0.92, 0.95, "T2")
        self.meter.write(snap)
        return out


# --- Retrieval and Prune ---


class RetrievalAndPrune:
    """Retrieval and pruning."""

    def __init__(
        self,
        buf: SonicBuffers,
        gate: DeltaGateA,
        jit: JitLikeCacheA,
        meter: SonicMeteres,
    ) -> None:
        self.buf = buf
        self.gate = gate
        self.jit = jit
        self.meter = meter
        self.pool = cf.ThreadPoolExecutor(max_workers=16)

    def _dist_batch(
        self, q: memoryview, batch: list[memoryview]
    ) -> Tuple[memoryview, float]:
        dim = len(q) // 4
        best = None
        best_d = float("inf")
        for v in batch:
            d = 0.0
            for i in range(dim):
                qi = struct.unpack_from("f", q, i * 4)[0]
                vi = struct.unpack_from("f", v, i * 4)[0]
                d += (qi - vi) ** 2
            if d < best_d:
                best_d = d
                best = v
        return best or q[:4], math.sqrt(best_d)

    def retrieve(
        self, queries: list[memoryview], vec_db: list[memoryview], batch: int = 32
    ) -> List[Tuple[memoryview, float]]:
        out: List[Tuple[memoryview, float]] = []
        for q in queries:
            futs = []
            for i in range(0, len(vec_db), batch):
                futs.append(
                    self.pool.submit(self._dist_batch, q, vec_db[i : i + batch])
                )
            for f in cf.as_completed(futs):
                out.append(f.result())
        snap = MetricsSnapshotP(0.6, 1.1, 1000.0, 5.0, 0.95, 0.98, "T2")
        self.meter.write(snap)
        return out

    def prune_topk(
        self, ctx: memoryview, query: memoryview, k: int = 64, chunk: int = 1024
    ) -> memoryview:
        if k < 1:
            raise ValueError("k >=1")
        dim = len(query) // 4
        scored: List[Tuple[float, memoryview]] = []
        total = len(ctx) // 4
        for i in range(0, total, chunk):
            end = min(i + chunk, total)
            c = ctx[i * 4 : end * 4]
            s = 0.0
            for j in range(min(dim, k)):
                qa = struct.unpack_from("f", query, j * 4)[0]
                ca = struct.unpack_from("f", c, j * 4)[0]
                s += qa * ca
            scored.append((s, c))
        top = sorted(scored, key=lambda x: x[0], reverse=True)[:k]
        payload = b"".join(mv.tobytes() for _, mv in top)
        idx, _ = self.buf.alloc()
        mv = self.buf.write_hot(payload)
        self.buf.release(idx)
        snap = MetricsSnapshotP(1.1, 2.2, 600.0, 9.0, 0.9, 0.95, "T1")
        self.meter.write(snap)
        return mv


# --- Index and Embed ---


class IndexAndEmbedP:
    """Index and embed."""

    def __init__(
        self,
        buf: SonicBuffers,
        gate: DeltaGateA,
        jit: JitLikeCacheA,
        meter: SonicMeteres,
    ) -> None:
        self.buf = buf
        self.gate = gate
        self.jit = jit
        self.meter = meter
        self.pool = cf.ThreadPoolExecutor(max_workers=16)
        self.index: defaultdict[str, List[Tuple[int, memoryview]]] = defaultdict(list)
        self.mem_cap: int = 1000000000
        self.theta: float = 10000.0 ** (-2 / 768)

    def index_batched(self, vecs: Iterable[memoryview], batch: int = 1024) -> None:
        futs = []
        it = iter(vecs)
        while True:
            chunk = list(itertools.islice(it, batch))
            if not chunk:
                break
            if self._mem_usage() > self.mem_cap:
                raise RuntimeError("mem cap")
            futs.append(self.pool.submit(self._build_layer, chunk))
        for f in cf.as_completed(futs):
            self.index["l0"].extend(f.result())
        snap = MetricsSnapshotP(2.0, 4.0, 250.0, 50.0, 0.85, 0.9, "T3")
        self.meter.write(snap)

    def _build_layer(self, batch: list[memoryview]) -> list[Tuple[int, memoryview]]:
        layer = [(hash(b.tobytes()), b) for b in batch]
        layer.sort(key=lambda x: x[0])
        return layer

    def _mem_usage(self) -> int:
        return sum(len(v) for _, v in self.index["l0"])

    def rope_adjust(self, emb: memoryview, pos: int) -> memoryview:
        n = len(emb) // 4
        idx, slot = self.buf.alloc()
        for i in range(n):
            x = struct.unpack_from("f", emb, i * 4)[0]
            ang = pos / (self.theta ** (2 * i / (n * 2)))
            struct.pack_into("f", slot, i * 4, x * math.cos(ang))
        mv = slot[: n * 4]
        self.buf.release(idx)
        snap = MetricsSnapshotP(0.5, 1.2, 800.0, 3.0, 0.92, 0.96, "T2")
        self.meter.write(snap)
        return mv


# --- Run Metrics ---


@dataclass
class RunMetrics:
    p50_ms: float
    p95_ms: float
    qps: float


# --- Match Switch PIC ---


class MatchSwitchPIC:
    _h: Dict[str, Callable[..., Any]]
    _hot: Dict[str, bool]
    _hits: Dict[str, int]
    _last: Optional[str]
    _crc: Dict[str, int]

    def __init__(self, promote_hits: int = 3) -> None:
        self._h = {}
        self._hot = {}
        self._hits = {}
        self._last = None
        self._crc = {}
        self._promote = max(1, promote_hits)

    def register(self, op: str, fn: Callable[..., Any]) -> None:
        self._h[op] = fn
        self._hot.setdefault(op, False)
        self._hits.setdefault(op, 0)
        self._crc[op] = self._crc32(op.encode())

    def unregister(self, op: str) -> None:
        self._h.pop(op, None)
        self._hot.pop(op, None)
        self._hits.pop(op, None)
        self._crc.pop(op, None)

    def dispatch(self, op: str, *a: Any, **k: Any) -> Any:
        hit = op == self._last
        if hit:
            c = self._hits.get(op, 0) + 1
            self._hits[op] = c
            if c >= self._promote:
                self._hot[op] = True
        else:
            self._last = op
            self._hits[op] = 1
        match (op, self._hot.get(op, False)):
            case (op_name, True):
                fn = self._h.get(op_name)
                if fn is None:
                    return self._miss(op, *a, **k)
                return fn(*a, **k)
            case (op_name, False):
                fn = self._h.get(op_name)
                if fn is not None:
                    return fn(*a, **k)
                return self._miss(op, *a, **k)
            case _:
                return self._miss(op, *a, **k)

    def guard_crc(self, op: str) -> bool:
        cur = self._crc32(op.encode())
        ref = self._crc.get(op)
        return (ref is None) or (cur == ref)

    def _miss(self, op: str, *a: Any, **k: Any) -> Any:
        raise KeyError(f"no handler: {op}")

    @staticmethod
    def _crc32(b: bytes) -> int:
        return zlib.crc32(b) & 0xFFFFFFFF


# --- Async Fanout Executor ---


class AsyncFanoutExecutor:
    _sem: asyncio.Semaphore
    _q: asyncio.Queue
    _budget: int
    _win: deque[float]
    _last_tick: float
    _done: bool
    _lat_ms: List[float]

    def __init__(
        self, max_conc: int = 8, q_cap: int = 2048, budget_ms: int = 500
    ) -> None:
        self._sem = asyncio.Semaphore(max(1, max_conc))
        self._q = asyncio.Queue(maxsize=max(1, q_cap))
        self._budget = max(50, budget_ms)
        self._win = deque(maxlen=256)
        self._last_tick = time.perf_counter()
        self._done = False
        self._lat_ms = []

    async def map_gather(
        self,
        items: Iterable[Any],
        fn: Callable[[Any], Awaitable[Any]],
        *,
        timeout_s: Optional[float] = None,
    ) -> List[Any]:
        prod = asyncio.create_task(self._producer(items))
        cons = asyncio.create_task(self._consumer(fn, timeout_s))
        await asyncio.gather(prod)
        self._done = True
        await cons
        return [v for (_, v) in self._drain()]

    def metrics(self) -> RunMetrics:
        if not self._lat_ms:
            return RunMetrics(0.0, 0.0, 0.0)
        lat = sorted(self._lat_ms)
        p50 = lat[len(lat) // 2]
        p95 = lat[int(len(lat) * 0.95)]
        span = max(1e-3, sum(self._win)) / 1000.0
        qps = len(self._lat_ms) / span if span > 0 else 0.0
        return RunMetrics(p50, p95, qps)

    async def _producer(self, items: Iterable[Any]) -> None:
        for it in items:
            await self._wait_budget()
            await self._q.put(("job", it))
        await self._q.put(("eof", None))

    async def _consumer(
        self, fn: Callable[[Any], Awaitable[Any]], timeout_s: Optional[float]
    ) -> None:
        out: deque = deque()
        pend: List[asyncio.Task] = []
        while True:
            kind, val = await asyncio.wait_for(self._q.get(), timeout=timeout_s)
            match kind:
                case "job":
                    t = asyncio.create_task(self._run_one(fn, val))
                    pend.append(t)
                case "eof":
                    break
                case _:
                    continue
            if self._q.qsize() > self._q.maxsize * 0.8:
                await asyncio.sleep(0)
        if pend:
            done, _ = await asyncio.wait(pend)
            for d in done:
                try:
                    out.append(("ok", d.result()))
                except Exception as e:
                    out.append(("err", e))
        self._stash = out

    async def _run_one(self, fn: Callable[[Any], Awaitable[Any]], x: Any) -> Any:
        t0 = time.perf_counter()
        async with self._sem:
            try:
                res = await fn(x)
                return res
            finally:
                dt = (time.perf_counter() - t0) * 1000.0
                self._lat_ms.append(dt)
                self._note_tick(dt)

    async def _wait_budget(self) -> None:
        now = time.perf_counter()
        if (now - self._last_tick) * 1000.0 > self._budget:
            self._win.clear()
            self._last_tick = now
            return
        if len(self._win) >= 64:
            await asyncio.sleep(0)

    def _note_tick(self, dt_ms: float) -> None:
        self._win.append(dt_ms)
        now = time.perf_counter()
        if (now - self._last_tick) * 1000.0 > self._budget:
            self._win.clear()
            self._last_tick = now

    def _drain(self) -> List[Any]:
        out = []
        if hasattr(self, "_stash"):
            while self._stash:
                out.append(self._stash.popleft())
        return out


# --- Fast Iter ---


@dataclass
class FastIterSignature:
    type_name: str
    length: int


class FastIter:
    """Fast iter promotion."""

    def __init__(self, hot_threshold: int = 3) -> None:
        self.last_sig: Optional[FastIterSignature] = None
        self.hot_hits = 0
        self.hot_threshold = max(2, hot_threshold)

    def _sig_of(self, it: Iterable) -> FastIterSignature:
        n = len(it) if hasattr(it, "__len__") else -1
        return FastIterSignature(type(it).__name__, n)

    def maybe_promote(self, it: Iterable) -> Iterable:
        sig = self._sig_of(it)
        if self.last_sig and sig == self.last_sig:
            self.hot_hits += 1
        else:
            self.hot_hits = 0
        self.last_sig = sig
        if self.hot_hits >= self.hot_threshold - 1:
            if isinstance(it, (list, tuple)):
                return memoryview(array("d", it))
            if isinstance(it, array) and it.typecode == "d":
                return memoryview(it)
        return it


# --- For Count Buffer ---


class ForCountBuffer:
    """Count buffer."""

    def __init__(self, capacity_elems: int) -> None:
        self.capacity = int(capacity_elems)
        self.buf = bytearray(self.capacity * 8)
        self.mv = memoryview(self.buf)
        self.offset = 0
        self.count = 0

    def append_double(self, x: float) -> None:
        struct.pack_into("d", self.mv, self.offset, float(x))
        self.offset += 8
        self.count += 1

    def as_array_d(self) -> array:
        used = self.count
        out = array("d")
        out.frombytes(self.buf[: used * 8])
        return out


# --- For Chunk Batcher ---


class ForChunkBatcher:
    """Chunk batcher."""

    def __init__(self, chunk_size: int) -> None:
        self.chunk = max(16, int(chunk_size))

    def batches(self, xs: Sequence) -> Iterable[memoryview]:
        mv = _as_mv_d(xs)
        n = len(mv)
        for i in range(0, n, self.chunk):
            yield mv[i : min(n, i + self.chunk)]


# --- Delta Gate Hot ---


class DeltaGateHot:
    """Hot delta gate."""

    def __init__(self, hit_relax: int = 2, promote_hits: int = 3) -> None:
        self.last_key: Optional[Tuple[str, int]] = None
        self.hits = 0
        self.promote_hits = max(2, promote_hits)
        self.relax_hit = max(1, hit_relax)
        self.is_hot = False

    def _key_of(self, payload) -> Tuple[str, int]:
        t = type(payload).__name__
        n = len(payload) if hasattr(payload, "__len__") else 1
        b = 10 ** max(2, int(math.log10(max(2, n))))
        return (t, b)

    def observe(self, payload) -> None:
        key = self._key_of(payload)
        if self.last_key and key == self.last_key:
            self.hits += 1
        else:
            self.hits = 0
        self.last_key = key
        if self.hits >= self.promote_hits - 1:
            self.is_hot = True

    def relaxed_bin(self, base: int) -> int:
        if self.is_hot:
            return int(base * 1.25)
        return base

    def cool_down(self) -> None:
        self.is_hot = False
        self.hits = 0

    def prewarm(self) -> None:
        if not self.is_hot:
            self.hits = max(self.hits, self.relax_hit)


# --- Ring IO Buffer ---


class RingIOBuffer:
    """Ring IO buffer."""

    def __init__(self, slots: int = 32, slot_bytes: int = 64 * 1024) -> None:
        self.slots = max(4, slots)
        self.slot_bytes = max(8192, slot_bytes)
        self.buf = [bytearray(self.slot_bytes) for _ in range(self.slots)]
        self.head = 0
        self.len = [0] * self.slots
        self.hot = [False] * self.slots

    def alloc(self) -> Tuple[memoryview, int]:
        mv = memoryview(self.buf[self.head])
        self.len[self.head] = 0
        self.hot[self.head] = True
        idx = self.head
        self.head = (self.head + 1) % self.slots
        return mv, idx

    def fill(self, idx: int, used: int) -> None:
        used = max(0, min(used, self.slot_bytes))
        self.len[idx] = used
        self.hot[idx] = True

    def dump(self) -> List[bytes]:
        views: List[bytes] = []
        for i in range(self.slots):
            if self.hot[i] and self.len[i] > 0:
                views.append(bytes(self.buf[i][: self.len[i]]))
            self.len[i] = 0
            self.hot[i] = False
        return views


# --- Sonic Meter Lite ---


class SonicMeterLite:
    """Lite meter."""

    def __init__(self, jsonl_path: Optional[str] = None) -> None:
        self.path = jsonl_path
        self.enabled = bool(jsonl_path)

    def emit(self, **fields) -> None:
        if not self.enabled:
            return
        try:
            with open(self.path, "a", encoding="utf-8") as f:
                rec = {"ts_ms": _now_ms(), **fields}
                f.write(json.dumps(rec, ensure_ascii=False) + "\n")
        except Exception:
            pass


# --- SLA Switch Controller ---


class SLASwitchController:
    """SLA switch."""

    def __init__(self, policy: AdaptivePolicy, mem_probe: Callable) -> None:
        self.policy = policy
        self.mem_probe = mem_probe

    def before(self, op: str) -> str:
        return self.policy.precision_mode

    def after(self, op: str, p50_ms: float) -> None:
        mem_bytes = int(self.mem_probe().get("total_bytes", 0))
        self.policy.autoswitch(mem_bytes, p50_ms)


# --- AOT Store ---


class AOTStore:
    """AOT store."""

    def __init__(self, db_path: str = "aot_cache.sqlite3") -> None:
        self.path = pathlib.Path(db_path)
        self.conn = sqlite3.connect(self.path)
        self._init()

    def _init(self) -> None:
        cur = self.conn.cursor()
        cur.execute(
            "CREATE TABLE IF NOT EXISTS units (name TEXT PRIMARY KEY, src TEXT)"
        )
        self.conn.commit()

    def store(self, name: str, src: str) -> None:
        cur = self.conn.cursor()
        cur.execute("REPLACE INTO units(name, src) VALUES(?,?)", (name, src))
        self.conn.commit()

    def load_all(self) -> List[Tuple[str, str]]:
        cur = self.conn.cursor()
        cur.execute("SELECT name, src FROM units")
        return list(cur.fetchall())

    def close(self) -> None:
        try:
            self.conn.close()
        except Exception:
            pass


def aot_load_into_cache(aot_store: AOTStore, aot_cache: AOTCodeCache, g: dict) -> None:
    for name, src in aot_store.load_all():
        aot_cache.add(CodeUnit(name=name, src=src, globals=g))


def aot_capture_jit(name: str, src: str, aot_store: Optional[AOTStore]) -> None:
    if aot_store:
        aot_store.store(name, src)


# --- Standard Lib Combo ---


def iter_batched(xs: Sequence, k: int) -> Iterable[List[Any]]:
    it = iter(xs)
    while True:
        batch = list(itertools.islice(it, k))
        if not batch:
            return
        yield batch


def mmap_file_readonly(path: str) -> memoryview:
    f = open(path, "rb")
    mm = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
    return memoryview(mm)


def setup_async_logging(
    logger_name: str = "rechar", level: int = logging.INFO
) -> Tuple[logging.Logger, QueueListener]:
    log_q: queue.Queue = queue.Queue()
    handler = logging.StreamHandler()
    listener = QueueListener(log_q, handler)
    listener.start()
    logger = logging.getLogger(logger_name)
    logger.setLevel(level)
    logger.addHandler(QueueHandler(log_q))
    return logger, listener


# --- Policy Caps ---


@dataclass
class PolicyCaps:
    max_vec_len: int = 10000000
    max_mat_elems: int = 200000000
    max_fft_len: int = 1 << 20
    max_seconds: float = 30.0
    max_bytes: int = 512 * 1024 * 1024

    def check_vec(self, n: int) -> None:
        if n > self.max_vec_len:
            raise SecurityCriticalError(f"vec too large: {n}")

    def check_mat(self, n: int, m: int) -> None:
        if n * m > self.max_mat_elems:
            raise SecurityCriticalError(f"mat too large: {n*m}")

    def check_fft(self, n: int) -> None:
        if n > self.max_fft_len:
            raise SecurityCriticalError(f"fft too large: {n}")

    def check_time(self, start_ns: int) -> None:
        if (time.perf_counter_ns() - start_ns) / 1e9 > self.max_seconds:
            raise SecurityCriticalError("time exceeded")


# --- SLA Contract ---


@dataclass
class SLAContract:
    name: str
    p50_ms: float
    p95_ms: float
    max_rel_err: float
    prefer_gc_off: bool
    prefer_cache_store: bool
    sum_mode: str
    dot_unroll: int


# --- SLA Slider ---


class SLASlider:
    """SLA slider."""

    def __init__(self) -> None:
        self._m = {
            "fast": SLAContract("fast", 8, 16, 1e-6, True, True, "fast", 16),
            "balanced": SLAContract(
                "balanced", 12, 24, 1e-9, True, True, "balanced", 16
            ),
            "precise": SLAContract(
                "precise", 16, 32, 1e-12, False, False, "precise", 8
            ),
        }
        self.cur = "balanced"

    def set(self, mode: str) -> None:
        if mode in self._m:
            self.cur = mode

    def get(self) -> SLAContract:
        return self._m[self.cur]

    def advise(self, ema_p50: float, ema_p95: float, mem_bytes: int) -> str:
        if mem_bytes > 256 * 1024 * 1024 or ema_p95 > self._m["balanced"].p95_ms * 1.2:
            self.cur = "fast"
        elif (
            ema_p50 < self._m["balanced"].p50_ms * 0.8 and mem_bytes < 64 * 1024 * 1024
        ):
            self.cur = "precise"
        else:
            self.cur = "balanced"
        return self.cur


# --- Precision Config ---


@dataclass
class PrecisionConfig:
    reproducible_sum: bool = False
    sum_mode: str = "auto"
    use_fma: bool = hasattr(math, "fma")
    pairwise: bool = False
    kahan_on_fast: bool = True

    def pick_sum(self, mode: str) -> str:
        if self.sum_mode != "auto":
            return self.sum_mode
        if mode == "fast":
            return "kahan" if self.kahan_on_fast else "plain"
        if mode == "precise":
            return "fsum"
        return "neumaier"


# --- Variant ---


@dataclass
class Variant:
    name: str
    block: int
    unroll: int
    guard: str
    notes: str = ""


# --- Auto Variant Registry ---


class AutoVariantRegistry:
    """Variant registry."""

    def __init__(self) -> None:
        self._v: List[Variant] = []
        for k in range(2, 11):
            b = 10**k
            self._v.append(
                Variant(f"v10e{k}", b, 8 if k <= 4 else (16 if k <= 7 else 32), "size")
            )

    def choose(self, n: int) -> Variant:
        n = max(1, n)
        return min(
            self._v,
            key=lambda v: abs(v.block - n)
            if n <= v.block
            else (v.block - (n % v.block or v.block)),
        )

    def register(self, var: Variant) -> None:
        self._v.append(var)


# --- AOI Plan ---


@dataclass
class AOIPlan:
    kind: str
    prealloc: int
    chunk: int
    unroll: int
    notes: str = ""


# --- AOI Planner ---


class AOIPlanner:
    """AOI planner."""

    def __init__(self, variants: AutoVariantRegistry) -> None:
        self.vars = variants

    def plan_for_each(self, n: int) -> AOIPlan:
        var = self.vars.choose(n)
        return AOIPlan("for-each", 0, var.block, var.unroll, "iter")

    def plan_for_count(self, n: int, elem_bytes: int = 8) -> AOIPlan:
        var = self.vars.choose(n)
        return AOIPlan(
            "for-count", var.block * elem_bytes, var.block, var.unroll, "prealloc"
        )

    def plan_for_chunk(self, n: int) -> AOIPlan:
        var = self.vars.choose(n)
        c = int(max(16, math.sqrt(var.block)))
        return AOIPlan("for-chunk", 0, c, var.unroll, "even")

    def choose(self, op: str, n: int) -> AOIPlan:
        if op in ("sum", "argsort"):
            return self.plan_for_each(n)
        if op in ("matmul", "conv"):
            return self.plan_for_chunk(n)
        return self.plan_for_count(n)


# --- Phase State ---


@dataclass
class PhaseState:
    phase: str = "liquid"
    guards: Dict[str, Any] = field(default_factory=dict)
    last_switch_ms: float = 0.0


# --- Transphase Manager ---


class TransphaseManager:
    """Transphase manager."""

    def __init__(self) -> None:
        self.state = PhaseState()

    def _now(self) -> float:
        return time.perf_counter_ns() / 1e6

    def to_liquid(self, reason: str) -> None:
        self.state = PhaseState("liquid", {"reason": reason}, self._now())

    def to_vapor(self, guards: Dict[str, Any]) -> None:
        self.state = PhaseState("vapor", guards, self._now())

    def to_solid(self, assumptions: Dict[str, Any]) -> None:
        self.state = PhaseState("solid", assumptions, self._now())

    def guard_ok(self, assumptions: Dict[str, Any]) -> bool:
        if self.state.phase != "solid":
            return True
        for k, v in self.state.guards.items():
            if assumptions.get(k) != v:
                return False
        return True

    def advise(self, hit_ratio: float, ema_p50: float, target: float) -> str:
        if hit_ratio > 0.92 and ema_p50 < target * 0.9:
            self.to_solid({"jit_hit": ">0.92"})
        elif hit_ratio < 0.6 or ema_p50 > target * 1.3:
            self.to_liquid("miss/high-lat")
        else:
            self.to_vapor({"jit_hit": hit_ratio})
        return self.state.phase


# --- Isobar Plan ---


@dataclass
class IsobarPlan:
    slots: int
    slot_bytes: int
    dump_threshold: int
    tier: int


# --- Byte Isobar Planner ---


class ByteIsobarPlanner:
    """Byte isobar planner."""

    def __init__(self) -> None:
        self.base = 64 * 1024

    def plan(self, bin_hint: int, tier: int, hot_hits: int) -> IsobarPlan:
        slot = max(self.base, int(self.base * (1 + 0.25 * (tier - 1))))
        if hot_hits >= 3:
            slot = int(slot * 1.5)
        slots = 32 if tier <= 1 else (24 if tier == 2 else 16)
        return IsobarPlan(slots, slot, slot // 2, tier)


# --- CRC Node ---


@dataclass
class CRCNode:
    key: Tuple[Any, ...]
    crc: int
    bytes_est: int
    last_ms: float


# --- CRC Graph ---


class CRCGraph:
    """CRC graph."""

    def __init__(self) -> None:
        self.map: Dict[Tuple[Any, ...], CRCNode] = {}

    def _crc32(self, *parts: bytes) -> int:
        c = 0
        for p in parts:
            c = zlib.crc32(p, c)
        return c & 0xFFFFFFFF

    def touch(self, key: Tuple[Any, ...], bytes_est: int) -> int:
        crc = self._crc32(str(key).encode(), str(bytes_est).encode())
        self.map[key] = CRCNode(key, crc, bytes_est, time.perf_counter_ns() / 1e6)
        return crc

    def reusable(self, key: Tuple[Any, ...], bytes_est: int) -> bool:
        crc = self._crc32(str(key).encode(), str(bytes_est).encode())
        n = self.map.get(key)
        return bool(n and n.crc == crc)


# --- Story Driven ReLiquefier ---


class StoryDrivenReLiquefier:
    """Re-liquefier."""

    def __init__(self, writer: Callable[[str, Dict[str, Any]], None]) -> None:
        self.writer = writer
        self.count = 0

    def on_anomaly(self, kind: str, ctx: Dict[str, Any]) -> None:
        self.count += 1
        self.writer(f"anomaly#{self.count}:{kind}", ctx)

    def should_reliquefy(self, p95_ms: float, target_ms: float, miss: float) -> bool:
        return (p95_ms > target_ms * 1.8) or (miss > 0.5)


# --- Budget Snapshot ---


@dataclass
class BudgetSnapshot:
    start_ns: int
    rss_bytes: Optional[int]
    bytes_soft: int
    seconds_soft: float


# --- Budget Guard ---


class BudgetGuard:
    """Budget guard."""

    def __init__(self, caps: PolicyCaps) -> None:
        self.caps = caps

    def start(self) -> BudgetSnapshot:
        rss = self._rss_bytes()
        return BudgetSnapshot(
            time.perf_counter_ns(),
            rss,
            int(self.caps.max_bytes * 0.75),
            self.caps.max_seconds * 0.8,
        )

    def check(self, snap: BudgetSnapshot) -> None:
        if snap.rss_bytes is not None:
            now = self._rss_bytes()
            if now and now > snap.bytes_soft:
                raise SecurityCriticalError("mem exceeded")
        if (time.perf_counter_ns() - snap.start_ns) / 1e9 > snap.seconds_soft:
            raise SecurityCriticalError("time exceeded")

    def _rss_bytes(self) -> Optional[int]:
        try:
            r = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return int(r if sys.platform == "darwin" else r * 1024)
        except Exception:
            return None


# --- Code Unit ---


@dataclass
class CodeUnit:
    name: str
    src: str
    globals: Dict[str, Any]
    fn: Callable[..., Any] | None = None


# --- AOT Code Cache ---


class AOTCodeCache:
    """AOT cache."""

    def __init__(self) -> None:
        self._units: Dict[str, CodeUnit] = {}
        self._lock = threading.Lock()

    def add(self, u: CodeUnit) -> None:
        with self._lock:
            self._units[u.name] = u

    def compile(self, name: str) -> Callable[..., Any]:
        with self._lock:
            u = self._units.get(name)
            if not u:
                raise DiagnosticError(f"no unit: {name}")
            if u.fn is None:
                ns = dict(u.globals)
                exec(u.src, ns)
                u.fn = ns.get("f")
                if not callable(u.fn):
                    raise DiagnosticError("no entry 'f'")
            return u.fn

    def has(self, name: str) -> bool:
        return name in self._units


# --- Unified Plan ---


@dataclass
class UnifiedPlan:
    mode: str
    variant: Variant
    aoi: AOIPlan
    phase: str
    isobar: IsobarPlan


# --- Planner Facade ---


class PlannerFacade:
    """Planner facade."""

    def __init__(self) -> None:
        self.caps = PolicyCaps()
        self.sla = SLASlider()
        self.prec = PrecisionConfig()
        self.variants = AutoVariantRegistry()
        self.aoi = AOIPlanner(self.variants)
        self.phase = TransphaseManager()
        self.isobar = ByteIsobarPlanner()
        self.budget = BudgetGuard(self.caps)
        self.crc = CRCGraph()
        self.reliq = StoryDrivenReLiquefier(lambda msg, ctx: None)
        self.aot = AOTCodeCache()

    def advise(
        self,
        op: str,
        n: int,
        ema_p50: float,
        ema_p95: float,
        mem_bytes: int,
        hot_hits: int,
    ) -> UnifiedPlan:
        mode = self.sla.advise(ema_p50, ema_p95, mem_bytes)
        var = self.variants.choose(max(1, n))
        aoi = self.aoi.choose(op, n)
        phase = self.phase.advise(
            hit_ratio=min(0.99, max(0.0, hot_hits / max(1, hot_hits + 1))),
            ema_p50=ema_p50,
            target=self.sla.get().p50_ms,
        )
        tier = 1 if mode == "fast" else (2 if mode == "balanced" else 3)
        iso = self.isobar.plan(bin_hint=var.block, tier=tier, hot_hits=hot_hits)
        return UnifiedPlan(mode, var, aoi, phase, iso)


# --- Planner Adapter ---


class PlannerAdapter:
    """Planner adapter."""

    def __init__(self, planner: PlannerFacade) -> None:
        self.planner = planner
        self.hot_hits: Dict[str, int] = {}
        self.last_ema: Dict[str, Tuple[float, float]] = {}

    def record(self, op: str, p50: float, p95: float) -> None:
        self.last_ema[op] = (p50, p95)

    def advise(self, op: str, n: int, mem_bytes: int) -> UnifiedPlan:
        p50, p95 = self.last_ema.get(op, (0.0, 0.0))
        hits = self.hot_hits.get(op, 0)
        return self.planner.advise(op, n, p50, p95, mem_bytes, hits)

    def hit(self, op: str, ok: bool = True) -> None:
        self.hot_hits[op] = self.hot_hits.get(op, 0) + (1 if ok else -1)


# --- Utility ---


def _now_ms() -> float:
    return time.perf_counter_ns() / 1e6


def _now_us() -> float:
    return time.perf_counter_ns() / 1e3


def _is_pow2(n: int) -> bool:
    return n > 0 and (n & (n - 1)) == 0


def _next_pow2(n: int) -> int:
    if n <= 1:
        return 1
    p = 1
    while p < n:
        p <<= 1
    return p


def _sizeof_top(o: Any) -> int:
    try:
        return sys.getsizeof(o)
    except Exception:
        return 0


def _as_mv_d(xs: Sequence[Any]) -> memoryview:
    if isinstance(xs, memoryview):
        return xs.cast("d") if xs.format != "d" else xs
    if isinstance(xs, array) and xs.typecode == "d":
        return memoryview(xs)
    return memoryview(array("d", xs))


def _to_complex_list(xs: Sequence[Any]) -> List[complex]:
    return [complex(v) for v in xs]


def _crc32_of(*parts: bytes) -> int:
    c = 0
    for p in parts:
        c = zlib.crc32(p, c)
    return c & 0xFFFFFFFF


# --- Audit Log ---


@dataclass
class RingEvent:
    ts_ms: float
    event: str
    payload: Dict[str, Any]


class AuditLog:
    """Audit log."""

    def __init__(self, cap: int = 256, file_path: Optional[str] = None) -> None:
        self.cap = max(16, cap)
        self.buf: List[Optional[RingEvent]] = [None] * self.cap
        self.head = 0
        self.count = 0
        self.file_path = file_path

    def log(self, event: str, **payload: Any) -> None:
        e = RingEvent(_now_ms(), event, payload)
        self.buf[self.head] = e
        self.head = (self.head + 1) % self.cap
        self.count = min(self.count + 1, self.cap)
        if self.file_path:
            try:
                with open(self.file_path, "a", encoding="utf-8") as f:
                    rec = {"ts_ms": e.ts_ms, "event": event, **payload}
                    f.write(json.dumps(rec, ensure_ascii=False) + "\n")
            except Exception:
                pass

    def tail(self, k: int = 20) -> List[Dict[str, Any]]:
        k = min(k, self.count)
        out: List[Dict[str, Any]] = []
        for i in range(k):
            idx = (self.head - 1 - i) % self.cap
            ev = self.buf[idx]
            if ev:
                out.append({"ts_ms": ev.ts_ms, "event": ev.event, **ev.payload})
        return list(reversed(out))


# --- Sonic Meter ---


class SonicMeter:
    """Sonic meter."""

    def __init__(self, jsonl_path: Optional[str] = None) -> None:
        self.path = jsonl_path
        self.last: Dict[str, Any] = {}
        self.enabled = bool(jsonl_path)

    def write(self, **fields: Any) -> None:
        if not self.enabled:
            self.last = fields
            return
        try:
            with open(self.path, "a", encoding="utf-8") as f:
                rec = {"ts_ms": _now_ms(), **fields}
                f.write(json.dumps(rec, ensure_ascii=False) + "\n")
        except Exception:
            pass
        self.last = fields


# --- Memory Pool ---


@dataclass
class PoolEntry:
    key: str
    kind: str
    buf: Any
    size: int
    hits: int
    gen: int
    last_ms: float
    bucket: str


class MemoryPool:
    """Memory pool."""

    SMALL_EDGE = 262144

    def __init__(
        self, max_total_elems: int = 4000000, audit: Optional[AuditLog] = None
    ) -> None:
        self.max_total = max_total_elems
        self.entries: Dict[str, PoolEntry] = {}
        self.total_elems = 0
        self.gen = 0
        self.audit = audit
        self.alloc_count = 0
        self.reuse_count = 0
        self.free_count = 0
        self.bytes_alloc = 0
        self.bytes_freed = 0

    def _bucket_of(self, size: int) -> str:
        return "small" if size <= self.SMALL_EDGE else "large"

    def _ensure_capacity(self) -> None:
        if self.total_elems <= self.max_total:
            return

        def score(e: PoolEntry) -> Tuple[int, int, float]:
            bucket_bias = 0 if e.bucket == "large" else 1
            return (e.hits + bucket_bias, e.gen, e.last_ms)

        cand = sorted(self.entries.values(), key=score)
        target = int(self.max_total * 0.8)
        for e in cand:
            self.total_elems -= e.size
            self.entries.pop(e.key, None)
            b = _sizeof_top(e.buf)
            self.free_count += 1
            self.bytes_freed += b
            if self.total_elems <= target:
                break
        if self.audit:
            self.audit.log("pool_evict", total=self.total_elems)

    def alloc(self, key: str, size: int, kind: str = "float") -> Any:
        self.gen += 1
        ent = self.entries.get(key)
        if ent and ent.kind == kind and ent.size >= size:
            ent.hits += 1
            ent.gen = self.gen
            ent.last_ms = _now_ms()
            self.reuse_count += 1
            return ent.buf
        buf = [0.0] * size if kind == "float" else [0j] * size
        bucket = self._bucket_of(size)
        self.entries[key] = PoolEntry(
            key, kind, buf, size, 1, self.gen, _now_ms(), bucket
        )
        self.total_elems += size
        self.alloc_count += 1
        self.bytes_alloc += _sizeof_top(buf)
        self._ensure_capacity()
        return buf

    def free_key(self, key: str) -> None:
        ent = self.entries.pop(key, None)
        if ent:
            self.total_elems -= ent.size
            self.free_count += 1
            self.bytes_freed += _sizeof_top(ent.buf)

    def stats(self) -> Dict[str, Any]:
        cur_bytes = sum(_sizeof_top(e.buf) for e in self.entries.values())
        eff = self.reuse_count / max(1, self.alloc_count + self.reuse_count)
        return {
            "total_elems": self.total_elems,
            "max_total_elems": self.max_total,
            "alloc_count": self.alloc_count,
            "reuse_count": self.reuse_count,
            "free_count": self.free_count,
            "efficiency": eff,
            "bytes_alloc": self.bytes_alloc,
            "bytes_freed": self.bytes_freed,
            "bytes_current": cur_bytes,
        }


# --- Ring Cache ---


class RingCache:
    """Ring cache."""

    def __init__(self, cap: int = 64, audit: Optional[AuditLog] = None) -> None:
        self.cap = max(16, cap)
        self.buf: List[Optional[Tuple[Tuple[Any, ...], Any, int]]] = [None] * self.cap
        self.head = 0
        self.count = 0
        self.hits = 0
        self.miss = 0
        self.audit = audit
        self.bytes_current = 0

    def get(self, key: Tuple[Any, ...]) -> Any:
        for i in range(self.count):
            idx = (self.head - 1 - i) % self.cap
            slot = self.buf[idx]
            if slot and slot[0] == key:
                self.hits += 1
                return slot[1]
        self.miss += 1
        return None

    def put(self, key: Tuple[Any, ...], val: Any, allow_store: bool = True) -> None:
        if not allow_store:
            return
        sz = _sizeof_top(val)
        old = self.buf[self.head]
        if old is not None:
            self.bytes_current -= old[2]
        self.buf[self.head] = (key, val, sz)
        self.bytes_current += sz
        self.head = (self.head + 1) % self.cap
        self.count = min(self.count + 1, self.cap)

    def metrics(self) -> Dict[str, Any]:
        return {
            "hits": self.hits,
            "miss": self.miss,
            "cap": self.cap,
            "live": self.count,
            "bytes_current": self.bytes_current,
        }

    def autotune(self) -> None:
        total = self.hits + self.miss
        if total < 64:
            return
        hitrate = self.hits / total
        if hitrate > 0.9 and self.cap < 1024:
            self.cap = int(self.cap * 1.25)
        elif hitrate < 0.3 and self.cap > 32:
            self.cap = max(32, int(self.cap * 0.8))


# --- Block System ---


class BlockSystem:
    """Block system."""

    def __init__(self, p50_target_ms: float = 10.0) -> None:
        self.p50_target = max(0.1, float(p50_target_ms))
        self.max_block = 10**10
        self.last_block = 10**3

    def pick(self, n: int, ema_p50_ms: Optional[float]) -> int:
        if n <= 0:
            return 100
        base = 10 ** max(2, int(math.log10(max(2, n))))
        if ema_p50_ms is None:
            self.last_block = base
            return base
        ratio = self.p50_target / max(1e-6, ema_p50_ms)
        k = math.log10(base) + math.log10(max(0.25, min(4.0, ratio))) * 0.5
        k = max(2.0, min(10.0, k))
        blk = int(10**k)
        blk = max(100, min(self.max_block, blk))
        self.last_block = blk
        return blk


# --- JIT ---


_HAS_FMA = hasattr(math, "fma")


class JIT:
    """JIT ops."""

    @staticmethod
    @lru_cache(maxsize=128)
    def sum_unroll(unroll: int):
        u = max(1, int(unroll))
        lines = ["def f(xs, n):", "    s = 0.0", "    i = 0"]
        lines += [
            f"    while i + {u} <= n:",
            "        s += " + " + ".join([f"xs[i+{k}]" for k in range(u)]),
            f"        i += {u}",
            "    while i < n:",
            "        s += xs[i]; i += 1",
            "    return s",
        ]
        ns = {}
        exec("\n".join(lines), ns)
        return ns["f"]

    @staticmethod
    @lru_cache(maxsize=128)
    def dot_unroll(unroll: int):
        u = max(1, int(unroll))
        lines = ["def f(a, a0, b, b0, n):", "    s = 0.0", "    i = 0"]
        if _HAS_FMA:
            lines += [
                f"    while i + {u} <= n:",
                *[
                    f"        s = math.fma(a[a0+i+{k}], b[b0+i+{k}], s)"
                    for k in range(u)
                ],
                f"        i += {u}",
            ]
        else:
            lines += [
                f"    while i + {u} <= n:",
                "        s += "
                + " + ".join([f"a[a0+i+{k}]*b[b0+i+{k}]" for k in range(u)]),
                f"        i += {u}",
            ]
        lines += [
            "    while i < n:",
            "        s += a[a0+i]*b[b0+i]; i += 1",
            "    return s",
        ]
        ns = {"math": math}
        exec("\n".join(lines), ns)
        return ns["f"]


# --- Rate Plan ---


@dataclass
class RatePlan:
    block: int
    unroll: int
    gc_off: bool
    store_result: bool
    store_bt: bool


# --- Adaptive Policy ---


class AdaptivePolicy:
    """Adaptive policy."""

    def __init__(
        self,
        blocks: BlockSystem,
        audit: Optional[AuditLog] = None,
        mode: str = "balanced",
    ) -> None:
        self.blocks = blocks
        self.audit = audit
        self.ema_p50: Dict[str, float] = {}
        self.ema_p95: Dict[str, float] = {}
        self.alpha_fast = 0.30
        self.alpha_slow = 0.10
        self.eps = 0.05
        self.mode = mode
        self.auto_enabled = True
        self.acc_highwater_ms = blocks.p50_target * 0.80
        self.fast_highwater_ms = blocks.p50_target * 1.40
        self.mem_soft_bytes = 32 * 1024 * 1024
        self.mem_hard_bytes = 96 * 1024 * 1024
        self.prec = PrecisionConfig()
        self.prec.pick_sum(mode)

    def _ema(self, prev: Optional[float], val: float, a: float) -> float:
        return val if prev is None else a * val + (1 - a) * prev

    def feed(self, op: str, p50_ms: float, p95_ms: float) -> None:
        self.ema_p50[op] = self._ema(self.ema_p50.get(op), p50_ms, self.alpha_fast)
        self.ema_p95[op] = self._ema(self.ema_p95.get(op), p95_ms, self.alpha_slow)

    def plan(self, op: str, n: int) -> RatePlan:
        ema_p50 = self.ema_p50.get(op)
        blk = self.blocks.pick(n, ema_p50)
        density = max(1.0, n / max(1, blk))
        base_unroll = 8 if density < 8 else (16 if density < 32 else 32)
        if random.random() < self.eps:
            base_unroll = random.choice([8, 12, 16, 24, 32])
        if ema_p50 and ema_p50 > self.blocks.p50_target * 1.2:
            base_unroll = max(8, int(base_unroll * 0.75))
        ema_p95 = self.ema_p95.get(op)
        gc_off = not (ema_p95 and ema_p95 > self.blocks.p50_target * 2.0)
        store_res = op != "matmul"
        store_bt = op == "matmul"
        return RatePlan(blk, base_unroll, gc_off, store_res, store_bt)

    @property
    def precision_mode(self) -> str:
        return self.mode

    def set_mode(self, mode: str) -> None:
        self.mode = mode

    def autoswitch(self, mem_bytes: int, last_p50: float) -> None:
        if not self.auto_enabled:
            return
        prev = self.mode
        if mem_bytes < self.mem_soft_bytes and last_p50 <= self.acc_highwater_ms:
            self.mode = "precise"
        if (mem_bytes > self.mem_hard_bytes) or (last_p50 >= self.fast_highwater_ms):
            self.mode = "fast"
        if prev == "fast" and self.mode == "precise":
            self.mode = "balanced"
        if self.audit and self.mode != prev:
            self.audit.log(
                "precision_autoswitch",
                prev=prev,
                cur=self.mode,
                mem_bytes=mem_bytes,
                last_p50=last_p50,
            )


# --- Numeric Kernels ---


def _kahan_sum(xs: Sequence[float]) -> float:
    s, c = 0.0, 0.0
    for x in xs:
        y = x - c
        t = s + y
        c = (t - s) - y
        s = t
    return s


def _neumaier_sum(xs: Sequence[float]) -> float:
    s = 0.0
    c = 0.0
    for x in xs:
        t = s + x
        if abs(s) >= abs(x):
            c += (s - t) + x
        else:
            c += (x - t) + s
        s = t
    return s + c


# --- Core Sum Sort ---


class CoreSumSort:
    """Sum and sort core."""

    def __init__(
        self, cache: RingCache, policy: AdaptivePolicy, audit: Optional[AuditLog] = None
    ) -> None:
        self.cache = cache
        self.policy = policy
        self.audit = audit
        self.last_flops = 0
        self.last_bytes = 0
        self.vec = PSSVectorSeqCh(policy.prec)

    def sum_stream(self, it: Iterable[float], block: Optional[int] = None) -> float:
        rp = self.policy.plan("sum", 1)
        blk = block or rp.block
        mode = self.policy.precision_mode
        reducer = _kahan_sum if mode == "fast" else _neumaier_sum
        if mode == "precise":
            reducer = math.fsum
        xs_chunk: List[float] = []
        total = 0.0
        seen = 0
        for x in it:
            xs_chunk.append(float(x))
            seen += 1
            if len(xs_chunk) >= blk:
                total += reducer(xs_chunk)
                xs_chunk.clear()
        if xs_chunk:
            total += reducer(xs_chunk)
        self.last_flops = max(1, seen)
        self.last_bytes = 8 * max(1, seen)
        return total

    def sum_block(self, xs: Sequence, block: Optional[int] = None) -> float:
        xs_mv = _as_mv_d(xs)
        n = len(xs_mv)
        rp = self.policy.plan("sum", n)
        blk = block or rp.block
        key = (
            "sum",
            id(xs_mv.obj if hasattr(xs_mv, "obj") else xs),
            n,
            blk,
            rp.unroll,
            self.policy.precision_mode,
        )
        hit = self.cache.get(key)
        if hit is not None:
            return float(hit)
        mode = self.policy.precision_mode
        was = gc.isenabled()
        if rp.gc_off and was:
            gc.disable()
        t0 = _now_ms()
        try:
            if mode == "precise":
                total = 0.0
                i = 0
                while i < n:
                    j = min(n, i + blk)
                    total += math.fsum(xs_mv[i:j])
                    i = j
            elif mode == "balanced":
                total = 0.0
                i = 0
                while i < n:
                    j = min(n, i + blk)
                    total += _neumaier_sum(xs_mv[i:j])
                    i = j
            else:
                un = max(8, int(rp.unroll))
                sum_u = JIT.sum_unroll(un)
                total = 0.0
                c = 0.0
                i = 0
                while i < n:
                    j = min(n, i + blk)
                    s_block = sum_u(xs_mv, i, j - i)
                    y = s_block - c
                    t = total + y
                    c = (t - total) - y
                    total = t
                    i = j
        finally:
            if rp.gc_off and was:
                gc.enable()
        p50 = max(0.0, _now_ms() - t0)
        self.policy.feed("sum", p50, p50 * 1.05)
        self.cache.put(key, total, allow_store=rp.store_result)
        self.cache.autotune()
        if self.audit:
            self.audit.log("sum_done", n=n, blk=blk, mode=mode, p50=p50)
        self.last_flops = n
        self.last_bytes = 8 * n
        return total

    def argsort_block(self, xs: Sequence, block: Optional[int] = None) -> List[int]:
        xs_mv = _as_mv_d(xs)
        n = len(xs_mv)
        rp = self.policy.plan("argsort", n)
        blk = block or rp.block
        key = ("argsort", id(xs_mv.obj if hasattr(xs_mv, "obj") else xs), n, blk)
        hit = self.cache.get(key)
        if hit is not None:
            return list(hit)
        t0 = _now_ms()
        if n <= 64:
            pairs = [(xs_mv[i], i) for i in range(n)]
            pairs.sort()
            idx = [i for _, i in pairs]
        else:
            idx = list(range(n))
            idx.sort(key=xs_mv.__getitem__)
        p50 = max(0.0, _now_ms() - t0)
        self.policy.feed("argsort", p50, p50 * 1.05)
        self.cache.put(key, idx, allow_store=rp.store_result)
        self.cache.autotune()
        if self.audit:
            self.audit.log("argsort_done", n=n, blk=blk, p50=p50)
        self.last_flops = int(max(1, n * math.log2(max(2, n))))
        self.last_bytes = 8 * n
        return idx


# --- Core Matmul ---


class CoreMatmul:
    """Matmul core with adaptive block and cache-aware refinement."""

    def __init__(
        self,
        pool: MemoryPool,
        cache: RingCache,
        policy: AdaptivePolicy,
        audit: Optional[AuditLog] = None,
    ) -> None:
        self.pool = pool
        self.cache = cache
        self.policy = policy
        self.audit = audit
        self.last_flops = 0
        self.last_bytes = 0

    @staticmethod
    def _as_mv_d2D(xs: Sequence, rows: int, cols: int) -> memoryview:
        mv = _as_mv_d(xs)
        if len(mv) < rows * cols:
            raise ValueError("size mismatch")
        return mv

    def matmul_block(
        self, a: Sequence, b: Sequence, n: int, block: Optional[int] = None
    ) -> List[float]:
        return self.matmul_general(a, b, n, n, n, block)

    def matmul_general(
        self,
        a: Sequence,
        b: Sequence,
        n: int,
        m: int,
        k: int,
        block: Optional[int] = None,
    ) -> List[float]:
        rp = self.policy.plan("matmul", max(n, m, k))
        blk = block or rp.block
        a_mv = self._as_mv_d2D(a, n, m)
        b_mv = self._as_mv_d2D(b, m, k)

        key = (
            "matmul_g",
            id(a_mv.obj if hasattr(a_mv, "obj") else a),
            id(b_mv.obj if hasattr(b_mv, "obj") else b),
            n,
            m,
            k,
            blk,
            rp.unroll,
            self.policy.precision_mode,
        )
        hit = self.cache.get(key)
        if hit is not None:
            return list(hit)

        # --- Transposed B (bt) ---
        key_bt = ("bt_g", id(b_mv.obj if hasattr(b_mv, "obj") else b), m, k)
        bt = self.cache.get(key_bt)
        if bt is None:
            bt = self.pool.alloc(f"bt_{id(b)}", m * k, "float")
            for j in range(k):
                col = j * m
                src = b_mv[j::k]
                bt[col : col + m] = src
            self.cache.put(key_bt, bt, allow_store=rp.store_bt)

        # --- Allocate result ---
        res = self.pool.alloc(f"mm_{id(a)}_{id(b)}_{n}_{m}_{k}", n * k, "float")
        dot = JIT.dot_unroll(max(8, int(rp.unroll)))

        was_gc = gc.isenabled()
        if rp.gc_off and was_gc:
            gc.disable()

        t0 = _now_ms()
        try:
            # --- Adaptive block size (cache aware) ---
            Bn = max(1, int(max(16, math.isqrt(blk))))
            _a, _bt, _res = a_mv, bt, res
            _m, _k, _n = m, k, n
            _dot = dot

            for ii in range(0, _n, Bn):
                i_end = min(ii + Bn, _n)
                for jj in range(0, _k, Bn):
                    j_end = min(jj + Bn, _k)
                    for i in range(ii, i_end):
                        ai = i * _m
                        ri = i * _k
                        # --- inner kernel unrolled ---
                        for j in range(jj, j_end):
                            bj = j * _m
                            _res[ri + j] = _dot(_a, ai, _bt, bj, _m)

        finally:
            if rp.gc_off and was_gc:
                gc.enable()

        p50 = max(0.0, _now_ms() - t0)
        self.policy.feed("matmul", p50, p50 * 1.05)
        self.cache.put(key, res[:], allow_store=rp.store_result)
        self.cache.autotune()

        if self.audit:
            self.audit.log("matmul_done", n=n, m=m, k=k, blk=blk, un=rp.unroll, p50=p50)

        self.last_flops = 2 * n * m * k
        self.last_bytes = 8 * (n * m + m * k + n * k)
        return res


# --- Core FFT ---


class CoreFFT:
    """FFT core."""

    def __init__(
        self,
        pool: MemoryPool,
        cache: RingCache,
        policy: AdaptivePolicy,
        audit: Optional[AuditLog] = None,
    ) -> None:
        self.pool = pool
        self.cache = cache
        self.policy = policy
        self.audit = audit
        self.last_flops = 0
        self.last_bytes = 0

    @staticmethod
    def _bitrev_inplace(x: List[complex]) -> None:
        n = len(x)
        j = 0
        for i in range(1, n):
            bit = n >> 1
            while j & bit:
                j ^= bit
                bit >>= 1
            j ^= bit
            if i < j:
                x[i], x[j] = x[j], x[i]

    def _fft_radix2(self, xs: Sequence[complex]) -> List[complex]:
        n = len(xs)
        if n == 0:
            return []
        x = [complex(v) for v in xs]
        self._bitrev_inplace(x)
        length = 2
        while length <= n:
            W = [exp(-2j * pi * k / length) for k in range(length // 2)]
            half = length // 2
            for i in range(0, n, length):
                for k in range(half):
                    u = x[i + k]
                    v = W[k] * x[i + k + half]
                    x[i + k] = u + v
                    x[i + k + half] = u - v
            length <<= 1
        return x

    def _ifft_radix2(self, xs: Sequence[complex]) -> List[complex]:
        n = len(xs)
        if n == 0:
            return []
        conj = [complex(z).conjugate() for z in xs]
        y = self._fft_radix2(conj)
        return [z.conjugate() / n for z in y]

    def _fft_bluestein(self, xs: Sequence[complex]) -> List[complex]:
        n = len(xs)
        if n == 0:
            return []
        a = [0j] * n
        w = [0j] * n
        for m in range(n):
            ang = pi * (m * m) / n
            w[m] = cmath.exp(-1j * ang)
            a[m] = xs[m] * w[m]
        M = _next_pow2(2 * n - 1)
        A = [0j] * M
        B = [0j] * M
        for m in range(n):
            A[m] = a[m]
            B[m] = w[m].conjugate()
        for m in range(1, n):
            B[M - m] = w[m].conjugate()
        FA = self._fft_radix2(A)
        FB = self._fft_radix2(B)
        Y = [FA[i] * FB[i] for i in range(M)]
        c = self._ifft_radix2(Y)
        return [c[m] * w[m] for m in range(n)]

    def _fft_any(self, xs: Sequence[complex]) -> Tuple[List[complex], str]:
        n = len(xs)
        if _is_pow2(n):
            if n == 2:
                a, b = complex(xs[0]), complex(xs[1])
                return [a + b, a - b], "radix2"
            if n == 4:
                x0, x1, x2, x3 = (
                    complex(xs[0]),
                    complex(xs[1]),
                    complex(xs[2]),
                    complex(xs[3]),
                )
                a = x0 + x2
                b = x0 - x2
                c = x1 + x3
                d = (x1 - x3) * -1j
                return [a + c, b + d, a - c, b - d], "radix2"
            return self._fft_radix2(xs), "radix2"
        return self._fft_bluestein(xs), "bluestein"

    def fft_iter(self, xs: Sequence, block: Optional[int] = None) -> List[complex]:
        n = len(xs)
        if n == 0:
            return []
        rp = self.policy.plan("fft", n)
        key = ("fft_any", id(xs), n, rp.block, rp.unroll)
        hit = self.cache.get(key)
        if hit is not None:
            return list(hit)
        was = gc.isenabled()
        if rp.gc_off and was:
            gc.disable()
        t0 = _now_ms()
        try:
            out, algo = self._fft_any(_to_complex_list(xs))
        finally:
            if rp.gc_off and was:
                gc.enable()
        p50 = max(0.0, _now_ms() - t0)
        self.policy.feed("fft", p50, p50 * 1.05)
        self.cache.put(key, out, allow_store=(n <= (1 << 16)))
        self.cache.autotune()
        if self.audit:
            self.audit.log("fft_done", n=n, p50=p50, algo=algo)
        L = max(1, int(math.log2(_next_pow2(max(1, n)))))
        self.last_flops = int(n * L)
        self.last_bytes = 16 * n
        return out

    def ifft_iter(self, X: Sequence, block: Optional[int] = None) -> List[complex]:
        n = len(X)
        if n == 0:
            return []
        rp = self.policy.plan("ifft", n)
        key = ("ifft_any", id(X), n, rp.block, rp.unroll)
        hit = self.cache.get(key)
        if hit is not None:
            return list(hit)
        was = gc.isenabled()
        if rp.gc_off and was:
            gc.disable()
        try:
            if _is_pow2(n):
                out = self._ifft_radix2(_to_complex_list(X))
                algo = "radix2"
            else:
                conj = [complex(z).conjugate() for z in X]
                y = self._fft_bluestein(conj)
                out = [z.conjugate() / n for z in y]
                algo = "bluestein"
        finally:
            if rp.gc_off and was:
                gc.enable()
        self.cache.put(key, out, allow_store=(n <= (1 << 16)))
        if self.audit:
            self.audit.log("ifft_done", n=n, algo=algo)
        L = max(1, int(math.log2(_next_pow2(max(1, n)))))
        self.last_flops = int(n * L)
        self.last_bytes = 16 * n
        return out

    def fft_stream(self, chunks: Iterable[Sequence[float | complex]]) -> List[complex]:
        buf: List[complex] = []
        for c in chunks:
            buf.extend(_to_complex_list(c))
        return self.fft_iter(buf)


# --- Core Signal ---


class CoreSignal:
    """Signal ops."""

    def __init__(
        self,
        fftcore: CoreFFT,
        pool: MemoryPool,
        cache: RingCache,
        audit: Optional[AuditLog] = None,
        max_fft_len: int = 8192,
        target_block: int = 4096,
        small_direct_mul: int = 200000,
    ) -> None:
        self.fftcore = fftcore
        self.pool = pool
        self.cache = cache
        self.audit = audit
        self.max_fft_len = max_fft_len
        self.target_block = target_block
        self.small_direct_mul = small_direct_mul
        self.last_flops = 0
        self.last_bytes = 0

    @staticmethod
    def _valid_len(na: int, nb: int) -> int:
        return na + nb - 1

    def _pick_fft_block(self, nb: int) -> Tuple[int, int]:
        L = max(256, min(self.target_block, self.max_fft_len - (nb - 1)))
        M = _next_pow2(L + nb - 1)
        if M > self.max_fft_len:
            M = self.max_fft_len
            L = max(256, M - (nb - 1))
        return M, L

    def _conv_direct(
        self, a: Sequence[complex], b: Sequence[complex], conj_b: bool = False
    ) -> List[complex]:
        na, nb = len(a), len(b)
        out = [0j] * (na + nb - 1)
        if conj_b:
            b = [complex(x).conjugate() for x in b]
        for i in range(na):
            ai = complex(a[i])
            for j in range(nb):
                out[i + j] += ai * complex(b[j])
        return out

    def _conv_ols(
        self,
        a: Sequence[float | complex],
        b: Sequence[float | complex],
        conj_b: bool = False,
    ) -> List[complex]:
        na, nb = len(a), len(b)
        n_valid = self._valid_len(na, nb)
        if na * nb <= self.small_direct_mul:
            y = self._conv_direct(_to_complex_list(a), _to_complex_list(b), conj_b)
            self.last_flops = na * nb * 2
            self.last_bytes = 16 * (na + nb + n_valid)
            return y
        M, L = self._pick_fft_block(nb)
        bx = _to_complex_list(b) + [0j] * (M - nb)
        B = self.fftcore.fft_iter(bx)
        if conj_b:
            B = [z.conjugate() for z in B]
        out: List[complex] = []
        prev_tail = [0j] * (nb - 1)
        a_mv = _to_complex_list(a)
        i = 0
        blocks = 0
        while i < na:
            chunk = a_mv[i : i + L]
            if len(chunk) < L:
                chunk += [0j] * (L - len(chunk))
            x = prev_tail + chunk
            if len(x) < M:
                x += [0j] * (M - len(x))
            X = self.fftcore.fft_iter(x)
            Y = [X[k] * B[k] for k in range(M)]
            y = self.fftcore.ifft_iter(Y)
            out.extend(y[nb - 1 : nb - 1 + L])
            prev_tail = x[L:]
            if len(prev_tail) < (nb - 1):
                prev_tail += [0j] * ((nb - 1) - len(prev_tail))
            else:
                prev_tail = prev_tail[-(nb - 1) :]
            i += L
            blocks += 1
        self.last_flops = blocks * (3 * M * int(math.log2(_next_pow2(M))))
        self.last_bytes = 16 * (na + nb + n_valid)
        return out[:n_valid]

    def conv(
        self, a: Sequence[float | complex], b: Sequence[float | complex]
    ) -> List[complex]:
        return self._conv_ols(a, b, conj_b=False)

    def xcorr(
        self, a: Sequence[float | complex], b: Sequence[float | complex]
    ) -> List[complex]:
        return self._conv_ols(a, b, conj_b=True)


# — Types —


class LoopPlan(Enum):
    """Route kind."""

    EACH = "each"
    COUNT = "count"
    CHUNK = "chunk"


@dataclass(frozen=True)
class LoopTicket:
    """Loop ticket.

    Summary
    -------
    Carry plan, timestamp, and meta.

    Args
    ----
    plan : LoopPlan
        Selected plan.
    ts_ms : float
        Milliseconds since start (monotonic).
    meta : Dict[str, Any]
        Free-form metadata.

    Returns
    -------
    LoopTicket
        Immutable ticket.

    Raises
    ------
    None
    """

    plan: LoopPlan
    ts_ms: float
    meta: Dict[str, Any]


# — Small guards —


def _now_ms() -> float:
    """Monotonic milliseconds."""
    return time.perf_counter() * 1_000.0


def _safe_eval(expr: str, env: Dict[str, Any]) -> Any:
    """Why: eval only for JIT/AOT path."""
    if "import" in expr or "__" in expr:
        raise SecurityCriticalError("banned token")
    return eval(expr, {"__builtins__": {}}, env)


# — Core bridge —


class CoreLoopAdapter:
    """Route to core.loop shortest path with header/tailer.

    Summary
    -------
    Wrap CoreAllAdaptive and invoke fastest loop route with
    LoopHeader/LoopTailer hooks.

    Args
    ----
    core : Any
        CoreAllAdaptive instance.
    header : Optional[Any]
        LoopHeader-like (issue_ticket()).
    tailer : Optional[Any]
        LoopTailer-like (complete()).

    Returns
    -------
    CoreLoopAdapter
        Adapter instance.

    Raises
    ------
    VisibleError
        On invalid arguments.
    """

    def __init__(
        self,
        core: Any,
        header: Optional[Any] = None,
        tailer: Optional[Any] = None,
    ) -> None:
        self.core = core
        self.header = header
        self.tailer = tailer
        self._tick = 0

    # — Attachments —

    def set_header(self, h: Any) -> None:
        """Set header."""
        self.header = h

    def set_tailer(self, t: Any) -> None:
        """Set tailer."""
        self.tailer = t

    # — Warmup passthrough —

    def warmup(self) -> None:
        """Proxy warmup to core subsystems."""
        try:
            self.core.prec.warmup()
        except Exception:
            pass
        try:
            self.core.buffer.sonic_prewarm()
        except Exception:
            pass

    # — Ticket helpers —

    def _issue(self, plan: LoopPlan, meta: Dict[str, Any]) -> Optional[LoopTicket]:
        ts = _now_ms()
        if self.header is None:
            return None
        try:
            t = self.header.issue_ticket(plan.value, dict(meta), ts)
            if isinstance(t, LoopTicket):
                return t
            return LoopTicket(plan=plan, ts_ms=ts, meta=dict(meta))
        except Exception:
            return LoopTicket(plan=plan, ts_ms=ts, meta=dict(meta))

    def _complete(self, tk: Optional[LoopTicket], stats: Dict[str, Any]) -> None:
        if self.tailer is None:
            return
        try:
            self.tailer.complete(tk, stats)  # type: ignore[arg-type]
        except Exception:
            pass

    # — Plan selection —

    def plan_auto(self, size: int, kind: str) -> LoopPlan:
        """Pick route with core hint/fallback.

        Args
        ----
        size : int
            Logical size.
        kind : str
            Workload kind hint.

        Returns
        -------
        LoopPlan
            Selected route.
        """
        try:
            r = self.core.loop.plan_auto(size, kind)
        except Exception:
            r = "each" if kind == "map" else "count"
        match r:
            case "each":
                return LoopPlan.EACH
            case "count":
                return LoopPlan.COUNT
            case "chunk":
                return LoopPlan.CHUNK
            case _:
                return LoopPlan.EACH

    # — Public unified entrypoints —

    def run_each(self, seq: Iterable[Any], expr: str) -> List[Any]:
        """Run for-each with hooks.

        Args
        ----
        seq : Iterable[Any]
            Input sequence.
        expr : str
            Expression over x.

        Returns
        -------
        List[Any]
            Outputs.

        Raises
        ------
        VisibleError
            On bad input.
        """
        if seq is None or not isinstance(expr, str):
            raise VisibleError("need seq,expr")
        plan = LoopPlan.EACH
        tk = self._issue(plan, {"expr": expr})
        t0 = _now_ms()
        try:
            out = self.core.loop.run_each(seq, expr)
        except Exception:
            out = []
            env: Dict[str, Any] = {}
            for x in seq:
                env["x"] = x
                out.append(_safe_eval(expr, env))
        p50 = _now_ms() - t0
        self._after("each", p50)
        self._complete(tk, {"p50": p50, "n": len(out)})
        return out

    def run_count(self, n: int, expr: str, fmt: str = "f") -> memoryview:
        """Run for-count with hooks.

        Args
        ----
        n : int
            Count.
        expr : str
            Expression over i.
        fmt : str
            struct format.

        Returns
        -------
        memoryview
            Packed buffer.
        """
        if n < 0 or not isinstance(expr, str):
            raise VisibleError("need n>=0,expr")
        plan = LoopPlan.COUNT
        tk = self._issue(plan, {"expr": expr, "fmt": fmt, "n": n})
        t0 = _now_ms()
        try:
            mv = self.core.loop.run_count(n, expr, fmt)
        except Exception:
            size = struct.calcsize(fmt)
            buf = bytearray(n * size)
            mv = memoryview(buf)
            off = 0
            env: Dict[str, Any] = {}
            for i in range(n):
                env["i"] = i
                v = float(_safe_eval(expr, env))
                struct.pack_into(fmt, mv, off, v)
                off += size
        p50 = _now_ms() - t0
        self._after("count", p50)
        self._complete(tk, {"p50": p50, "n": n})
        return mv

    def run_chunk(
        self,
        mv: memoryview,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable[[memoryview, int], None]] = None,
    ) -> memoryview:
        """Run chunk with hooks.

        Args
        ----
        mv : memoryview
            Buffer view.
        parts : int
            Split count.
        flush_ms : int
            Spin-wait slice flush.
        update : Optional[Callable[[memoryview, int], None]]
            Slice callback.

        Returns
        -------
        memoryview
            Same buffer view.
        """
        if mv is None or parts <= 0:
            raise VisibleError("need mv,parts>0")
        plan = LoopPlan.CHUNK
        tk = self._issue(plan, {"parts": parts, "flush": flush_ms})
        t0 = _now_ms()
        try:
            out = self.core.loop.run_chunk(mv, parts, flush_ms, update)
        except Exception:
            out = self._fallback_chunk(mv, parts, flush_ms, update)
        p50 = _now_ms() - t0
        self._after("chunk", p50)
        self._complete(tk, {"p50": p50, "bytes": len(mv)})
        return out

    def run_auto(
        self,
        size: int,
        kind: str,
        *,
        seq: Optional[Iterable[Any]] = None,
        expr: Optional[str] = None,
        fmt: str = "f",
        mv: Optional[memoryview] = None,
    ) -> Any:
        """Auto-dispatch with hooks.

        Args
        ----
        size : int
            Logical size.
        kind : str
            Workload kind.
        seq : Optional[Iterable[Any]]
            For EACH.
        expr : Optional[str]
            Expression.
        fmt : str
            struct format.
        mv : Optional[memoryview]
            For CHUNK.

        Returns
        -------
        Any
            Route output.
        """
        plan = self.plan_auto(size, kind)
        if plan is LoopPlan.EACH:
            if seq is None or expr is None:
                raise VisibleError("need seq,expr")
            return self.run_each(seq, expr)
        if plan is LoopPlan.COUNT:
            if expr is None:
                raise VisibleError("need expr")
            return self.run_count(size, expr, fmt)
        if mv is None:
            raise VisibleError("need mv")
        return self.run_chunk(mv)

    # — Internals —

    def _fallback_chunk(
        self,
        mv: memoryview,
        parts: int,
        flush_ms: int,
        update: Optional[Callable[[memoryview, int], None]],
    ) -> memoryview:
        step = max(1, len(mv) // parts)
        for i in range(0, len(mv), step):
            ch = mv[i : i + step]
            if update:
                update(ch, i)
            t0 = _now_ms()
            while _now_ms() - t0 < float(flush_ms):
                pass
        return mv

    def _after(self, tag: str, p50_ms: float) -> None:
        """Feed policy and rare heavy ops."""
        self._tick = (self._tick + 1) & 0xFFFF
        try:
            feed = self.core.policy.feed
        except Exception:
            feed = None
        if feed and (self._tick & 0x3F) == 0:
            ema = getattr(self, "_ema_" + tag, p50_ms)
            ema = ema + 0.1 * (p50_ms - ema)
            setattr(self, "_ema_" + tag, ema)
            feed(tag, float(ema), float(ema * 1.05))
        try:
            if (self._tick & 0x7F) == 0:
                self.core.cache.autotune()
        except Exception:
            pass

    # — Convenience shortcuts —

    def sum_kahan(self, xs: Iterable[float]) -> float:
        """Precision sum via core.prec."""
        try:
            return self.core.prec.kahan_sum(xs)
        except Exception:
            s = 0.0
            c = 0.0
            for x in xs:
                y = x - c
                t = s + y
                c = (t - s) - y
                s = t
            return s

    def dot(self, x: List[float], y: List[float]) -> float:
        """Dot via core.blas."""
        try:
            return self.core.blas.dot(x, y)
        except Exception:
            if len(x) != len(y):
                raise VisibleError("len mismatch")
            s = 0.0
            c = 0.0
            for a, b in zip(x, y):
                z = a * b
                yv = z - c
                t = s + yv
                c = (t - s) - yv
                s = t
            return s

    def argsort(self, x: List[float]) -> List[int]:
        """Argsort via loop fast path."""
        idx = list(range(len(x)))
        idx.sort(key=x.__getitem__)
        return idx


# — Header/tailer shims —


class LoopHeaderShim:

    def issue_ticket(self, plan: str, meta: Dict[str, Any], ts_ms: float) -> LoopTicket:
        return LoopTicket(plan=LoopPlan(plan), ts_ms=ts_ms, meta=meta)


class LoopTailerShim:

    def complete(self, ticket: Optional[LoopTicket], stats: Dict[str, Any]) -> None:
        _ = (ticket, stats)  # standard criterion


import math, random, time, json, uuid, sys
from collections import deque, defaultdict, namedtuple
from itertools import chain, islice, accumulate
from typing import Any, Dict, List, Tuple, Callable

R = range


def now_ms():
    return int(time.time() * 1000)


def clamp(x, a, b):
    return a if x < a else b if x > b else x


def flatten(lst):
    out = []
    append = out.append
    for x in lst:
        if isinstance(x, list):
            out.extend(x)
        else:
            append(x)
    return out


def chunks(seq, k):
    for i in R(0, len(seq), k):
        yield seq[i : i + k]


def mvavg(seq, w):
    if w <= 1 or not seq:
        return seq[:]
    s = sum(seq[:w])
    out = [s / w]
    for i in R(w, len(seq)):
        s += seq[i] - seq[i - w]
        out.append(s / w)
    return out


def argmin(seq):
    return min(R(len(seq)), key=seq.__getitem__)


def argmax(seq):
    return max(R(len(seq)), key=seq.__getitem__)


class RNG:
    def __init__(self, seed=42):
        self.s = seed

    def u(self, a=0.0, b=1.0):
        self.s = (1103515245 * self.s + 12345) & 0x7FFFFFFF
        return a + (b - a) * (self.s / 0x7FFFFFFF)

    def i(self, a, b):
        return int(self.u(a, b + 1))

    def coin(self, p=0.5):
        return self.u() < p


rng = RNG(9474)

Mat = namedtuple("Mat", "name props field micro")


def mat_make(name, props=None, field=None, micro=None):
    return Mat(
        name=name,
        props=dict(props or {}),
        field=dict(field or {}),
        micro=list(micro or []),
    )


def mat_copy(m: Mat) -> Mat:
    return Mat(m.name, dict(m.props), dict(m.field), list(m.micro))


def series(n, fn):
    return [fn(i) for i in R(n)]


def lerp(a, b, t):
    return a + (b - a) * t


def color_shift(rgb, deg):
    r, g, b = rgb
    s = (math.sin(deg) + 1) / 2
    return (
        int(r * (1 - s) + g * s),
        int(g * (1 - s) + b * s),
        int(b * (1 - s) + r * s),
    )


class Signal:
    def __init__(self, vals: List[float]):
        self.v = list(vals)

    def map(self, f):
        return Signal([f(x) for x in self.v])

    def zipmap(self, other, f):
        n = min(len(self.v), len(other.v))
        return Signal([f(self.v[i], other.v[i]) for i in R(n)])

    def pad(self, n, val=0.0, side="both"):
        if side == "both":
            self.v = [val] * n + self.v + [val] * n
        elif side == "left":
            self.v = [val] * n + self.v
        else:
            self.v = self.v + [val] * n
            return self

    def diff(self):
        if len(self.v) < 2:
            return Signal([])
        return Signal([self.v[i + 1] - self.v[i] for i in R(len(self.v) - 1)])

    def integrate(self):
        return Signal(list(accumulate(self.v)))

    def norm(self, p=2):
        return (sum(abs(x) ** p for x in self.v)) ** (1 / p) if self.v else 0.0

    def smooth(self, w):
        return Signal(mvavg(self.v, w))

    def window(self, k, step=None):
        step = step or k
        return [self.v[i : i + k] for i in R(0, max(0, len(self.v) - k + 1), step)]

    def __len__(self):
        return len(self.v)

    def __repr__(self):
        return f"Signal({len(self.v)})"


class Flow:
    def __init__(self, data: Dict[str, Any] = None):
        self.d = dict(data or {})

    def set(self, k, v):
        self.d[k] = v
        return self

    def get(self, k, default=None):
        return self.d.get(k, default)

    def clone(self):
        return Flow(json.loads(json.dumps(self.d)))

    def keys(self):
        return list(self.d.keys())

    def __repr__(self):
        return f"Flow<{len(self.d)}>"

    def pop(self, k, default=None):
        return self.d.pop(k, default)


class Space:
    def __init__(self, dim=(1,)):
        self.dim = tuple(dim)
        self.grid = self._build(self.dim, 0.0)

    def _build(self, dim, val):
        if len(dim) == 1:
            return [val for _ in R(dim[0])]
        return [self._build(dim[1:], val) for _ in R(dim[0])]

    def at(self, idx):
        g = self.grid
        for i in idx:
            g = g[i]
        return g

    def set(self, idx, val):
        g = self.grid
        for i in idx[:-1]:
            g = g[i]
        g[idx[-1]] = val

    def apply_all(self, f):
        def rec(g):
            if isinstance(g, list) and g and isinstance(g[0], list):
                return [rec(x) for x in g]
            return [f(x) for x in g]

        self.grid = rec(self.grid)
        return self

    def fold(self, f, init=0.0):
        def rec(g, acc):
            if isinstance(g, list) and g and isinstance(g[0], list):
                for x in g:
                    acc = rec(x, acc)
                    return acc
            else:
                for x in g:
                    acc = f(acc, x)
                    return acc

        return rec(self.grid, init)

    def shape(self):
        return self.dim


class Journal:
    def __init__(self, maxn=16384):
        self.buf = deque(maxlen=maxn)

    def log(self, kind, payload):
        self.buf.append({"t": now_ms(), "k": kind, "p": payload})

    def dump(self):
        return list(self.buf)

    def to_jsonl(self, fp):
        with open(fp, "a", encoding="utf-8") as f:
            for e in self.buf:
                f.write(json.dumps(e, ensure_ascii=False) + "\n")


class Engine:
    def __init__(self):
        self.id = str(uuid.uuid4())[:8]
        self.J = Journal()
        self.rules = {}
        self._install()

    def reg(self, name: str, fn: Callable[[Flow], Flow]):
        self.rules[name] = fn

    def run(self, flow: Flow, plan: List[str]) -> Flow:
        f = flow
        for name in plan:
            fn = self.rules.get(name)
            if not fn:
                continue
            t0 = now_ms()
            nf = fn(f)
            self.J.log("step", {"rule": name, "dt": now_ms() - t0})
            f = nf
        return f

    def _install(self):
        self.reg("Segmentation", lambda f: self._split(f))
        self.reg("Extraction", lambda f: self._extract(f))
        self.reg("LocalQuality", lambda f: self._local_quality(f))
        self.reg("Asymmetry", lambda f: self._asym(f))
        self.reg("Integration", lambda f: self._integrate(f))
        self.reg("Universality", lambda f: self._generalize(f))
        self.reg("Nesting", lambda f: self._nest(f))
        self.reg("Balance", lambda f: self._balance(f))
        self.reg("PreCounterAction", lambda f: self._pre_counter(f))
        self.reg("PreAction", lambda f: self._pre_action(f))
        self.reg("EqualField", lambda f: self._equal_field(f))
        self.reg("Inversion", lambda f: self._invert(f))
        self.reg("Curvature", lambda f: self._curvature(f))
        self.reg("Dynamics", lambda f: self._dynamic(f))
        self.reg("PartialExcess", lambda f: self._partial_excess(f))
        self.reg("DimensionShift", lambda f: self._other_dim(f))
        self.reg("Vibration", lambda f: self._vibrate(f))
        self.reg("Periodicity", lambda f: self._period(f))
        self.reg("Continuity", lambda f: self._useful_continuity(f))
        self.reg("Skipping", lambda f: self._skip(f))
        self.reg("BlessingInDisguise", lambda f: self._harm2good(f))
        self.reg("Feedback", lambda f: self._feedback(f))
        self.reg("Mediation", lambda f: self._mediate(f))
        self.reg("SelfService", lambda f: self._self_service(f))
        self.reg("Substitution", lambda f: self._substitute(f))
        self.reg("CheapShortLife", lambda f: self._cheap_transient(f))
        self.reg("MechanicsSubstitution", lambda f: self._replace_mech(f))
        self.reg("Fluid", lambda f: self._fluid(f))
        self.reg("ThinFilm", lambda f: self._thinfilm(f))
        self.reg("Porous", lambda f: self._porous(f))
        self.reg("ColorChange", lambda f: self._color(f))
        self.reg("Homogenization", lambda f: self._homogenize(f))
        self.reg("DiscardRegen", lambda f: self._discard_regen(f))
        self.reg("ParamChange", lambda f: self._param(f))
        self.reg("PhaseTransition", lambda f: self._phase(f))
        self.reg("ThermalExpansion", lambda f: self._thermal(f))
        self.reg("OxygenAcceleration", lambda f: self._oxygen(f))
        self.reg("InertProtection", lambda f: self._inert(f))
        self.reg("Composite", lambda f: self._composite(f))

    def _ensure_sig(self, f: Flow, key="sig") -> Flow:
        if not isinstance(f.get(key), Signal):
            n = 256
            f.set(key, Signal([rng.u(-1, 1) for _ in R(n)]))
        return f

    def _split(self, f):
        self._ensure_sig(f)
        s = f.get("sig").v
        k = max(2, int(len(s) ** 0.5))
        parts = list(chunks(s, k))
        f.set("parts", parts)
        return f

    def _extract(self, f):
        p = f.get("parts") or [f.get("sig").v]
        feat = [
            (sum(x) / max(1, len(x)), max(x) if x else 0.0, min(x) if x else 0.0)
            for x in p
        ]
        f.set("feat", feat)
        return f

    def _local_quality(self, f):
        p = f.get("parts") or [f.get("sig").v]
        q = [mvavg(x, max(2, len(x) // 8 or 2)) for x in p]
        f.set("parts", q)
        return f

    def _asym(self, f):
        p = f.get("parts") or [f.get("sig").v]
        out = []
        for i, seg in enumerate(p):
            w = [x * (1 + 0.01 * i) for x in seg]
            out.append(w)
        f.set("parts", out)
        return f

    def _integrate(self, f):
        p = f.get("parts") or [f.get("sig").v]
        f.set("sig", Signal(flatten([list(accumulate(seg)) for seg in p])))
        return f

    def _generalize(self, f):
        s = f.get("sig", Signal([])).v
        if not s:
            return f
        m = sum(abs(x) for x in s) / len(s)
        f.set("scale", m or 1.0)
        return f

    def _nest(self, f):
        s = f.get("sig", Signal([])).v
        f.set("nest", [s[::2], s[1::2]])
        return f

    def _balance(self, f):
        s = f.get("sig", Signal([])).v
        if not s:
            return f
        m = sum(s) / len(s)
        f.set("sig", Signal([x - m for x in s]))
        return f

    def _pre_counter(self, f):
        s = f.get("sig", Signal([])).v
        f.set("pre_counter", [(-0.1 * x) for x in s[:16]])
        return f

    def _pre_action(self, f):
        s = f.get("sig", Signal([])).v
        f.set("pre_action", [0.1 * x for x in s[:16]])
        return f

    def _equal_field(self, f):
        s = f.get("sig", Signal([])).v
        if not s:
            return f
        span = max(1e-9, max(s) - min(s))
        f.set("sig", Signal([(x - min(s)) / span for x in s]))
        return f

    def _invert(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([-x for x in s]))
        return f

    def _curvature(self, f):
        s = f.get("sig", Signal([])).v
        n = len(s)
        if n < 3:
            return f
        cur = [s[i + 1] - 2 * s[i] + s[i - 1] for i in R(1, n - 1)]
        f.set("curv", cur)
        return f

    def _dynamic(self, f):
        s = f.get("sig", Signal([])).v
        if not s:
            return f
        sp = [lerp(s[i], s[(i + 1) % len(s)], 0.5) for i in R(len(s))]
        f.set("sig", Signal(sp))
        return f

    def _partial_excess(self, f):
        s = f.get("sig", Signal([])).v
        ex = []
        for i, x in enumerate(s):
            if i % 7 == 0:
                ex.append(1.5 * x)
            else:
                ex.append(x)
        f.set("sig", Signal(ex))
        return f

    def _other_dim(self, f):
        s = f.get("sig", Signal([])).v
        n = len(s)
        if n == 0:
            return f
        sz = int(math.sqrt(n)) or 1
        grid = [s[i * sz : (i + 1) * sz] for i in R(min(sz, len(s) // max(1, sz)))]
        f.set("space", Space((len(grid), len(grid[0]) if grid else 0)))
        if grid and grid[0]:
            sp = f.get("space")
            for i, row in enumerate(grid):
                for j, val in enumerate(row):
                    sp.set((i, j), val)
        return f

    def _vibrate(self, f):
        s = f.get("sig", Signal([])).v
        vib = [x + 0.05 * math.sin(0.1 * i) for i, x in enumerate(s)]
        f.set("sig", Signal(vib))
        return f

    def _period(self, f):
        s = f.get("sig", Signal([])).v
        n = len(s)
        if n == 0:
            return f
        w = max(2, n // 16)
        f.set("period", sum(abs(x) for x in mvavg(s, w)) / max(1, n))
        return f

    def _useful_continuity(self, f):
        s = f.get("sig", Signal([])).v
        f.set(
            "sig",
            Signal([s[i - 1] * 0.3 + s[i] * 0.7 if i else s[i] for i in R(len(s))]),
        )
        return f

    def _skip(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal(s[::2] if len(s) > 1 else s))
        return f

    def _harm2good(self, f):
        s = f.get("sig", Signal([])).v
        var = sum((x - sum(s) / max(1, len(s))) ** 2 for x in s) / max(1, len(s))
        f.set("benefit", 1.0 / (1.0 + var))
        return f

    def _feedback(self, f):
        s = f.get("sig", Signal([])).v
        g = f.get("gain", 0.1)
        f.set("sig", Signal([x + g * (0.0 - x) for x in s]))
        return f

    def _mediate(self, f):
        s = f.get("sig", Signal([])).v
        mid = [(s[i] + s[i - 1]) / 2 if i else s[i] for i in R(len(s))]
        f.set("sig", Signal(mid))
        return f

    def _self_service(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([x * (1 + 0.02 * math.tanh(x)) for x in s]))
        return f

    def _substitute(self, f):
        s = f.get("sig", Signal([])).v
        f.set(
            "sig", Signal([x if abs(x) < 0.9 else (0.9 if x > 0 else -0.9) for x in s])
        )
        return f

    def _cheap_transient(self, f):
        s = f.get("sig", Signal([])).v
        f.set("temp", sum(s[:8]) if s else 0.0)
        return f

    def _replace_mech(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([x + 0.03 * math.sin(x * 3.0) for x in s]))
        return f

    def _fluid(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal(mvavg(s, max(2, len(s) // 12 or 2))))
        return f

    def _thinfilm(self, f):
        s = f.get("sig", Signal([])).v
        coat = [0.98 * x for x in s]
        f.set("sig", Signal(coat))
        return f

    def _porous(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([x if (i % 5) else 0.5 * x for i, x in enumerate(s)]))
        return f

    def _color(self, f):
        rgb = f.get("rgb", (128, 128, 128))
        deg = f.get("hue", 0.0) + 0.13
        f.set("rgb", color_shift(rgb, deg))
        f.set("hue", deg)
        return f

    def _homogenize(self, f):
        s = f.get("sig", Signal([])).v
        m = (sum(s) / len(s)) if s else 0.0
        f.set("sig", Signal([0.8 * x + 0.2 * m for x in s]))
        return f

    def _discard_regen(self, f):
        s = f.get("sig", Signal([])).v
        keep = [x for i, x in enumerate(s) if i % 9]
        regen = [rng.u(-0.1, 0.1) for _ in R(len(s) - len(keep))]
        f.set("sig", Signal(keep + regen))
        return f

    def _param(self, f):
        g = f.get("gain", 0.1)
        f.set("gain", clamp(g * (1.0 + 0.05 * rng.u(-1, 1)), 0.01, 0.5))
        return f

    def _phase(self, f):
        s = f.get("sig", Signal([])).v
        th = 0.15
        f.set("sig", Signal([1.0 if x > th else -1.0 if x < -th else 0.0 for x in s]))
        return f

    def _thermal(self, f):
        s = f.get("sig", Signal([])).v
        a = f.get("alpha", 1.0)
        f.set("sig", Signal([x * a for x in s]))
        f.set("alpha", a * (1 + 0.001 * len(s)))
        return f

    def _oxygen(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([x * (1.02) for x in s]))
        return f

    def _inert(self, f):
        s = f.get("sig", Signal([])).v
        f.set("sig", Signal([x * 0.99 for x in s]))
        return f

    def _composite(self, f):
        s = f.get("sig", Signal([])).v
        nest = f.get("nest") or [s[::2], s[1::2]]
        mix = [
            (nest[0][i % len(nest[0])] if nest[0] else 0.0) * 0.6
            + (nest[1][i % len(nest[1])] if nest[1] else 0.0) * 0.4
            for i in R(len(s) if s else 0)
        ]
        if mix:
            f.set("sig", Signal(mix))
        f.set(
            "material",
            mat_make(
                "composite",
                {"w": 0.6, "v": 0.4},
                {"rgb": f.get("rgb", (128, 128, 128))},
                micro=[len(mix)],
            ),
        )
        return f


def build_plan():
    return [
        "Segmentation",
        "Extraction",
        "LocalQuality",
        "Asymmetry",
        "Integration",
        "Universality",
        "Nesting",
        "Balance",
        "PreCounterAction",
        "PreAction",
        "EqualField",
        "Inversion",
        "Curvature",
        "Dynamics",
        "PartialExcess",
        "DimensionShift",
        "Vibration",
        "Periodicity",
        "Continuity",
        "Skipping",
        "BlessingInDisguise",
        "Feedback",
        "Mediation",
        "SelfService",
        "Substitution",
        "CheapShortLife",
        "MechanicsSubstitution",
        "Fluid",
        "ThinFilm",
        "Porous",
        "ColorChange",
        "Homogenization",
        "DiscardRegen",
        "ParamChange",
        "PhaseTransition",
        "ThermalExpansion",
        "OxygenAcceleration",
        "InertProtection",
        "Composite",
    ]


def seed_flow(n=1024):
    sig = Signal(
        [
            math.sin(2 * math.pi * (i / n) * 7)
            + 0.3 * math.sin(2 * math.pi * (i / n) * 29)
            + 0.05 * rng.u(-1, 1)
            for i in R(n)
        ]
    )
    return Flow(
        {"sig": sig, "rgb": (120, 130, 140), "hue": 0.0, "gain": 0.12, "alpha": 1.0}
    )


def evaluate(f: Flow):
    s = f.get("sig", Signal([])).v
    score = 0.0
    if s:
        mean = sum(s) / len(s)
        var = sum((x - mean) ** 2 for x in s) / len(s)
        score += 1.0 / (1.0 + var) + 0.2 * (1.0 / (1.0 + abs(mean)))
        score += 0.1 * (1.0 / (1.0 + abs(max(s) - min(s) - 1.5)))
    if f.get("material"):
        score += 0.2
    if f.get("period") is not None:
        score += 0.1
    return score


def main():
    E = Engine()
    base = seed_flow(1536)
    plan = build_plan()
    t0 = now_ms()
    out = E.run(base, plan)
    t1 = now_ms()
    scr = evaluate(out)
    res = {
        "id": E.id,
        "ms": t1 - t0,
        "score": round(scr, 6),
        "len": len(out.get("sig", Signal([])).v),
        "rgb": out.get("rgb"),
        "gain": out.get("gain"),
        "alpha": round(out.get("alpha", 0.0), 6),
        "material": (out.get("material").name if out.get("material") else None),
    }
    print(json.dumps(res, ensure_ascii=False))


def seed_flow(n=1024):
    sig = Signal(
        [
            math.sin(2 * math.pi * (i / n) * 7)
            + 0.3 * math.sin(2 * math.pi * (i / n) * 29)
            + 0.05 * rng.u(-1, 1)
            for i in R(n)
        ]
    )
    return Flow(
        {"sig": sig, "rgb": (120, 130, 140), "hue": 0.0, "gain": 0.12, "alpha": 1.0}
    )


def evaluate(f: Flow):
    s = f.get("sig", Signal([])).v
    score = 0.0
    if s:
        mean = sum(s) / len(s)
        var = sum((x - mean) ** 2 for x in s) / len(s)
        score += 1.0 / (1.0 + var) + 0.2 * (1.0 / (1.0 + abs(mean)))
        score += 0.1 * (1.0 / (1.0 + abs(max(s) - min(s) - 1.5)))
    if f.get("material"):
        score += 0.2
    if f.get("period") is not None:
        score += 0.1
    return score


def main():
    E = Engine()
    base = seed_flow(1536)
    plan = build_plan()
    t0 = now_ms()
    out = E.run(base, plan)
    t1 = now_ms()
    scr = evaluate(out)
    res = {
        "id": E.id,
        "ms": t1 - t0,
        "score": round(scr, 6),
        "len": len(out.get("sig", Signal([])).v),
        "rgb": out.get("rgb"),
        "gain": out.get("gain"),
        "alpha": round(out.get("alpha", 0.0), 6),
        "material": (out.get("material").name if out.get("material") else None),
    }
    print(json.dumps(res, ensure_ascii=False))


# BigParallelWorker v3 (Charithmeticベース, match/case, matmul/fft/ifft/conv/dot/sum/reduces対応)


# --- chunk helpers ---
def _sum_chunk(x):
    s = 0.0
    for v in x:
        s += v
    return s


def _abs_sum_chunk(x):
    s = 0.0
    for v in x:
        s += abs(v)
    return s


def _min_chunk(x):
    it = iter(x)
    m = next(it)
    for v in it:
        if v < m:
            m = v
    return m


def _max_chunk(x):
    it = iter(x)
    m = next(it)
    for v in it:
        if v > m:
            m = v
    return m


def _mean_pair(x):
    s = 0.0
    n = 0
    for v in x:
        s += v
        n += 1
    return (s, n)


def _dot_chunk(a, b):
    s = 0.0
    for x, y in zip(a, b):
        s += x * y
    return s


def _mm_blk(a, b, i0, i1, k0, k1, j0, j1):
    n, m, p = i1 - i0, k1 - k0, j1 - j0
    out = [[0.0] * p for _ in range(n)]
    for i in range(n):
        Ai = a[i0 + i]
        Oi = out[i]
        for k in range(m):
            aik = Ai[k0 + k]
            Bk = b[k0 + k]
            for j in range(p):
                Oi[j] += aik * Bk[j0 + j]
    return (i0, i1, j0, j1, out)


def _conv_blk(a, b, i0, i1):
    n = len(a)
    m = len(b)
    out = [0.0] * (i1 - i0)
    for t in range(i0, i1):
        s = 0.0
        j0 = max(0, t - (n - 1))
        j1 = min(m - 1, t)
        ai = t - j0
        for j in range(j0, j1 + 1):
            s += a[ai - (t - j)] * b[j]
        out[t - i0] = s
    return (i0, i1, out)


# --- fallback tiny DFT (小サイズのみ) ---
def _dft(x, inverse=False):
    n = len(x)
    if n == 0:
        return []
    ang = (2 * math.pi / n) * (-1 if not inverse else 1)
    out = []
    for k in range(n):
        re = 0.0
        im = 0.0
        for t in range(n):
            c = math.cos(ang * k * t)
            s = math.sin(ang * k * t)
            re += x[t] * c
            im += x[t] * s
        out.append((re, im))
    if inverse:
        inv = 1.0 / n
        return [re * inv for re, im in out]
    return out


class BigParallelWorker:
    def __init__(
        self,
        *,
        matmul_min=256,
        generic_min=10**6,
        max_workers=None,
        use_process=True,
        symbolic=None,
        quantize=None,
        fft_fn=None,
        ifft_fn=None,
        conv_fn=None,
    ):
        self.matmul_min = matmul_min
        self.generic_min = generic_min
        self.max_workers = max_workers or max(os.cpu_count() or 2, 2)
        self.use_process = use_process
        self.symbolic = symbolic
        self.quantize = quantize
        self.fft_fn = fft_fn
        self.ifft_fn = ifft_fn
        self.conv_fn = conv_fn

    def _pool(self):
        return (
            ProcessPoolExecutor(self.max_workers)
            if self.use_process
            else ThreadPoolExecutor(self.max_workers)
        )

    def _parts(self, n, target=1 << 18):
        m = max(1, (n + target - 1) // target)
        step = (n + m - 1) // m
        return [(i, min(i + step, n)) for i in range(0, n, step)]

    def _maybe_q(self, data):
        return self.quantize(data) if self.quantize else data

    def _maybe_sym(self, expr, ctx):
        return self.symbolic(expr, ctx) if self.symbolic else None

    # --- ops ---
    def sum(self, seq):
        n = len(seq)
        if n < self.generic_min:
            s = 0.0
            for v in seq:
                s += v
            return s
        with self._pool() as ex:
            fs = [ex.submit(_sum_chunk, seq[i:j]) for i, j in self._parts(n)]
            return sum(f.result() for f in as_completed(fs))

    def sum_abs(self, seq):
        n = len(seq)
        if n < self.generic_min:
            s = 0.0
            for v in seq:
                s += abs(v)
            return s
        with self._pool() as ex:
            fs = [ex.submit(_abs_sum_chunk, seq[i:j]) for i, j in self._parts(n)]
            return sum(f.result() for f in as_completed(fs))

    def reduce_min(self, seq):
        n = len(seq)
        if n == 0:
            return float("inf")
        if n < self.generic_min:
            m = seq[0]
            for v in seq[1:]:
                if v < m:
                    m = v
            return m
        with self._pool() as ex:
            fs = [ex.submit(_min_chunk, seq[i:j]) for i, j in self._parts(n)]
            m = None
            for f in as_completed(fs):
                v = f.result()
                m = v if m is None else (v if v < m else m)
            return m

    def reduce_max(self, seq):
        n = len(seq)
        if n == 0:
            return float("-inf")
        if n < self.generic_min:
            m = seq[0]
            for v in seq[1:]:
                if v > m:
                    m = v
            return m
        with self._pool() as ex:
            fs = [ex.submit(_max_chunk, seq[i:j]) for i, j in self._parts(n)]
            m = None
            for f in as_completed(fs):
                v = f.result()
                m = v if m is None else (v if v > m else m)
            return m

    def reduce_mean(self, seq):
        n = len(seq)
        if n == 0:
            return 0.0
        if n < self.generic_min:
            s = 0.0
            for v in seq:
                s += v
            return s / n
        with self._pool() as ex:
            fs = [ex.submit(_mean_pair, seq[i:j]) for i, j in self._parts(n)]
            S = 0.0
            N = 0
            for f in as_completed(fs):
                s, k = f.result()
                S += s
                N += k
            return S / N if N else 0.0

    def dot(self, a, b):
        n = len(a)
        if n != len(b):
            raise ValueError("shape mismatch")
        if n < self.generic_min:
            s = 0.0
            for x, y in zip(a, b):
                s += x * y
            return s
        with self._pool() as ex:
            fs = [ex.submit(_dot_chunk, a[i:j], b[i:j]) for i, j in self._parts(n)]
            return sum(f.result() for f in as_completed(fs))

    def matmul(self, A, B, *, tile=64):
        n = len(A)
        k = len(A[0]) if n else 0
        p = len(B[0]) if B else 0
        if n == 0 or k == 0 or p == 0:
            return []
        if k != len(B):
            raise ValueError("shape mismatch")
        if max(n, k, p) < self.matmul_min:
            C = [[0.0] * p for _ in range(n)]
            for i in range(n):
                Ai = A[i]
                Ci = C[i]
                for kk in range(k):
                    aik = Ai[kk]
                    Bk = B[kk]
                    for j in range(p):
                        Ci[j] += aik * Bk[j]
            return C
        t = tile
        out = [[0.0] * p for _ in range(n)]
        tasks = []
        with self._pool() as ex:
            for i0 in range(0, n, t):
                for k0 in range(0, k, t):
                    for j0 in range(0, p, t):
                        i1 = min(i0 + t, n)
                        k1 = min(k0 + t, k)
                        j1 = min(j0 + t, p)
                        tasks.append(ex.submit(_mm_blk, A, B, i0, i1, k0, k1, j0, j1))
            for fut in as_completed(tasks):
                i0, i1, j0, j1, blk = fut.result()
                for i in range(i1 - i0):
                    oi = out[i0 + i]
                    bi = blk[i]
                    for j in range(j1 - j0):
                        oi[j0 + j] += bi[j]
        return out

    def conv(self, a, b):
        n = len(a)
        m = len(b)
        if n == 0 or m == 0:
            return []
        L = n + m - 1
        if self.conv_fn and L >= self.generic_min:
            return self.conv_fn(a, b)
        if L < self.generic_min:
            out = [0.0] * L
            for t in range(L):
                s = 0.0
                j0 = max(0, t - (n - 1))
                j1 = min(m - 1, t)
                for j in range(j0, j1 + 1):
                    s += a[t - j] * b[j]
                out[t] = s
            return out
        parts = []
        target = max(1 << 18, m)  # 広め
        step = max(1, (L + target - 1) // (L // target + 1))
        for i in range(0, L, step):
            parts.append((i, min(i + step, L)))
        with self._pool() as ex:
            fs = [ex.submit(_conv_blk, a, b, i0, i1) for i0, i1 in parts]
            out = [0.0] * L
            for f in as_completed(fs):
                i0, i1, seg = f.result()
                out[i0:i1] = seg
        return out

    def fft(self, seq):
        n = len(seq)
        if n == 0:
            return []
        if self.fft_fn and n >= self.generic_min:
            return self.fft_fn(seq)
        if n < 2048:
            return _dft(seq, inverse=False)
        # 大規模はセグメントFFT→結合は上位で扱う想定(フック優先)
        return _dft(seq, inverse=False)

    def ifft(self, seq):
        n = len(seq)
        if n == 0:
            return []
        if self.ifft_fn and n >= self.generic_min:
            return self.ifft_fn(seq)
        if n < 2048:
            return _dft(seq, inverse=True)
        return _dft(seq, inverse=True)

    def map_reduce(self, seq, f, r):
        n = len(seq)
        if n < self.generic_min:
            acc = None
            for v in seq:
                w = f(v)
                acc = w if acc is None else r(acc, w)
            return acc
        with self._pool() as ex:
            fs = [ex.submit(self._mr_chunk, seq[i:j], f, r) for i, j in self._parts(n)]
            acc = None
            for fut in as_completed(fs):
                w = fut.result()
                acc = w if acc is None else r(acc, w)
            return acc

    @staticmethod
    def _mr_chunk(chunk, f, r):
        acc = None
        for v in chunk:
            w = f(v)
            acc = w if acc is None else r(acc, w)
        return acc

    # --- dispatcher ---
    def run(self, op: str, *a, **k):
        match op:
            case "symbolic":
                return self._maybe_sym(k.get("expr", ""), k.get("ctx", {}))
            case "sum":
                x = self._maybe_q(a[0])
                return self.sum(x)
            case "sum_abs":
                x = self._maybe_q(a[0])
                return self.sum_abs(x)
            case "reduce_min":
                x = self._maybe_q(a[0])
                return self.reduce_min(x)
            case "reduce_max":
                x = self._maybe_q(a[0])
                return self.reduce_max(x)
            case "reduce_mean":
                x = self._maybe_q(a[0])
                return self.reduce_mean(x)
            case "dot":
                A = self._maybe_q(a[0])
                B = self._maybe_q(a[1])
                return self.dot(A, B)
            case "matmul":
                A = self._maybe_q(a[0])
                B = self._maybe_q(a[1])
                return self.matmul(A, B, tile=k.get("tile", 64))
            case "conv":
                A = self._maybe_q(a[0])
                B = self._maybe_q(a[1])
                return self.conv(A, B)
            case "fft":
                x = self._maybe_q(a[0])
                return self.fft(x)
            case "ifft":
                x = self._maybe_q(a[0])
                return self.ifft(x)
            case "map_reduce":
                return self.map_reduce(*a, **k)
            case _:
                raise ValueError(f"unknown op {op}")


# --- CoreAllAdaptive ---


try:
    _now_ms
except NameError:
    import time as _t

    def _now_ms():
        return int(_t.time() * 1000)


class AutoVariantIntegrator:
    def __init__(self, selector):
        self.v = selector
        self.big = None
        self._bind_parallel()

    def _bind_parallel(self):
        try:
            self.big = BigParallelWorker()
            self.big.bind("symbolic", self.Transpiler().transpile)
            self.big.bind("quantize", self.quantile)
            self.big.bind("fft", self.ntt_conv)
            self.big.bind("ifft", self.fsum_precise)
            self.big.bind("conv", self.matmul)
        except Exception:
            self.big = None

    def matmul(self, *a, **k):
        return self.v("matmul", *a, **k)

    def conv(self, *a, **k):
        return self.v("conv", *a, **k)

    def fft(self, *a, **k):
        return self.v("fft", *a, **k)

    def ifft(self, *a, **k):
        return self.v("ifft", *a, **k)

    def dot(self, *a, **k):
        return self.v("dot", *a, **k)

    def run_each(self, *a, **k):
        return self.v("run_each", *a, **k)

    def run_count(self, *a, **k):
        return self.v("run_count", *a, **k)

    def run_chunk(self, *a, **k):
        return self.v("run_chunk", *a, **k)

    def plan_auto(self, *a, **k):
        return self.v("plan_auto", *a, **k)

    def mem_chaser(self, *a, **k):
        return self.v("mem_chaser", *a, **k)

    def stride_oracle(self, *a, **k):
        return self.v("stride_oracle", *a, **k)

    def prefetch_weaver(self, *a, **k):
        return self.v("prefetch_weaver", *a, **k)

    def alloc(self, *a, **k):
        return self.v("alloc", *a, **k)

    def free(self, *a, **k):
        return self.v("free", *a, **k)

    def partition(self, *a, **k):
        return self.v("partition", *a, **k)

    def quantile(self, *a, **k):
        return self.v("quantile", *a, **k)

    def softmax(self, *a, **k):
        return self.v("softmax", *a, **k)

    def logsumexp(self, *a, **k):
        return self.v("logsumexp", *a, **k)

    def code_gen(self, *a, **k):
        return self.v("code_gen", *a, **k)

    def transpile(self, *a, **k):
        return self.v("transpile", *a, **k)

    def triz_plan(self, *a, **k):
        return self.v("triz_plan", *a, **k)

    def triz_run(self, *a, **k):
        return self.v("triz_run", *a, **k)

    def symbolic(self, *a, **k):
        return self.v("symbolic", *a, **k)

    def vec(self, *a, **k):
        return self.v("vec", *a, **k)

    def cast(self, *a, **k):
        return self.v("cast", *a, **k)

    def window(self, *a, **k):
        return self.v("window", *a, **k)

    def chunk(self, *a, **k):
        return self.v("chunk", *a, **k)

    def flatten(self, *a, **k):
        return self.v("flatten", *a, **k)

    def pad(self, *a, **k):
        return self.v("pad", *a, **k)

    def diff(self, *a, **k):
        return self.v("diff", *a, **k)

    def prefix_sum(self, *a, **k):
        return self.v("prefix_sum", *a, **k)

    def take(self, *a, **k):
        return self.v("take", *a, **k)

    def drop(self, *a, **k):
        return self.v("drop", *a, **k)

    def filter_seq(self, *a, **k):
        return self.v("filter_seq", *a, **k)

    def unique(self, *a, **k):
        return self.v("unique", *a, **k)

    def sort_seq(self, *a, **k):
        return self.v("sort_seq", *a, **k)

    def topk(self, *a, **k):
        return self.v("topk", *a, **k)

    def argmin(self, *a, **k):
        return self.v("argmin", *a, **k)

    def argmax(self, *a, **k):
        return self.v("argmax", *a, **k)

    def map_f(self, *a, **k):
        return self.v("map_f", *a, **k)

    def reduce_f(self, *a, **k):
        return self.v("reduce_f", *a, **k)

    def sum_kahan(self, *a, **k):
        return self.v("sum_kahan", *a, **k)

    def fsum_precise(self, *a, **k):
        return self.v("fsum_precise", *a, **k)

    def mean_pairwise(self, *a, **k):
        return self.v("mean_pairwise", *a, **k)

    def var(self, *a, **k):
        return self.v("var", *a, **k)

    def median(self, *a, **k):
        return self.v("median", *a, **k)

    def winsorized_mean(self, *a, **k):
        return self.v("winsorized_mean", *a, **k)


class CoreAllAdaptive:
    def __init__(self, mode: str = "balanced", n_qubits: int = 20):
        self.mode = mode
        self.n_qubits = n_qubits
        self.route_id = (
            RouteIdentifier(mode) if "RouteIdentifier" in globals() else None
        )
        self._binds()
        self.variant_api = AutoVariantIntegrator(self.auto_variant)

    def _binds(self):
        g = globals()
        self.H = g.get("HEADER")
        self.A = g.get("ADAPTER")
        self.T = g.get("TAILER")
        self.passes = (
            self.H.decide_passes
            if self.H and hasattr(self.H, "decide_passes")
            else (lambda: 1)
        )
        self.M = {
            "vec": g.get("vec"),
            "cast": g.get("cast"),
            "window": g.get("window"),
            "chunk": g.get("chunk"),
            "flatten": g.get("flatten"),
            "pad": g.get("pad"),
            "diff": g.get("diff"),
            "prefix_sum": g.get("prefix_sum"),
            "take": g.get("take"),
            "drop": g.get("drop"),
            "filter_seq": g.get("filter_seq"),
            "unique": g.get("unique"),
            "sort_seq": g.get("sort_seq"),
            "topk": g.get("topk"),
            "argmin": g.get("argmin"),
            "argmax": g.get("argmax"),
            "map_f": g.get("map_f"),
            "reduce_f": g.get("reduce_f"),
            "sum_kahan": g.get("sum_kahan"),
            "fsum_precise": g.get("fsum_precise"),
            "mean_pairwise": g.get("mean_pairwise"),
            "var": g.get("var"),
            "median": g.get("median"),
            "quantile": g.get("quantile"),
            "softmax": g.get("softmax"),
            "logsumexp": g.get("logsumexp"),
            "median_abs_dev": g.get("median_abs_dev"),
            "winsorized_mean": g.get("winsorized_mean"),
            "dot": g.get("dot"),
            "scale": g.get("scale"),
            "norm": g.get("norm"),
            "axpy": g.get("axpy"),
            "cross": g.get("cross"),
            "matvec": g.get("matvec"),
            "spmv": g.get("spmv"),
            "ntt_conv": g.get("ntt_conv"),
        }
        self.IO = {
            "emit": g.get("emit"),
            "read": g.get("read"),
            "mmap_read": g.get("mmap_read"),
            "checkpoint": g.get("checkpoint"),
            "restore": g.get("restore"),
        }
        self.MEM = {
            "alloc": g.get("alloc"),
            "free": g.get("free"),
            "ring_push": g.get("ring_push"),
            "ring_pop": g.get("ring_pop"),
        }
        self.COMP = {
            "compile_and_run": g.get("compile_and_run"),
            "transpile_and_compile": g.get("transpile_and_compile"),
        }
        self.TSY = g.get("Transpiler")
        self.CMP = g.get("Compiler")
        self.SYM = getattr(g.get("core", object), "symbolic", None)
        self.TRIZ = {"build_plan": g.get("build_plan"), "Engine": g.get("Engine")}
        self.QA = g.get("QuantumAdapter")

    def auto_variant(self, op: str, *args, **kw):
        try:
            if op in ("matmul", "conv", "fft", "ifft", "dot"):
                fn = globals().get(op)
                return fn(*args, **kw)
            if op in ("run_each", "run_count", "run_chunk", "plan_auto"):
                return self._loop_gateway(op, *args, **kw)
            if op in ("mem_chaser", "stride_oracle", "prefetch_weaver"):
                fn = globals().get(op)
                return fn(*args, **kw)
            if op in ("alloc", "free"):
                return self.MEM[op](*args, **kw)
            if op in ("partition", "quantile", "softmax", "logsumexp"):
                return (
                    self.M[op](*args, **kw)
                    if op in self.M
                    else globals()[op](*args, **kw)
                )
            if op in ("code_gen", "transpile"):
                if op == "code_gen" and self.CMP:
                    return self.CMP().code_gen()
                if op == "transpile" and self.TSY:
                    return self.TSY().transpile(*args, **kw)
            if op in (
                "vec",
                "cast",
                "window",
                "chunk",
                "flatten",
                "pad",
                "diff",
                "prefix_sum",
                "take",
                "drop",
                "filter_seq",
                "unique",
                "sort_seq",
                "topk",
                "argmin",
                "argmax",
                "map_f",
                "reduce_f",
                "sum_kahan",
                "fsum_precise",
                "mean_pairwise",
                "var",
                "median",
                "winsorized_mean",
                "dot",
                "scale",
                "norm",
                "axpy",
                "cross",
                "matvec",
                "spmv",
                "ntt_conv",
            ):
                return self._dispatch_prim(op, *args, **kw)
            if op == "triz_plan":
                bp = self.TRIZ["build_plan"]
                return bp(*args, **kw) if bp else None
            if op == "triz_run":
                E = self.TRIZ["Engine"]
                bp = kw.get("plan")
                base = kw.get("base")
                return E().run(base, bp) if E and bp is not None else None
            if op == "symbolic":
                if not self.SYM or not hasattr(self.SYM, "hook"):
                    raise VisibleError("symbolic hook missing")
                return self.SYM.hook(*args, **kw)
            if op == "quantum_init":
                if not self.QA:
                    raise VisibleError("QuantumAdapter missing")
                return self.QA(kw.get("n_qubits", self.n_qubits))
            raise VisibleError(f"unknown op {op}")
        except Exception as e:
            raise DiagnosticError(f"AutoVariant:{op}:{e}")

    def _loop_gateway(self, op, *a, **k):
        if not (self.H and self.A and self.T):
            raise VisibleError("loop system not bound")
        p = self.passes()
        out = None
        unit = k.get("unit", "Charithmetic")
        if op == "run_each":
            seq = k.get("seq")
            expr = k.get("expr")
            for tk in self.H.file_head(unit=unit, passes=p):
                out = self.A.run_auto(len(seq), kind="map", seq=seq, expr=expr)
                self.T.finalize(
                    ticket=tk,
                    result=out,
                    t0_ms=_now_ms(),
                    op="each",
                    n_bytes=(len(out) if hasattr(out, "__len__") else None),
                )
            return out
        if op == "run_count":
            n = k.get("n")
            expr = k.get("expr")
            fmt = k.get("fmt", "d")
            for tk in self.H.file_head(unit=unit, passes=p):
                mv = self.A.run_auto(n, kind="count", n=n, expr=expr, fmt=fmt)
                out = mv
                self.T.finalize(
                    ticket=tk,
                    result=None,
                    t0_ms=_now_ms(),
                    op="count",
                    n_bytes=(len(mv) if hasattr(mv, "__len__") else None),
                )
            return out
        if op == "run_chunk":
            mv = k.get("mv")
            parts = k.get("parts", 1)
            flush_ms = k.get("flush_ms", 0)
            update = k.get("update", False)
            for tk in self.H.file_head(unit=unit, passes=p):
                out = self.A.run_auto(
                    len(mv),
                    kind="chunk",
                    mv=mv,
                    parts=parts,
                    flush_ms=flush_ms,
                    update=update,
                )
                self.T.finalize(
                    ticket=tk,
                    result=None,
                    t0_ms=_now_ms(),
                    op="chunk",
                    n_bytes=(len(out) if hasattr(out, "__len__") else None),
                )
            return out
        if op == "plan_auto":
            size = k.get("size")
            kind = k.get("kind", "auto")
            planner = getattr(self.A, "plan_auto", None)
            return planner(size, kind) if planner else "auto"

    def _dispatch_prim(self, name, *a, **k):
        if name == "vec":
            return self.M["vec"](*a, **k)
        if name == "cast":
            return self.M["cast"](*a, **k)
        if name == "window":
            return self.M["window"](*a, **k)
        if name == "chunk":
            return self.M["chunk"](*a, **k)
        if name == "flatten":
            return self.M["flatten"](*a, **k)
        if name == "pad":
            return self.M["pad"](*a, **k)
        if name == "diff":
            return self.M["diff"](*a, **k)
        if name == "prefix_sum":
            return self.M["prefix_sum"](*a, **k)
        if name == "take":
            return self.M["take"](*a, **k)
        if name == "drop":
            return self.M["drop"](*a, **k)
        if name == "filter_seq":
            return self.M["filter_seq"](*a, **k)
        if name == "unique":
            return self.M["unique"](*a, **k)
        if name == "sort_seq":
            return self.M["sort_seq"](*a, **k)
        if name == "topk":
            return self.M["topk"](*a, **k)
        if name == "argmin":
            return self.M["argmin"](*a, **k)
        if name == "argmax":
            return self.M["argmax"](*a, **k)
        if name == "map_f":
            return self.M["map_f"](*a, **k)
        if name == "reduce_f":
            return self.M["reduce_f"](*a, **k)
        if name in (
            "sum_kahan",
            "fsum_precise",
            "mean_pairwise",
            "var",
            "median",
            "winsorized_mean",
        ):
            return self.M[name](*a, **k)
        if name in (
            "dot",
            "scale",
            "norm",
            "axpy",
            "cross",
            "matvec",
            "spmv",
            "ntt_conv",
        ):
            return self.M[name](*a, **k)
        raise VisibleError(f"unknown prim {name}")

    def run(self, op: str, *a, **k):
        sla = k.get("sla", self.mode)
        if self.route_id:
            try:
                self.route_id.identify_route(op, a[0] if a else k, sla)
            except Exception:
                pass
        return (
            getattr(self.variant_api, op)(*a, **k)
            if hasattr(self.variant_api, op)
            else self.auto_variant(op, *a, **k)
        )

    def warmup(self, scales: tuple = (100, 10_000, 100_000)) -> None:
        import random

        rnd = random.Random(42)

        def _try(x, name, *a, **k):
            obj = getattr(self, x, None)
            fn = getattr(obj, name, None) if obj is not None else None
            if callable(fn):
                return fn(*a, **k)
            return None

        if hasattr(self, "route_id"):
            try:
                self.route_id.identify_route("warmup", {"sizes": scales}, self.mode)
            except Exception:
                pass
        _try("big", "prime")
        _try("batch", "prime")
        _try("align", "prime")
        for n in scales:
            v = [rnd.random() for _ in range(n)]
            _try("prec", "kahan_sum", v)
            _try("prec", "welford_var", v)
            _try("prec", "p2_quantile", v, 0.95)
            _try("blas", "gemm_sample", v)
            _try("vseq", "apply_ops", v)
            _try("fft", "fft_iter", v)
            _try("loop", "unroll_sample", v)
            _try("bufc", "allocate", len(v))
            _try("poly", "eval_expr", "x+1", {"x": 1})
            _try("sonic", "allocate", len(v))
            _try("delta", "prewarm")
            _try("jit", "trace", v)
            _try("meter", "tick", "warmup")
            _try("align", "align_block", v)
            _try("batch", "feed", v)
            _try("qtz", "quantize", v)
            _try("rnp", "prune", v)
            _try("sum_sort", "run", v)
            _try("matmul", "matmul", [[1.0, 2.0], [3.0, 4.0]], [[5.0, 6.0], [7.0, 8.0]])
            if getattr(self, "signal", None):
                getattr(self.signal.fftcore, "fft_iter")(v)
            _try("dot", "dot", v, v)
            _try("scalar", "add", v, 1.0)
            _try("accuracy", "kahan_sum", v)
            _try("symbolic", "expand", "a*(b+c)")
            _try("autovar", "run", v)
            _try("guard", "check", v)
            _try("big", "run", "sum_abs", v)
            _try("big", "run", "reduce_min", v)
            _try("big", "run", "reduce_max", v)
            _try("big", "run", "reduce_mean", v)
            try:
                if hasattr(self, "variant_api"):
                    plan = self.variant_api.triz_plan(base="sum", budget=8)
                    self.variant_api.triz_run(base="sum", plan=plan)
            except Exception:
                pass
            _try("loopops", "pipe", v)
        try:
            if hasattr(self, "variant_api"):
                self.variant_api.plan_auto(size=scales[-1], kind="auto")
        except Exception:
            pass


def _bind_parallel(self):
    sym = (
        (lambda expr, ctx: self.symbolic.hook(expr, ctx))
        if getattr(self, "symbolic", None)
        else None
    )
    qtz = (
        (lambda x: self.qtz.quantize(x))
        if getattr(self, "qtz", None)
        else (lambda x: x)
    )
    fft_fn = (
        (lambda x: self.signal.fftcore.fft_iter(x))
        if getattr(self, "signal", None)
        else None
    )
    ifft_fn = (
        (lambda x: self.signal.fftcore.ifft_iter(x))
        if getattr(self, "signal", None) and hasattr(self.signal.fftcore, "ifft_iter")
        else None
    )
    conv_fn = (
        (lambda a, b: self.signal._conv_ols(a, b))
        if getattr(self, "signal", None) and hasattr(self.signal, "_conv_ols")
        else None
    )
    self.big = BigParallelWorker(
        matmul_min=256,
        generic_min=10**6,
        max_workers=None,
        use_process=True,
        symbolic=sym,
        quantize=qtz,
        fft_fn=fft_fn,
        ifft_fn=ifft_fn,
        conv_fn=conv_fn,
    )


if not hasattr(CoreAllAdaptive, "_orig_auto_variant"):
    CoreAllAdaptive._orig_auto_variant = CoreAllAdaptive.auto_variant

    def _auto_variant_parallel(self, op, *a, **k):
        if not hasattr(self, "big"):
            _bind_parallel(self)
        if op == "matmul":
            A, B = a
            n = len(A)
            k_ = len(A[0]) if n else 0
            p = len(B[0]) if B else 0
            if max(n, k_, p) >= self.big.matmul_min:
                return self.big.matmul(A, B, tile=k.get("tile", 64))
        if op in (
            "fft",
            "ifft",
            "conv",
            "dot",
            "sum",
            "sum_abs",
            "reduce_min",
            "reduce_max",
            "reduce_mean",
        ):
            if op in ("dot", "conv") and len(a) >= 2:
                n_est = max(len(a[0]), len(a[1]))
            else:
                n_est = len(a[0]) if a else 0
            if n_est >= self.big.generic_min:
                return self.big.run(op, *a, **k)
        return self._orig_auto_variant(op, *a, **k)

    CoreAllAdaptive.auto_variant = _auto_variant_parallel

try:
    core
except NameError:
    core = None
if core is not None:
    core.alladaptive = CoreAllAdaptive(getattr(core, "mode", "balanced"))

class BenchOps:
    """Independent implementations of 14 benchmark ops (_ch suffix)."""

    # --- 1. sum (Kahan) ---
    def sum_ch(self, xs):
        s, c = 0.0, 0.0
        for x in xs:
            y = x - c
            t = s + y
            c = (t - s) - y
            s = t
        return s

    # --- 2. matmul ---
    def matmul_ch(self, A, B):
        n, m, p = len(A), len(A[0]), len(B[0])
        C = [[0.0] * p for _ in range(n)]
        for i in range(n):
            for k in range(m):
                aik = A[i][k]
                for j in range(p):
                    C[i][j] += aik * B[k][j]
        return C

    # --- 3. fft (Cooley-Tukey, power of 2) ---
    def fft_ch(self, x):
        n = len(x)
        if n <= 1:
            return x[:]
        if n & (n - 1):
            return self.dft_ch(x)
        even = self.fft_ch(x[0::2])
        odd = self.fft_ch(x[1::2])
        out = [0j] * n
        for k in range(n // 2):
            wk = math.e ** (-2j * math.pi * k / n) * odd[k]
            out[k] = even[k] + wk
            out[k + n // 2] = even[k] - wk
        return out

    def dft_ch(self, x):
        n = len(x)
        out = [0j] * n
        tau = -2.0 * math.pi
        for k in range(n):
            s = 0j
            for t in range(n):
                ang = tau * (k * t) / n
                s += x[t] * math.e ** (1j * ang)
            out[k] = s
        return out

    # --- 4. conv (direct) ---
    def conv_ch(self, a, b):
        na, nb = len(a), len(b)
        out = [0.0] * (na + nb - 1)
        for i in range(na):
            ai = a[i]
            for j in range(nb):
                out[i + j] += ai * b[j]
        return out

    # --- 5. argsort ---
    def argsort_ch(self, xs):
        return [i for i, _ in sorted(enumerate(xs), key=lambda t: t[1])]

    # --- 6. dot ---
    def dot_ch(self, a, b):
        return sum(x * y for x, y in zip(a, b))

    # --- 7. scalar_add ---
    def scalar_add_ch(self, a, b):
        return a + b

    # --- 8. scalar_mul ---
    def scalar_mul_ch(self, a, b):
        return a * b

    # --- 9. reduce_min ---
    def reduce_min_ch(self, xs):
        return min(xs)

    # --- 10. reduce_max ---
    def reduce_max_ch(self, xs):
        return max(xs)

    # --- 11. reduce_mean ---
    def reduce_mean_ch(self, xs):
        return sum(xs) / len(xs) if xs else 0.0

    # --- 12. trig_sin ---
    def trig_sin_ch(self, x):
        return math.sin(x)

    # --- 13. trig_cos ---
    def trig_cos_ch(self, x):
        return math.cos(x)

    # --- 14. poly_eval (Horner) ---
    def poly_eval_ch(self, coef, x):
        y = 0.0
        for c in reversed(coef):
            y = y * x + c
        return y

    def set_sla(self, name: str) -> None:
        self.prec.set_sla(name)
        self.loop.sla = name

    def set_mass(self, profile: str) -> None:
        for c in (
            self.prec,
            self.blas,
            self.vseq,
            self.fft,
            self.loop,
            self.bufc,
            self.poly,
        ):
            if hasattr(c, "set_mass"):
                c.set_mass(profile)

    def export_policy(self) -> str:
        d = {
            "precision": self.prec.export_policy(),
            "blas": self.blas.export_policy()
            if hasattr(self.blas, "export_policy")
            else "{}",
            "vseq": self.vseq.export_policy()
            if hasattr(self.vseq, "export_policy")
            else "{}",
            "fft": self.fft.export_policy()
            if hasattr(self.fft, "export_policy")
            else "{}",
            "loop": self.loop.export_policy(),
            "bufc": self.bufc.export_policy(),
            "poly": self.poly.export_policy(),
        }
        return json.dumps(d, ensure_ascii=False)

    def import_policy(self, s: str) -> None:
        try:
            d = json.loads(s)
        except Exception:
            return
        if "precision" in d:
            self.prec.import_policy(d["precision"])
        if "blas" in d and hasattr(self.blas, "import_policy"):
            self.blas.import_policy(d["blas"])
        if "vseq" in d and hasattr(self.vseq, "import_policy"):
            self.vseq.import_policy(d["vseq"])
        if "fft" in d and hasattr(self.fft, "import_policy"):
            self.fft.import_policy(d["fft"])
        if "loop" in d:
            self.loop.import_policy(d["loop"])
        if "bufc" in d:
            self.bufc.import_policy(d["bufc"])
        if "poly" in d:
            self.poly.import_policy(d["poly"])

    def warmup(self) -> None:
        self.prec.warmup()
        self.blas.warmup()
        self.vseq.warmup()
        self.fft.warmup()
        self.loop.warmup()
        self.bufc.sonic_prewarm()

    def learn_from_latency(self, key: str, p95_ms: float, err: float = 0.0) -> None:
        self.prec.learn_mode(p95_ms, err)
        self.vseq.learn_window(p95_ms)
        self.fft.learn_route(int(p95_ms * 1024), p95_ms)
        self.loop.learn_route(p95_ms)
        self.bufc.record_latency(p95_ms)
        self.bufc.mass_adjust()

    def matmul(self, A: list[list[float]], B: list[list[float]]) -> list[list[float]]:
        m = len(A)
        n = len(B[0]) if B else 0
        C = [[0.0] * n for _ in range(m)]
        self.blas.gemm(A, B, C)
        return C

    def qr(self, A: list[list[float]]) -> Tuple[list[list[float]], list[list[float]]]:
        return self.blas.qr(A)

    def lu(self, A: list[list[float]]) -> Tuple[list[list[float]], list[list[float]]]:
        return self.blas.lu(A)

    def svd(
        self, A: list[list[float]], it: int = 64
    ) -> Tuple[list[list[float]], List[float], list[list[float]]]:
        return self.blas.svd(A, it)

    def fft_exec(self, x: list[complex]) -> list[complex]:
        return self.fft.fft(x)

    def ifft_exec(self, x: list[complex]) -> list[complex]:
        return self.fft.ifft(x)

    def conv(self, a: list[float], b: list[float]) -> list[float]:
        return self.fft.conv(a, b)

    def xcorr(self, a: list[float], b: list[float]) -> list[float]:
        return self.fft.xcorr(a, b)

    def fft_blas_bridge(
        self, X: list[list[complex]], Y: list[list[complex]]
    ) -> list[list[complex]]:
        return self.fft.fft_blas_bridge(X, Y)

    def rolling_sum(self, it: Iterable[float], win: int) -> Iterable[float]:
        self.vseq.set_window(win)
        return self.vseq.rolling_sum(it)

    def rolling_var(self, it: Iterable[float], win: int) -> Iterable[float]:
        self.vseq.set_window(win)
        return self.vseq.rolling_var(it)

    def run_auto(
        self,
        size: int,
        expr_kind: str,
        *,
        seq: Optional[Iterable[Any]] = None,
        expr: Optional[str] = None,
        fmt: str = "f",
        mv: Optional[memoryview] = None,
    ) -> Any:
        return self.loop.run_auto(size, expr_kind, seq=seq, expr=expr, fmt=fmt, mv=mv)

    def run_each(self, seq: Iterable[Any], expr: str) -> List[Any]:
        return self.loop.run_each(seq, expr)

    def run_count(self, n: int, expr: str, fmt: str = "f") -> memoryview:
        return self.loop.run_count(n, expr, fmt)

    def run_chunk(
        self,
        mv: memoryview,
        parts: int = 8,
        flush_ms: int = 4,
        update: Optional[Callable] = None,
    ) -> memoryview:
        return self.loop.run_chunk(mv, parts, flush_ms, update)

    def loop_plan(self, size: int, expr_kind: str) -> str:
        return self.loop.plan_auto(size, expr_kind)

    def loop_match(self, size: int, shape_bin: int, boundary: str, err: str) -> str:
        return self.loop.match_case_route(size, shape_bin, boundary, err)

    def poly_map(self, it: Iterable[Any], fns: List[Callable]) -> Iterable[Any]:
        return self.poly.map_pipe(it, fns)

    def poly_reduce(self, it: Iterable[Any], fn: Callable, init: Any) -> Any:
        return self.poly.reduce_pipe(it, fn, init)

    def poly_groupby(self, it: Iterable[Tuple[Any, float]]) -> Dict[Any, float]:
        return self.poly.decl_groupby_sum(it)

    def poly_sort(
        self, it: Iterable[Any], key: Optional[Callable] = None, rev: bool = False
    ) -> List[Any]:
        return self.poly.decl_sort(it, key, rev)

    def poly_loop(self, n: int, step: int, fn: Callable) -> List[Any]:
        return self.poly.imp_loop(n, step, fn)

    def poly_decl(self, it: Iterable[Tuple[Any, float]]) -> Dict[Any, float]:
        return self.poly.decl_groupby_sum(it)

    def poly_imp(self, n: int, step: int, fn: Callable) -> List[Any]:
        return self.poly.imp_loop(n, step, fn)

    def buf_flush(self, ms: int = 4) -> None:
        self.bufc.flush(ms)

    def buf_mass_adjust(self) -> None:
        self.bufc.mass_adjust()

    def buf_snapshot(
        self,
        qps: float = 0.0,
        io_hide: float = 0.0,
        jit_hit: float = 0.0,
        tier: int = 2,
    ) -> Dict[str, float]:
        return self.bufc.snapshot(qps, io_hide, jit_hit, tier)

    def shard(self, vecs: list[memoryview], n_shard: int) -> list[memoryview]:
        return self.align.shard(vecs, n_shard)

    def align_avg(self, groups: list[list[memoryview]]) -> list[memoryview]:
        return self.align.align_avg(groups)

    async def aggregate(
        self, vecs: Iterable[memoryview], batch: int = 1024
    ) -> List[memoryview]:
        out = []
        async for mv in self.batch.aggregate(vecs, batch=batch):
            out.append(mv)
        return out

    def quant8(self, vecs: list[memoryview]) -> list[memoryview]:
        return self.qtz.quant8(vecs)

    def quant16(self, vecs: list[memoryview]) -> list[memoryview]:
        return self.qtz.quant16(vecs)

    def retrieve(
        self, queries: list[memoryview], vec_db: list[memoryview], batch: int = 32
    ) -> List[Tuple[memoryview, float]]:
        return self.rnp.retrieve(queries, vec_db, batch=batch)

    def prune_topk(self, ctx: memoryview, query: memoryview, k: int = 64) -> memoryview:
        return self.rnp.prune_topk(ctx, query, k)

    def sonic_snapshot(self) -> Dict[str, Any]:
        return self.meter.last

    def sonic_metrics(self) -> Dict[str, Any]:
        return self.meter.last

    def delta_gate(self, x: Any) -> Any:
        return self.delta.apply(x)

    def jit_cache_get(self, key: str) -> Optional[Callable]:
        try:
            return self.jit.get_or_build(key, lambda: "")
        except Exception:
            return None

    def jit_cache_put(self, key: str, val: Callable) -> None:
        self.jit.cache[key] = val

    def snapshot(
        self,
        qps: float = 0.0,
        io_hide: float = 0.0,
        jit_hit: float = 0.0,
        tier: int = 2,
    ) -> Dict[str, float]:
        return self.bufc.snapshot(qps, io_hide, jit_hit, tier)

    def sum(self, arr: Iterable[float]) -> float:
        return self.sum_sort.sum_block(arr)

    def argsort(self, arr: List[float]) -> List[int]:
        return self.sum_sort.argsort_block(arr)

    def gemm(self, A: List[List[float]], B: List[List[float]]) -> List[List[float]]:
        n = len(A)
        m = len(B[0]) if B else 0
        C = [[0.0] * m for _ in range(n)]
        self.blas.gemm(A, B, C)
        return C


# —-- Protocols —--


class _CacheLike(Protocol):
    def put(self, key: Any, obj: Any, *, allow_store: bool = True) -> None:
        ...


class _PoolLike(Protocol):
    def flush(self, ms: int = 4) -> None:
        ...

    def mass_adjust(self) -> None:
        ...


class _DeltaLike(Protocol):
    def update(self, key: str) -> None:
        ...

    def is_hot(self, key: str) -> bool:
        ...


class _TicketLike(Protocol):
    key: Any
    kind: str
    fmt: str | None
    seq: Any | None
    mv: memoryview | None
    aot_key: str | None
    plan: str | None
    gc_off: bool
    store_result: bool
    unroll: int
    code: str | None


# —-- Helpers —--


def _now_ms() -> float:
    return time.perf_counter() * 1_000.0


def _safe_float(x: Any) -> float:
    try:
        return float(x)
    except Exception:
        return 0.0


def _crc32_bytes(b: bytes) -> int:
    return zlib.crc32(b) & 0xFFFF_FFFF


def _guard_path(p: str) -> None:
    if not re.fullmatch(r"[ -~]{1,128}", p or ""):
        raise SecurityCriticalError("path policy")
    if any(s in p for s in ("..", "//", "\x00")):
        raise SecurityCriticalError("path traversal")


# — LoopTailer —


class LoopTailer:
    def __init__(
        self,
        cache: _CacheLike | None = None,
        pool: _PoolLike | None = None,
        policy: TailPolicy | None = None,
        meter: TailMeter | None = None,
        delta: _DeltaLike | None = None,
        aot_db: str = "pss_aot.sqlite3",
        aot_ns_cap: int = 64,
    ) -> None:
        self.cache = cache
        self.pool = pool
        self.policy = policy or TailPolicy()
        self.meter = meter or TailMeter()
        self.delta = delta
        self.aot_db = aot_db
        self.aot_ns_cap = max(4, int(aot_ns_cap))
        self._aot_ns: Dict[str, Callable[..., Any]] = {}
        self._aot_lock = threading.Lock()
        self._init_aot_store()

    # —-- Public API —--

    def finalize(
        self,
        ticket: _TicketLike,
        result: Any,
        *,
        t0_ms: float,
        op: str,
        n_bytes: int | None = None,
        flop2: int | None = None,
    ) -> Any:
        was = gc.isenabled()
        try:
            if getattr(ticket, "gc_off", False) and was:
                if n_bytes and n_bytes >= (1 << 18):
                    gc.enable()
                else:
                    gc.disable()
            p50 = max(0.0, _now_ms() - t0_ms)
            self._feed_policy(op, p50)
            self._maybe_cache(ticket, result)
            self._maybe_delta(ticket)
            self._maybe_pool_flush()
            self._maybe_metric(ticket, op, p50, n_bytes, flop2)
            self._maybe_aot_store(ticket)
            return result
        finally:
            if getattr(ticket, "gc_off", False) and not was:
                gc.enable()

    def aot_load_all(self) -> int:
        cnt = 0
        with self._aot_lock, sqlite3.connect(self.aot_db) as db:
            db.row_factory = sqlite3.Row
            for r in db.execute("select k, kind, unit, src from aot"):
                fn = self._compile_guarded(r["src"])
                self._remember_ns(r["k"], fn)
                cnt += 1
        return cnt

    def aot_get(self, key: str) -> Optional[Callable[..., Any]]:
        with self._aot_lock:
            return self._aot_ns.get(key)

    # --— Internals —--

    def _feed_policy(self, op: str, p50: float) -> None:
        tick = getattr(self, "_tick", 0) + 1
        self._tick = tick & 0xFFFF
        if (tick & 0x3F) == 0:
            ema = getattr(self, "_p50_ema", p50)
            self._p50_ema = ema + 0.1 * (p50 - ema)
            self.policy.feed(op, self._p50_ema, self._p50_ema * 1.05)

    def _maybe_cache(self, ticket: _TicketLike, result: Any) -> None:
        if not self.cache:
            return
        allow = bool(getattr(ticket, "store_result", True))
        obj = result if allow else result
        try:
            self.cache.put(getattr(ticket, "key", None), obj, allow_store=allow)
        except Exception as e:
            raise DiagnosticError(f"cache: {e!s}") from e

    def _maybe_delta(self, ticket: _TicketLike) -> None:
        if not self.delta:
            return
        k = str(getattr(ticket, "kind", ""))
        if k:
            self.delta.update(k)

    def _maybe_pool_flush(self) -> None:
        if not self.pool:
            return
        try:
            self.pool.mass_adjust()
            self.pool.flush(ms=4)
        except Exception as e:
            raise DiagnosticError(f"pool: {e!s}") from e

    def _maybe_metric(
        self,
        ticket: _TicketLike,
        op: str,
        p50: float,
        n_bytes: int | None,
        flop2: int | None,
    ) -> None:
        tick = getattr(self, "_tick", 0)
        if (tick & 0x7F) != 0:
            return
        rec = {
            "op": op,
            "p50_ms": float(p50),
            "kind": str(getattr(ticket, "kind", "")),
            "plan": str(getattr(ticket, "plan", "")),
            "un": int(getattr(ticket, "unroll", 0)),
        }
        if n_bytes is not None:
            rec["bytes"] = int(n_bytes)
        if flop2 is not None:
            rec["flop2"] = int(flop2)
        rec.update(self.policy.snapshot())
        self.meter.write_jsonl(rec)

    def _maybe_aot_store(self, ticket: _TicketLike) -> None:
        k = getattr(ticket, "aot_key", None)
        src = getattr(ticket, "code", None)
        if not k or not src:
            return
        try:
            self._aot_store(
                str(k),
                str(getattr(ticket, "kind", "")),
                str(getattr(ticket, "fmt", "")),
                str(src),
            )
            fn = self._compile_guarded(str(src))
            self._remember_ns(str(k), fn)
        except Exception as e:
            raise DiagnosticError(f"aot: {e!s}") from e

    # —-- AOT store/load —--

    def _init_aot_store(self) -> None:
        _guard_path(self.aot_db)
        with sqlite3.connect(self.aot_db) as db:
            db.execute(
                "create table if not exists aot("
                "k text primary key, kind text, unit text, src text)"
            )
            db.commit()

    def _aot_store(self, key: str, kind: str, unit: str, src: str) -> None:
        blob = src.encode("utf-8")
        if len(blob) > 512_000:
            raise VisibleError("aot size")
        with sqlite3.connect(self.aot_db) as db:
            db.execute(
                "insert or replace into aot(k,kind,unit,src) values(?,?,?,?)",
                (key, kind, unit, src),
            )
            db.commit()

    def _compile_guarded(self, src: str) -> Callable[..., Any]:
        if "import" in src or "__" in src:
            raise SecurityCriticalError("guard")
        code = compile(src, "<aot>", "exec")
        ns: Dict[str, Any] = {}
        exec(code, {"__builtins__": {}}, ns)
        fn = next((v for v in ns.values() if callable(v)), None)
        if not callable(fn):
            raise DiagnosticError("aot no func")
        return fn  # type: ignore[return-value]

    def _remember_ns(self, key: str, fn: Callable[..., Any]) -> None:
        with self._aot_lock:
            if len(self._aot_ns) >= self.aot_ns_cap:
                k0 = next(iter(self._aot_ns))
                del self._aot_ns[k0]
            self._aot_ns[key] = fn


# --- PSS_ForRuntime.run_each — fixed header/tailer wiring (no stray self) ---


def run_each(self, seq: Iterable[Any], expr: str) -> List[Any]:
    """for-each with Header→Plan→Tailer round-trip."""
    if not isinstance(expr, str):
        raise VisibleError("expr required")
    size = len(seq) if hasattr(seq, "__len__") else 0

    # Header: open ticket once
    tk = self.header.open_ticket("each", size)

    # Plan: compile/get fn, execute loop
    t0 = _now_ms()
    key = self.pic.make_key("each", expr, (size,))
    fn = self.pic.get(key)
    if fn is None:
        tree = ast.parse(f"lambda x: ({expr})", mode="eval")
        code = compile(tree, "<jit_each>", "eval")
        fn = eval(code, {"__builtins__": {}})
        self.pic.put(key, fn, tree, expr)

    out: List[Any] = []
    for x in seq:
        out.append(fn(x))

    # Tailer: finalize exactly once (no re-open to header here)
    return self.tailer.finalize(
        ticket=tk,
        result=out,
        t0_ms=t0,
        op="each",
        n_bytes=(len(out) if hasattr(out, "__len__") else None),
        flop2=size,
    )


if __name__ == "__main__":
    ops = BenchOps()
