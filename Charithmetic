# Charithmetic
# Pure-Python numerical core with IR, cache, auto-variants,
# safe arithmetic, FFT, convolution, matmul, metrics, and CLI shell.
#
# Copyright (c) 2025 HIROKI (kirohihi69lo-wq)
# Released under the MIT License.
#
# A higher-level model is separately available.
# For commercial use or customization, please contact us.

from __future__ import annotations

import argparse
import ast
import cmath
import math
import time
from collections import OrderedDict, deque
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any, Deque, Dict, List, Sequence, Tuple


# ---------------- Metrics ----------------
class OpMetrics:
    def __init__(self, max_samples: int = 256) -> None:
        self.samples: Deque[float] = deque(maxlen=max_samples)
        self.count = 0

    def add(self, ms: float) -> None:
        self.samples.append(ms)
        self.count += 1

    def snapshot(self) -> Dict[str, float]:
        if not self.samples:
            return {"count": 0, "mean_ms": 0.0, "p50_ms": 0.0, "p95_ms": 0.0}
        data = sorted(self.samples)
        n = len(data)
        p50 = data[int(0.50 * (n - 1))]
        p95 = data[int(0.95 * (n - 1))]
        mean = sum(data) / n
        return {
            "count": float(self.count),
            "mean_ms": mean,
            "p50_ms": p50,
            "p95_ms": p95,
        }


class Metrics:
    def __init__(self) -> None:
        self.ops: Dict[str, OpMetrics] = {}
        self.started_at = time.time()

    def record(self, op: str, ms: float) -> None:
        self.ops.setdefault(op, OpMetrics()).add(ms)

    def snapshot(self) -> Dict[str, Any]:
        return {
            "uptime_s": time.time() - self.started_at,
            "ops": {k: v.snapshot() for k, v in self.ops.items()},
        }


_metrics = Metrics()


def _timeit(op: str):
    def deco(f):
        def wrap(*args, **kw):
            t0 = time.perf_counter()
            out = f(*args, **kw)
            dt = (time.perf_counter() - t0) * 1000.0
            _metrics.record(op, dt)
            return out

        return wrap

    return deco


# ---------------- Memory cache (LRU) ----------------
class MemoryCache:
    def __init__(self, max_size: int = 256) -> None:
        self._cache: OrderedDict[Any, Any] = OrderedDict()
        self.hits = 0
        self.misses = 0
        self.max_size = max_size

    def get(self, key: Any) -> Any:
        if key in self._cache:
            self.hits += 1
            self._cache.move_to_end(key)
            return self._cache[key]
        self.misses += 1
        return None

    def put(self, key: Any, value: Any) -> None:
        if key in self._cache:
            self._cache.move_to_end(key)
        self._cache[key] = value
        if len(self._cache) > self.max_size:
            self._cache.popitem(last=False)

    def stats(self) -> Tuple[int, int, float]:
        total = self.hits + self.misses
        rate = self.hits / total if total else 0.0
        return self.hits, self.misses, rate


_cache = MemoryCache()


# ---------------- Safety / Precision ----------------
def safe_div(a: float, b: float) -> float:
    if b == 0.0:
        raise ZeroDivisionError("division by zero")
    y = a / b
    if not math.isfinite(y):
        raise ArithmeticError("non-finite division result")
    return y


def sum_kahan(xs: Sequence[float]) -> float:
    s, c = 0.0, 0.0
    for x in xs:
        y = x - c
        t = s + y
        c = (t - s) - y
        s = t
    return s


def sum_fsum(xs: Sequence[float]) -> float:
    return math.fsum(xs)


# ---------------- Core ops ----------------
@_timeit("add")
def add(a: float, b: float) -> float:
    return a + b


@_timeit("sub")
def sub(a: float, b: float) -> float:
    return a - b


@_timeit("mul")
def mul(a: float, b: float) -> float:
    return a * b


@_timeit("div")
def div(a: float, b: float) -> float:
    return safe_div(a, b)


@_timeit("dot")
def dot(a: Sequence[float], b: Sequence[float]) -> float:
    return sum_fsum(x * y for x, y in zip(a, b))


# ---------------- Linear algebra ----------------
def _shape(A: Sequence[Sequence[float]]) -> Tuple[int, int]:
    return (len(A), len(A[0]) if A else 0)


def _matmul_naive(A, B) -> List[List[float]]:
    r, k = _shape(A)
    k2, c = _shape(B)
    if k != k2:
        raise ValueError("shape mismatch")
    out = [[0.0] * c for _ in range(r)]
    for i in range(r):
        Ai = A[i]
        for t in range(k):
            ait = Ai[t]
            Bt = B[t]
            for j in range(c):
                out[i][j] += ait * Bt[j]
    return out


def _matmul_rows(A, B, i0, i1):
    r, k = _shape(A)
    _, c = _shape(B)
    sub = [[0.0] * c for _ in range(i1 - i0)]
    for ii, i in enumerate(range(i0, i1)):
        Ai = A[i]
        for t in range(k):
            ait = Ai[t]
            Bt = B[t]
            for j in range(c):
                sub[ii][j] += ait * Bt[j]
    return i0, sub


@_timeit("matmul")
def matmul(A, B, threshold=256) -> List[List[float]]:
    key = ("matmul", tuple(map(tuple, A)), tuple(map(tuple, B)))
    cached = _cache.get(key)
    if cached is not None:
        return cached
    r, k = _shape(A)
    _, c = _shape(B)
    work = r * k * c
    if work < threshold:
        out = _matmul_naive(A, B)
    else:
        chunks = max(1, min(8, r // 8))
        step = max(1, r // chunks)
        pieces = []
        with ThreadPoolExecutor(max_workers=chunks) as ex:
            futs = [
                ex.submit(_matmul_rows, A, B, i0, min(r, i0 + step))
                for i0 in range(0, r, step)
            ]
            for f in as_completed(futs):
                pieces.append(f.result())
        pieces.sort(key=lambda x: x[0])
        out = [row for _, block in pieces for row in block]
    _cache.put(key, out)
    return out


# ---------------- FFT ----------------
def _fft_recursive(x):
    n = len(x)
    if n <= 1:
        return list(x)
    even = _fft_recursive(x[0::2])
    odd = _fft_recursive(x[1::2])
    ang = [-2j * math.pi * k / n for k in range(n // 2)]
    tw = [cmath.exp(a) for a in ang]
    return [even[k] + tw[k] * odd[k] for k in range(n // 2)] + [
        even[k] - tw[k] * odd[k] for k in range(n // 2)
    ]


def _fft_iterative(x):
    n = len(x)
    if n & (n - 1):  # not pow2
        return _fft_recursive(x)
    bits = n.bit_length() - 1
    rev = [int(bin(i)[2:].zfill(bits)[::-1], 2) for i in range(n)]
    a = [x[i] for i in rev]
    m = 2
    while m <= n:
        half = m // 2
        w_m = cmath.exp(-2j * math.pi / m)
        for k in range(0, n, m):
            w = 1.0 + 0j
            for j in range(half):
                t = w * a[k + j + half]
                u = a[k + j]
                a[k + j], a[k + j + half] = u + t, u - t
                w *= w_m
        m *= 2
    return a


@_timeit("fft")
def fft(x):
    key = ("fft", tuple(x))
    cached = _cache.get(key)
    if cached is not None:
        return cached
    _, _, rate = _cache.stats()
    out = _fft_iterative(x) if (len(x) > 32 and rate >= 0.3) else _fft_recursive(x)
    _cache.put(key, out)
    return out


# ---------------- Convolution ----------------
@_timeit("conv")
def conv(a, b) -> List[float]:
    key = ("conv", tuple(a), tuple(b))
    cached = _cache.get(key)
    if cached is not None:
        return cached
    n, m = len(a), len(b)
    out = [0.0] * (n + m - 1)
    for i in range(n):
        ai = a[i]
        for j in range(m):
            out[i + j] += ai * b[j]
    _cache.put(key, out)
    return out


# ---------------- Optimization ----------------
@_timeit("gradient_descent")
def gradient_descent(
    f, grad, x0: float, lr: float = 0.1, max_iter: int = 1000, tol: float = 1e-6
) -> float:
    x = float(x0)
    for _ in range(max_iter):
        g = float(grad(x))
        if abs(g) < tol:
            break
        x -= lr * g
    return x


@_timeit("simulated_annealing")
def simulated_annealing(
    f,
    x0: float,
    T0: float = 1.0,
    alpha: float = 0.99,
    max_iter: int = 1000,
    step: float = 1.0,
) -> float:
    import random

    x = float(x0)
    fx = float(f(x))
    best_x, best_f = x, fx
    T = float(T0)
    for _ in range(max_iter):
        xn = x + random.uniform(-step, step)
        fn = float(f(xn))
        if fn < fx:
            x, fx = xn, fn
        else:
            # accept uphill moves with Boltzmann probability
            try:
                import math as _m

                if random.random() < _m.exp((fx - fn) / max(T, 1e-12)):
                    x, fx = xn, fn
            except OverflowError:
                pass
        if fx < best_f:
            best_x, best_f = x, fx
        T *= alpha
    return best_x


@_timeit("genetic_algorithm")
def genetic_algorithm(
    f,
    pop_size: int = 24,
    generations: int = 60,
    bounds: Tuple[float, float] = (-5.0, 5.0),
    mutation_rate: float = 0.1,
    elite_frac: float = 0.5,
) -> float:
    import random

    lo, hi = bounds
    pop = [random.uniform(lo, hi) for _ in range(pop_size)]
    elite_k = max(1, int(pop_size * elite_frac))

    for _ in range(generations):
        scored = sorted(((float(f(x)), x) for x in pop), key=lambda t: t[0])
        elites = [x for _, x in scored[:elite_k]]
        children: List[float] = []
        while len(children) + elite_k < pop_size:
            p1, p2 = random.sample(elites, 2 if len(elites) >= 2 else 1)
            c = 0.5 * (p1 + p2) if isinstance(p2, float) else p1
            if random.random() < mutation_rate:
                c += random.uniform(-(hi - lo) * 0.05, (hi - lo) * 0.05)
            c = max(lo, min(hi, c))
            children.append(c)
        pop = elites + children

    best = min(pop, key=lambda x: float(f(x)))
    return best


@_timeit("linear_programming_simplex")
def linear_programming_simplex(
    c: Sequence[float], A: Sequence[Sequence[float]], b: Sequence[float]
) -> Tuple[List[float], float]:
    # Build initial tableau: [A | I | b] and objective [-c | 0 | 0]
    m = len(b)
    n = len(c)
    # tableau has m+1 rows, n + m slack cols + 1 RHS col
    cols = n + m + 1
    T: List[List[float]] = [[0.0] * cols for _ in range(m + 1)]

    # constraints
    for i in range(m):
        row = T[i]
        for j in range(n):
            row[j] = float(A[i][j])
        row[n + i] = 1.0  # slack
        row[-1] = float(b[i])

    # objective row
    obj = T[m]
    for j in range(n):
        obj[j] = -float(c[j])
    # slack coeffs already 0; RHS 0

    basis = [n + i for i in range(m)]  # track basic var indices

    def _pivot(piv_i: int, piv_j: int) -> None:
        # normalize pivot row
        pr = T[piv_i]
        piv = pr[piv_j]
        if abs(piv) < 1e-15:
            raise ZeroDivisionError("pivot too small")
        inv = 1.0 / piv
        for j in range(cols):
            pr[j] *= inv
        # eliminate pivot col from other rows
        for i in range(m + 1):
            if i == piv_i:
                continue
            r = T[i]
            factor = r[piv_j]
            if factor != 0.0:
                for j in range(cols):
                    r[j] -= factor * pr[j]

    while True:
        # entering variable: most negative coef in objective row
        obj = T[m]
        enter_j = min(range(cols - 1), key=lambda j: obj[j])
        if obj[enter_j] >= -1e-12:
            # optimal
            break
        # leaving variable: min ratio test
        ratios = []
        for i in range(m):
            ai = T[i][enter_j]
            if ai > 1e-12:
                ratios.append((T[i][-1] / ai, i))
        if not ratios:
            raise ValueError("unbounded LP")
        _, leave_i = min(ratios, key=lambda t: t[0])
        _pivot(leave_i, enter_j)
        basis[leave_i] = enter_j

    # extract solution
    x = [0.0] * n
    for i in range(m):
        bi = basis[i]
        if bi < n:
            x[bi] = T[i][-1]
    value = T[m][-1]
    return x, value


# ---------------- Hybrid algorithms ----------------
@_timeit("hybrid_sa_gd")
def hybrid_sa_gd(
    f,
    grad,
    x0: float,
    sa_T0: float = 1.0,
    sa_alpha: float = 0.98,
    sa_iter: int = 400,
    sa_step: float = 1.0,
    gd_lr: float = 0.1,
    gd_iter: int = 600,
    gd_tol: float = 1e-6,
) -> float:
    import random, math as _m

    x = float(x0)
    fx = float(f(x))
    T = float(sa_T0)
    for _ in range(sa_iter):
        xn = x + random.uniform(-sa_step, sa_step)
        fn = float(f(xn))
        if fn < fx or random.random() < _m.exp((fx - fn) / max(T, 1e-12)):
            x, fx = xn, fn
        T *= sa_alpha
    for _ in range(gd_iter):
        g = float(grad(x))
        if abs(g) < gd_tol:
            break
        x -= gd_lr * g
    return x


@_timeit("hybrid_bisect_newton")
def hybrid_bisect_newton(
    f,
    df,
    a: float,
    b: float,
    bisect_iter: int = 40,
    newton_iter: int = 40,
    tol: float = 1e-12,
) -> float:
    fa, fb = float(f(a)), float(f(b))
    if fa == 0.0:
        return a
    if fb == 0.0:
        return b
    if fa * fb > 0:
        raise ValueError("root not bracketed")
    L, R = float(a), float(b)
    for _ in range(bisect_iter):
        m = 0.5 * (L + R)
        fm = float(f(m))
        if abs(fm) < tol:
            return m
        if fa * fm <= 0:
            R, fb = m, fm
        else:
            L, fa = m, fm
    x = 0.5 * (L + R)
    for _ in range(newton_iter):
        fx = float(f(x))
        if abs(fx) < tol:
            return x
        dfx = float(df(x))
        if dfx == 0.0:
            break
        x -= fx / dfx
    return x


@_timeit("hybrid_rk4_shoot_bisect")
def hybrid_rk4_shoot_bisect(
    ode,
    t0: float,
    t1: float,
    y0: float,
    y1_target: float,
    slope_lo: float,
    slope_hi: float,
    steps: int = 200,
    tol: float = 1e-6,
) -> Tuple[float, List[float]]:
    def rk4(y0, s):
        h = (t1 - t0) / steps
        t = t0
        y = y0
        v = s
        for _ in range(steps):

            def f(t, y, v):
                return (
                    ode(t, y),
                    v,
                )  # ode: dy/dt = f(t, y). v-slot is unused in this lite version.

            k1y, k1v = f(t, y, v)
            k2y, k2v = f(t + 0.5 * h, y + 0.5 * h * k1y, v + 0.5 * h * k1v)
            k3y, k3v = f(t + 0.5 * h, y + 0.5 * h * k2y, v + 0.5 * h * k2v)
            k4y, k4v = f(t + h, y + h * k3y, v + h * k3v)
            y += (h / 6.0) * (k1y + 2 * k2y + 2 * k3y + k4y)
            v += (h / 6.0) * (k1v + 2 * k2v + 2 * k3v + k4v)
            t += h
        return y

    lo, hi = float(slope_lo), float(slope_hi)
    y_lo = rk4(y0, lo) - y1_target
    y_hi = rk4(y0, hi) - y1_target
    if y_lo * y_hi > 0:
        raise ValueError("target not bracketed by slopes")
    for _ in range(60):
        mid = 0.5 * (lo + hi)
        y_mid = rk4(y0, mid) - y1_target
        if abs(y_mid) < tol:
            return mid, [y0, y1_target]
        if y_lo * y_mid <= 0:
            hi, y_hi = mid, y_mid
        else:
            lo, y_lo = mid, y_mid
    s = 0.5 * (lo + hi)
    return s, [y0, rk4(y0, s)]


@_timeit("sudoku_solve_mrv")
def sudoku_solve_mrv(board: List[List[int]]) -> List[List[int]]:
    N = 9
    rows = [set(range(1, 10)) for _ in range(N)]
    cols = [set(range(1, 10)) for _ in range(N)]
    boxes = [set(range(1, 10)) for _ in range(N)]
    empties = []
    for r in range(N):
        for c in range(N):
            v = board[r][c]
            b = (r // 3) * 3 + (c // 3)
            if v == 0:
                empties.append((r, c))
            else:
                rows[r].discard(v)
                cols[c].discard(v)
                boxes[b].discard(v)

    from functools import lru_cache

    @lru_cache(maxsize=1 << 14)
    def key_snapshot():
        return tuple(tuple(row) for row in board)

    def candidates(r, c):
        b = (r // 3) * 3 + (c // 3)
        return rows[r] & cols[c] & boxes[b]

    def pick_mrv():
        best = None
        best_opts = None
        for r, c in empties:
            if board[r][c] != 0:
                continue
            opts = candidates(r, c)
            if best is None or len(opts) < len(best_opts):
                best, best_opts = (r, c), opts
                if len(best_opts) == 1:
                    break
        return best, best_opts

    def place(r, c, v):
        b = (r // 3) * 3 + (c // 3)
        board[r][c] = v
        rows[r].discard(v)
        cols[c].discard(v)
        boxes[b].discard(v)

    def unplace(r, c, v):
        b = (r // 3) * 3 + (c // 3)
        board[r][c] = 0
        rows[r].add(v)
        cols[c].add(v)
        boxes[b].add(v)

    def solve():
        if all(board[r][c] != 0 for r, c in empties):
            return True
        pos, opts = pick_mrv()
        if pos is None:
            return True
        r, c = pos
        for v in sorted(opts):
            place(r, c, v)
            if solve():
                return True
            unplace(r, c, v)
        return False

    solve()
    return board


@_timeit("dh_kdf_sha256")
def dh_kdf_sha256(p: int, g: int, a_priv: int, b_priv: int) -> Tuple[int, bytes]:
    import hashlib

    A = pow(g, a_priv, p)
    B = pow(g, b_priv, p)
    s1 = pow(B, a_priv, p)
    s2 = pow(A, b_priv, p)
    if s1 != s2:
        raise ArithmeticError("DH mismatch")
    shared = s1
    k = hashlib.sha256(str(shared).encode()).digest()
    return shared, k


# ---------------- IR ----------------
class IRNode:
    def __init__(self, op: str, args: Tuple[Any, ...]) -> None:
        self.op = op
        self.args = args
        self.variant = None


class AutoVariantIntegrator:
    def choose(self, op: str, args: Tuple[Any, ...]) -> str:
        _, _, rate = _cache.stats()
        if op == "matmul":
            A, B = args
            r, k = (len(A), len(A[0]) if A else 0)
            _, c = (len(B), len(B[0]) if B else 0)
            work = r * k * c
            return "matmul" if (rate >= 0.3 and work >= 256) else "matmul_naive"
        if op == "fft":
            n = len(args[0])
            return "fft_iterative" if (rate >= 0.3 and n > 32) else "fft_recursive"
        return op


_integrator = AutoVariantIntegrator()


class IRExecutor:
    def run(self, node: IRNode) -> Any:
        def _mk_key():
            try:
                hash(node.args)
                return (node.op, node.args)
            except Exception:
                return None

        key = _mk_key()
        if key is not None:
            cached = _cache.get(key)
            if cached is not None:
                node.variant = "cache"
                return cached

        variant = _integrator.choose(node.op, node.args)
        node.variant = variant

        if variant == "add":
            out = add(*node.args)
        elif variant == "sub":
            out = sub(*node.args)
        elif variant == "mul":
            out = mul(*node.args)
        elif variant == "div":
            out = div(*node.args)
        elif variant == "dot":
            out = dot(*node.args)
        elif variant == "matmul":
            out = matmul(*node.args)
        elif variant == "matmul_naive":
            out = _matmul_naive(*node.args)
        elif variant == "fft_recursive":
            out = _fft_recursive(*node.args)
        elif variant == "fft_iterative":
            out = _fft_iterative(*node.args)
        elif variant == "conv":
            out = conv(*node.args)
        elif variant == "gd":
            out = gradient_descent(*node.args)
        elif variant == "sa":
            out = simulated_annealing(*node.args)
        elif variant == "ga":
            out = genetic_algorithm(*node.args)
        elif variant == "lp_simplex":
            out = linear_programming_simplex(*node.args)
        elif variant == "hybrid_sa_gd":
            out = hybrid_sa_gd(*node.args)
        elif variant == "hybrid_bisect_newton":
            out = hybrid_bisect_newton(*node.args)
        elif variant == "hybrid_rk4_shoot_bisect":
            out = hybrid_rk4_shoot_bisect(*node.args)
        elif variant == "sudoku_solve_mrv":
            out = sudoku_solve_mrv(*node.args)
        elif variant == "dh_kdf_sha256":
            out = dh_kdf_sha256(*node.args)
        else:
            raise ValueError("unknown op " + variant)

        if key is not None:
            _cache.put(key, out)
        return out


# ---------------- CLI Shell ----------------
def shell():
    exe = IRExecutor()
    print("Charithmetic Shell (type 'exit' to quit)")
    while True:
        try:
            line = input("> ").strip()
        except (EOFError, KeyboardInterrupt):
            break
        if not line or line.lower() in ("exit", "quit"):
            break
        try:
            if "(" not in line:
                print("Usage: op(args...) e.g. add(2,3)")
                continue
            op, rest = line.split("(", 1)
            op = op.strip()
            args = ast.literal_eval("(" + rest)
            node = IRNode(op, args)
            result = exe.run(node)
            print("Result:", result)
            print("Variant:", node.variant)
            print("Metrics:", _metrics.snapshot()["ops"].get(op, {}))
        except Exception as e:
            print("Error:", e)


# ---------------- Entry ----------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--shell", action="store_true", help="run interactive calculation shell"
    )
    args = parser.parse_args()
    if args.shell:
        shell()
    else:
        exe = IRExecutor()
        node = IRNode("add", (2.0, 3.0))
        print("Demo add:", exe.run(node))
        print("Metrics:", _metrics.snapshot())
        print("Charithmetic Shell | MIT | type 'exit' to quit")
